<html><head><meta charset="utf-8" lang="kotlin">

</head><body style="visibility: visible;" id="md"><meta charset="UTF-8"><meta http-equiv="content-type" content="text/html;charset=UTF-8"><meta name="viewport" content="width=600, initial-scale=1"><style>body{max-width:680px;margin:auto;padding:20px;text-align:justify;line-height:140%;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-smoothing:antialiased;color:#222;font-family:Palatino,Georgia,"Times New Roman",serif}</style><style>@media print{*{-webkit-print-color-adjust:exact;text-shadow:none !important}}body{counter-reset: h1 paragraph line item list-item}@page{margin:0;size:auto}#mdContextMenu{position:absolute;background:#383838;cursor:default;border:1px solid #999;color:#fff;padding:4px 0px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,"Helvetica Neue",sans-serif;font-size:85%;font-weight:600;border-radius:4px;box-shadow:0px 3px 10px rgba(0,0,0,35%)}#mdContextMenu div{padding:0px 20px}#mdContextMenu div:hover{background:#1659d1}.md code,.md pre{font-family:Menlo,Consolas,monospace;font-size:85%;text-align:left;line-height:140%}.md .mediumToc code,.md longToc code,.md .shortToc code,.md h1 code,.md h2 code,.md h3 code,.md h4 code,.md h5 code,.md h6 code{font-size:unset}.md div.title{font-size:26px;font-weight:800;line-height:120%;text-align:center}.md div.afterTitles{height:10px}.md div.subtitle{text-align:center}.md iframe.textinsert, .md object.textinsert,.md iframe:not(.markdeep){display:block;margin-top:10px;margin-bottom:10px;width:100%;height:75vh;border:1px solid #000;border-radius:4px;background:#f5f5f4}.md .image{display:inline-block}.md img{max-width:100%;page-break-inside:avoid}.md li{text-align:left;text-indent:0}.md pre.listing {width:100%;tab-size:4;-moz-tab-size:4;-o-tab-size:4;counter-reset:line;overflow-x:auto;resize:horizontal}.md pre.listing .linenumbers span.line:before{width:30px;margin-left:-28px;font-size:80%;text-align:right;counter-increment:line;content:counter(line);display:inline-block;padding-right:13px;margin-right:8px;color:#ccc}.md div.tilde{margin:20px 0 -10px;text-align:center}.md .imagecaption,.md .tablecaption,.md .listingcaption{display:inline-block;margin:7px 5px 12px;text-align:justify;font-style:italic}.md img.pixel{image-rendering:-moz-crisp-edges;image-rendering:pixelated}.md blockquote.fancyquote{margin:25px 0 25px;text-align:left;line-height:160%}.md blockquote.fancyquote::before{content:"“";color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-right:6px;vertical-align:-0.3em}.md span.fancyquote{font-size:118%;color:#777;font-style:italic}.md span.fancyquote::after{content:"”";font-style:normal;color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-left:6px;vertical-align:-0.3em}.md blockquote.fancyquote .author{width:100%;margin-top:10px;display:inline-block;text-align:right}.md small{font-size:60%}.md big{font-size:150%}.md div.title,contents,.md .tocHeader,.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .shortTOC,.md .mediumTOC,.nonumberh1,.nonumberh2,.nonumberh3,.nonumberh4,.nonumberh5,.nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;margin:13.4px 0 13.4px;padding:15px 0 3px;border-top:none;clear:both}.md .tocTop {display:none}.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .nonumberh1,.md .nonumberh2,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{page-break-after:avoid;break-after:avoid}.md svg.diagram{display:block;font-family:Menlo,Consolas,monospace;font-size:85%;text-align:center;stroke-linecap:round;stroke-width:2px;page-break-inside:avoid;stroke:#000;fill:#000}.md svg.diagram .opendot{fill:#fff}.md svg.diagram .shadeddot{fill:#CCC}.md svg.diagram .dotteddot{stroke:#000;stroke-dasharray:4;fill:none}.md svg.diagram text{stroke:none}@media print{@page{margin:1in 5mm;transform: scale(150%)}}@media print{.md .pagebreak{page-break-after:always;visibility:hidden}}.md a{font-family:Georgia,Palatino,'Times New Roman'}.md h1,.md .tocHeader,.md .nonumberh1{border-bottom:3px solid;font-size:20px;font-weight:bold;}.md h1,.md .nonumberh1{counter-reset:h2 h3 h4 h5 h6}.md h2,.md .nonumberh2{counter-reset:h3 h4 h5 h6;border-bottom:2px solid #999;color:#555;font-weight:bold;font-size:18px;}.md h3,.md h4,.md h5,.md h6,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;color:#555;font-size:16px;}.md h3{counter-reset:h4 h5 h6}.md h4{counter-reset:h5 h6}.md h5{counter-reset:h6}.md div.table{margin:16px 0 16px 0}.md table{border-collapse:collapse;line-height:140%;page-break-inside:avoid}.md table.table{margin:auto}.md table.calendar{width:100%;margin:auto;font-size:11px;font-family:Verdana,Helvetica,Arial,sans-serif}.md table.calendar th{font-size:16px}.md .today{background:#ECF8FA}.md .calendar .parenthesized{color:#999;font-style:italic}.md table.table th{color:#FFF;background-color:#AAA;border:1px solid #888;padding:8px 15px 8px 15px}.md table.table td{padding:5px 15px 5px 15px;border:1px solid #888}.md table.table tr:nth-child(even){background:#EEE}.md pre.tilde{border-top: 1px solid #CCC;border-bottom: 1px solid #CCC;padding: 5px 0 5px 20px;margin:0 0 0 0;background:#FCFCFC;page-break-inside:avoid}.md a.target{width:0px;height:0px;visibility:hidden;font-size:0px;display:inline-block}.md a:link, .md a:visited{color:#38A;text-decoration:none}.md a:link:hover{text-decoration:underline}.md dt{font-weight:700}.md dl>dd{margin-top:-8px; margin-bottom:8px}.md dl>table{margin:35px 0 30px}.md code{page-break-inside:avoid;} @media print{.md .listing code{white-space:pre-wrap}}.md .endnote{font-size:13px;line-height:15px;padding-left:10px;text-indent:-10px}.md .bib{padding-left:80px;text-indent:-80px;text-align:left}.markdeepFooter{font-size:9px;text-align:right;padding-top:80px;color:#999}.md .mediumTOC{float:right;font-size:12px;line-height:15px;border-left:1px solid #CCC;padding-left:15px;margin:15px 0px 15px 25px}.md .mediumTOC .level1{font-weight:600}.md .longTOC .level1{font-weight:600;display:block;padding-top:12px;margin:0 0 -20px}.md .shortTOC{text-align:center;font-weight:bold;margin-top:15px;font-size:14px}.md .admonition{position:relative;margin:1em 0;padding:.4rem 1rem;border-radius:.2rem;border-left:2.5rem solid rgba(68,138,255,.4);background-color:rgba(68,138,255,.15);}.md .admonition-title{font-weight:bold;border-bottom:solid 1px rgba(68,138,255,.4);padding-bottom:4px;margin-bottom:4px;margin-left: -1rem;padding-left:1rem;margin-right:-1rem;border-color:rgba(68,138,255,.4)}.md .admonition.tip{border-left:2.5rem solid rgba(50,255,90,.4);background-color:rgba(50,255,90,.15)}.md .admonition.tip::before{content:"\24d8";font-weight:bold;font-size:150%;position:relative;top:3px;color:rgba(26,128,46,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.tip>.admonition-title{border-color:rgba(50,255,90,.4)}.md .admonition.warn,.md .admonition.warning{border-left:2.5rem solid rgba(255,145,0,.4);background-color:rgba(255,145,0,.15)}.md .admonition.warn::before,.md .admonition.warning::before{content:"\26A0";font-weight:bold;font-size:150%;position:relative;top:2px;color:rgba(128,73,0,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.warn>.admonition-title,.md .admonition.warning>.admonition-title{border-color:rgba(255,145,0,.4)}.md .admonition.error{border-left: 2.5rem solid rgba(255,23,68,.4);background-color:rgba(255,23,68,.15)}.md .admonition.error>.admonition-title{border-color:rgba(255,23,68,.4)}.md .admonition.error::before{content: "\2612";font-family:"Arial";font-size:200%;position:relative;color:rgba(128,12,34,.8);top:-2px;left:-3rem;display:block;width:0;height:0}.md .admonition p:last-child{margin-bottom:0}.md li.checked,.md li.unchecked{list-style:none;overflow:visible;text-indent:-1.2em}.md li.checked:before,.md li.unchecked:before{content:"\2611";display:block;float:left;width:1em;font-size:120%}.md li.unchecked:before{content:"\2610"}</style><style>.md h1::before {
content:counter(h1) " ";
counter-increment: h1;margin-right:10px}

.md h2::before {
content:counter(h1) "."counter(h2) " ";
counter-increment: h2;margin-right:10px}

.md h3::before {
content:counter(h1) "."counter(h2) "."counter(h3) " ";
counter-increment: h3;margin-right:10px}

.md h4::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) " ";
counter-increment: h4;margin-right:10px}

.md h5::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) " ";
counter-increment: h5;margin-right:10px}

.md h6::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) "."counter(h6) " ";
counter-increment: h6;margin-right:10px}

</style><style>.hljs{display:block;overflow-x:auto;padding:0.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword{color:#02E}.hljs-literal,.nginx .hljs-title{color:#aa0d91}.method,.hljs-list .hljs-title,.hljs-tag .hljs-title,.setting .hljs-value,.hljs-winutils,.tex .hljs-command,.http .hljs-title,.hljs-request,.hljs-status,.hljs-name{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.hljs-tag .hljs-value,.hljs-cdata,.hljs-filter .hljs-argument,.hljs-attr_selector,.apache .hljs-cbracket,.hljs-date,.hljs-regexp{color:#080}.hljs-sub .hljs-identifier,.hljs-pi,.hljs-tag,.hljs-tag .hljs-keyword,.hljs-decorator,.ini .hljs-title,.hljs-shebang,.hljs-prompt,.hljs-hexcolor,.hljs-rule .hljs-value,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-number,.css .hljs-function,.hljs-function .hljs-title,.coffeescript .hljs-attribute{color:#A0C}.hljs-function .hljs-title{font-weight:bold;color:#000}.hljs-class .hljs-title,.smalltalk .hljs-class,.hljs-type,.hljs-typename,.hljs-tag .hljs-attribute,.hljs-doctype,.hljs-class .hljs-id,.hljs-built_in,.setting,.hljs-params,.clojure .hljs-attribute{color:#5c2699}.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-rule .hljs-property,.hljs-pseudo,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#ff7700;font-weight:bold}.hljs-rule .hljs-keyword{color:#c5af75}.hljs-annotation,.apache .hljs-sqbracket,.nginx .hljs-built_in{color:#9b859d}.hljs-preprocessor,.hljs-preprocessor *,.hljs-pragma{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:#808080;font-weight:bold}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:bold}.method .hljs-id{color:#000}</style><style>div.title { padding-top: 40px; } div.afterTitles { height: 15px; }</style><meta charset="utf-8" lang="kotlin">

<span class="md"><p><title>Android Lint API Guide</title></p><div class="title"> Android Lint API Guide </div>

<div class="afterTitles"></div>

<p></p><p>

This chapter inlines all the API documentation into a single
long book, suitable for printing or reading on a tablet.

</p>
<div class="longTOC"><div class="tocHeader">Contents</div><p><a href="#" class="tocTop">(Top)</a><br>
<a href="#terminology" class="level1"><span class="tocNumber">1&nbsp; </span>Terminology</a><br>
<a href="#writingalintcheck:basics" class="level1"><span class="tocNumber">2&nbsp; </span>Writing a Lint Check: Basics</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/preliminaries" class="level2"><span class="tocNumber">2.1&nbsp; </span>Preliminaries</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/preliminaries/%E2%80%9Clint?%E2%80%9D" class="level3"><span class="tocNumber">2.1.1&nbsp; </span>“Lint?”</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/preliminaries/apistability" class="level3"><span class="tocNumber">2.1.2&nbsp; </span>API Stability</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/preliminaries/kotlin" class="level3"><span class="tocNumber">2.1.3&nbsp; </span>Kotlin</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/concepts" class="level2"><span class="tocNumber">2.2&nbsp; </span>Concepts</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/clientapiversusdetectorapi" class="level2"><span class="tocNumber">2.3&nbsp; </span>Client API versus Detector API</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/creatinganissue" class="level2"><span class="tocNumber">2.4&nbsp; </span>Creating an Issue</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/textformat" class="level2"><span class="tocNumber">2.5&nbsp; </span>TextFormat</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/issueimplementation" class="level2"><span class="tocNumber">2.6&nbsp; </span>Issue Implementation</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/scopes" class="level2"><span class="tocNumber">2.7&nbsp; </span>Scopes</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/registeringtheissue" class="level2"><span class="tocNumber">2.8&nbsp; </span>Registering the Issue</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/implementingadetector:scanners" class="level2"><span class="tocNumber">2.9&nbsp; </span>Implementing a Detector: Scanners</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/detectorlifecycle" class="level2"><span class="tocNumber">2.10&nbsp; </span>Detector Lifecycle</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/scannerorder" class="level2"><span class="tocNumber">2.11&nbsp; </span>Scanner Order</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/implementingadetector:services" class="level2"><span class="tocNumber">2.12&nbsp; </span>Implementing a Detector: Services</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/scannerexample" class="level2"><span class="tocNumber">2.13&nbsp; </span>Scanner Example</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode" class="level2"><span class="tocNumber">2.14&nbsp; </span>Analyzing Kotlin and Java Code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/uast" class="level3"><span class="tocNumber">2.14.1&nbsp; </span>UAST</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/uastexample" class="level3"><span class="tocNumber">2.14.2&nbsp; </span>UAST Example</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/lookingupuast" class="level3"><span class="tocNumber">2.14.3&nbsp; </span>Looking up UAST</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/resolving" class="level3"><span class="tocNumber">2.14.4&nbsp; </span>Resolving</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/psi" class="level3"><span class="tocNumber">2.14.5&nbsp; </span>PSI</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/testing" class="level2"><span class="tocNumber">2.15&nbsp; </span>Testing</a><br>
<a href="#example:samplelintcheckgithubproject" class="level1"><span class="tocNumber">3&nbsp; </span>Example: Sample Lint Check GitHub Project</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/projectlayout" class="level2"><span class="tocNumber">3.1&nbsp; </span>Project Layout</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/:checks" class="level2"><span class="tocNumber">3.2&nbsp; </span>:checks</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/lintversion?" class="level2"><span class="tocNumber">3.3&nbsp; </span>lintVersion?</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/:libraryand:app" class="level2"><span class="tocNumber">3.4&nbsp; </span>:library and :app</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/lintcheckprojectlayout" class="level2"><span class="tocNumber">3.5&nbsp; </span>Lint Check Project Layout</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/serviceregistration" class="level2"><span class="tocNumber">3.6&nbsp; </span>Service Registration</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/issueregistry" class="level2"><span class="tocNumber">3.7&nbsp; </span>IssueRegistry</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/detector" class="level2"><span class="tocNumber">3.8&nbsp; </span>Detector</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/detectortest" class="level2"><span class="tocNumber">3.9&nbsp; </span>Detector Test</a><br>
<a href="#publishingalintcheck" class="level1"><span class="tocNumber">4&nbsp; </span>Publishing a Lint Check</a><br>
&nbsp;&nbsp;<a href="#publishingalintcheck/android" class="level2"><span class="tocNumber">4.1&nbsp; </span>Android</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publishingalintcheck/android/aarsupport" class="level3"><span class="tocNumber">4.1.1&nbsp; </span>AAR Support</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publishingalintcheck/android/lintpublishconfiguration" class="level3"><span class="tocNumber">4.1.2&nbsp; </span>lintPublish Configuration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publishingalintcheck/android/localchecks" class="level3"><span class="tocNumber">4.1.3&nbsp; </span>Local Checks</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publishingalintcheck/android/unpublishing" class="level3"><span class="tocNumber">4.1.4&nbsp; </span>Unpublishing</a><br>
<a href="#lintcheckunittesting" class="level1"><span class="tocNumber">5&nbsp; </span>Lint Check Unit Testing</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/creatingaunittest" class="level2"><span class="tocNumber">5.1&nbsp; </span>Creating a Unit Test</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/computingtheexpectedoutput" class="level2"><span class="tocNumber">5.2&nbsp; </span>Computing the Expected Output</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/testfiles" class="level2"><span class="tocNumber">5.3&nbsp; </span>Test Files</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/trimmingindents?" class="level2"><span class="tocNumber">5.4&nbsp; </span>Trimming indents?</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/dollarsinrawstrings" class="level2"><span class="tocNumber">5.5&nbsp; </span>Dollars in Raw Strings</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/quickfixes" class="level2"><span class="tocNumber">5.6&nbsp; </span>Quickfixes</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/librarydependenciesandstubs" class="level2"><span class="tocNumber">5.7&nbsp; </span>Library Dependencies and Stubs</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/binaryandcompiledsourcefiles" class="level2"><span class="tocNumber">5.8&nbsp; </span>Binary and Compiled Source Files</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/mydetectorisn'tinvokedfromatest!" class="level2"><span class="tocNumber">5.9&nbsp; </span>My Detector Isn't Invoked From a Test!</a><br>
<a href="#addingquickfixes" class="level1"><span class="tocNumber">6&nbsp; </span>Adding Quick Fixes</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/introduction" class="level2"><span class="tocNumber">6.1&nbsp; </span>Introduction</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/thelintfixbuilderclass" class="level2"><span class="tocNumber">6.2&nbsp; </span>The LintFix builder class</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/creatingalintfix" class="level2"><span class="tocNumber">6.3&nbsp; </span>Creating a LintFix</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/availablefixes" class="level2"><span class="tocNumber">6.4&nbsp; </span>Available Fixes</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/combiningfixes" class="level2"><span class="tocNumber">6.5&nbsp; </span>Combining Fixes</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/refactoringjavaandkotlincode" class="level2"><span class="tocNumber">6.6&nbsp; </span>Refactoring Java and Kotlin code</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/regularexpressionsandbackreferences" class="level2"><span class="tocNumber">6.7&nbsp; </span>Regular Expressions and Back References</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/emittingquickfixxmltoapplyonci" class="level2"><span class="tocNumber">6.8&nbsp; </span>Emitting quick fix XML to apply on CI</a><br>
<a href="#partialanalysis" class="level1"><span class="tocNumber">7&nbsp; </span>Partial Analysis</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/about" class="level2"><span class="tocNumber">7.1&nbsp; </span>About</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/theproblem" class="level2"><span class="tocNumber">7.2&nbsp; </span>The Problem</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/overview" class="level2"><span class="tocNumber">7.3&nbsp; </span>Overview</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?" class="level2"><span class="tocNumber">7.4&nbsp; </span>Does My Detector Need Work?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?/catchingmistakes:blockingaccesstomainproject" class="level3"><span class="tocNumber">7.4.1&nbsp; </span>Catching Mistakes: Blocking Access to Main Project</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?/catchingmistakes:simulatedappmodule" class="level3"><span class="tocNumber">7.4.2&nbsp; </span>Catching Mistakes: Simulated App Module</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?/catchingmistakes:diffingresults" class="level3"><span class="tocNumber">7.4.3&nbsp; </span>Catching Mistakes: Diffing Results</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?/catchingmistakes:remainingissues" class="level3"><span class="tocNumber">7.4.4&nbsp; </span>Catching Mistakes: Remaining Issues</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/incidents" class="level2"><span class="tocNumber">7.5&nbsp; </span>Incidents</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/constraints" class="level2"><span class="tocNumber">7.6&nbsp; </span>Constraints</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/incidentlintmaps" class="level2"><span class="tocNumber">7.7&nbsp; </span>Incident LintMaps</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/modulelintmaps" class="level2"><span class="tocNumber">7.8&nbsp; </span>Module LintMaps</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/optimizations" class="level2"><span class="tocNumber">7.9&nbsp; </span>Optimizations</a><br>
<a href="#frequentlyaskedquestions" class="level1"><span class="tocNumber">8&nbsp; </span>Frequently Asked Questions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//mydetectorcallbacksaren'tinvoked" class="level3"><span class="tocNumber">8.0.1&nbsp; </span>My detector callbacks aren't invoked</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//mylintcheckworksfromtheunittestbutnotintheide" class="level3"><span class="tocNumber">8.0.2&nbsp; </span>My lint check works from the unit test but not in the IDE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//visitannotationusageisn'tcalledforannotations" class="level3"><span class="tocNumber">8.0.3&nbsp; </span><code>visitAnnotationUsage</code> isn't called for annotations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoicheckifauastorpsielementisforjavaorkotlin?" class="level3"><span class="tocNumber">8.0.4&nbsp; </span>How do I check if a UAST or PSI element is for Java or Kotlin?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//whatifineedapsielementandihaveauelement?" class="level3"><span class="tocNumber">8.0.5&nbsp; </span>What if I need a <code>PsiElement</code> and I have a <code>UElement</code> ?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoigettheumethodforapsimethod?" class="level3"><span class="tocNumber">8.0.6&nbsp; </span>How do I get the <code>UMethod</code> for a <code>PsiMethod</code> ?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdogetajavaevaluator?" class="level3"><span class="tocNumber">8.0.7&nbsp; </span>How do get a <code>JavaEvaluator</code> ?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoicheckwhetheranelementisinternal?" class="level3"><span class="tocNumber">8.0.8&nbsp; </span>How do I check whether an element is internal?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//iselementinline,sealed,operator,infix,suspend,data?" class="level3"><span class="tocNumber">8.0.9&nbsp; </span>Is element inline, sealed, operator, infix, suspend, data?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoilookupaclassifihaveitsfullyqualifiedname?" class="level3"><span class="tocNumber">8.0.10&nbsp; </span>How do I look up a class if I have its fully qualified name?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoilookupaclassifihaveapsitype?" class="level3"><span class="tocNumber">8.0.11&nbsp; </span>How do I look up a class if I have a PsiType?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoilookuphierarhcyannotationsforanelement?" class="level3"><span class="tocNumber">8.0.12&nbsp; </span>How do I look up hierarhcy annotations for an element?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoilookupifaclassisasubclassofanother?" class="level3"><span class="tocNumber">8.0.13&nbsp; </span>How do I look up if a class is a subclass of another?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoiknowwhichparameteracallargumentcorrespondsto?" class="level3"><span class="tocNumber">8.0.14&nbsp; </span>How do I know which parameter a call argument corresponds to?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howcanmylintcheckstargettwodifferentversionsoflint?" class="level3"><span class="tocNumber">8.0.15&nbsp; </span>How can my lint checks target two different versions of lint?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//canimakemylintcheck%E2%80%9Cnotsuppressible?%E2%80%9D" class="level3"><span class="tocNumber">8.0.16&nbsp; </span>Can I make my lint check “not suppressible?”</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoicheckoutthecurrentlintsourcecode?" class="level3"><span class="tocNumber">8.0.17&nbsp; </span>How do I check out the current lint source code?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//wheredoifindexamplesoflintchecks?" class="level3"><span class="tocNumber">8.0.18&nbsp; </span>Where do I find examples of lint checks?</a><br>
<a href="#appendix:recentchanges" class="level1"><span class="tocNumber">9&nbsp; </span>Appendix: Recent Changes</a><br>
<a href="#appendix:environmentvariablesandsystemproperties" class="level1"><span class="tocNumber">10&nbsp; </span>Appendix: Environment Variables and System Properties</a><br>
&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/environmentvariables" class="level2"><span class="tocNumber">10.1&nbsp; </span>Environment Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/environmentvariables/detectorconfigurationvariables" class="level3"><span class="tocNumber">10.1.1&nbsp; </span>Detector Configuration Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/environmentvariables/lintconfigurationvariables" class="level3"><span class="tocNumber">10.1.2&nbsp; </span>Lint Configuration Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/environmentvariables/lintdevelopmentvariables" class="level3"><span class="tocNumber">10.1.3&nbsp; </span>Lint Development Variables</a><br>
&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/systemproperties" class="level2"><span class="tocNumber">10.2&nbsp; </span>System Properties</a><br>
</p></div><a class="target" name="terminology">&nbsp;</a><a class="target" name="terminology">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>Terminology</h1>
<p>


You don't need to read this up front and understand everything, but
this is hopefully a handy reference to return to.

</p><p>

In alphabetical order:

</p><p>

</p><dl><dt>Configuration</dt><dd><p>  A configuration provides extra information or parameters to lint on a
  per project, or even per directory basis. For example, the <code>lint.xml</code>
  files can change the severity for issues, or list incidents to ignore
  (matched for example by a regular expression), or even provide values
  for options read by a specific detector.

</p></dd><dt>Context</dt><dd><p>  An object passed into detectors in many APIs, providing data about
  (for example) which file is being analyzed (and in which project),
  and for specific types of analysis additional information; for
  example, an XmlContext points to the DOM document, a JavaContext
  includes the AST, and so on.

</p></dd><dt>Detector</dt><dd><p>  The implementation of the lint check which registers Issues, analyzes
  the code, and reports Incidents.

</p></dd><dt>Implementation</dt><dd><p>  An <code>Implementation</code> tells lint how a given issue is actually
  analyzed, such as which detector class to instantiate, as well as
  which scopes the detector applies to.

</p></dd><dt>Incident</dt><dd><p>  A specific occurrence of the issue at a specific location.
  An example of an incident is:
  </p><pre class="listing backtick"><code><span class="line">    Warning: In file IoUtils.kt, line 140, the field download folder</span>
<span class="line">    is "/sdcard/downloads"; do not hardcode the path to `/sdcard`.</span></code></pre></dd><dt>Issue</dt><dd><p>  A type or class of problem that your lint check identifies. An issue
  has an associated severity (error, warning or info), a priority, a
  category, an explanation, and so on.

</p><p>

  An example of an issue is “Don't hardcode paths to /sdcard”.

</p></dd><dt>IssueRegistry</dt><dd><p>  An <code>IssueRegistry</code> provides a list of issues to lint. When you write
  one or more lint checks, you'll register these in an <code>IssueRegistry</code>
  and point to it using the <code>META-INF</code> service loader mechanism.

</p></dd><dt>LintClient</dt><dd><p>  The <code>LintClient</code> represents the specific tool the detector is running
  in. For example, when running in the IDE there is a LintClient which
  (when incidents are reported) will show highlights in the editor,
  whereas when lint is running as part of the Gradle plugin, incidents
  are instead accumulated into HTML (and XML and text) reports, and
  the build interrupted on error.

</p></dd><dt>Location</dt><dd><p>  A “location” refers to a place where an incident is reported.
  Typically this refers to a text range within a source file, but a
  location can also point to a binary file such as a <code>png</code> file.
  Locations can also be linked together, along with descriptions.
  Therefore, if you for example are reporting a duplicate declaration,
  you can include <strong class="asterisk">both</strong> Locations, and in the IDE, both locations
  (if they're in the same file) will be highlighted. A location linked
  from another is called a “secondary” location, but the chaining can
  be as long as you want (and lint's unit testing infrastructure will
  make sure there are no cycles.)

</p></dd><dt>Partial Analysis</dt><dd><p>  A “map reduce” architecture in lint which makes it possible to
  analyze individual modules in isolation and then later filter and
  customize the partial results based on conditions outside of these
  modules. This is explained in greater detail in the
  <a href="#partialanalysis">partial analysis</a> chapter.

</p></dd><dt>Platform</dt><dd><p>  The <code>Platform</code> abstraction allows lint issues to indicate where they
  apply (such as “Android”, or “Server”, and so on). This means that an
  Android-specific check won't trigger warnings on non-Android code.

</p></dd><dt>Scanner</dt><dd><p>  A <code>Scanner</code> is a particular interface a detector can implement to
  indicate that it supports a specific set of callbacks. For example,
  the <code>XmlScanner</code> interface is where the methods for visiting XML
  elements and attributes are defined, and the <code>ClassScanner</code> is where
  the ASM bytecode handling methods are defined, and so on.

</p></dd><dt>Scope</dt><dd><p>  <code>Scope</code> is an enum which lists various types of files that a detector
  may want to analyze.

</p><p>

  For example, there is a scope for XML files, there is a scope for
  Java and Kotlin files, there is a scope for .class files, and so on.

</p><p>

  Typically lint cares about which <strong class="asterisk">set</strong> of scopes apply,
  so most of the APIs take an <code>EnumSet&lt; Scope&gt;</code>, but we'll often
  refer to this as just “the scope” instead of the “scope set”.

</p></dd><dt>Severity</dt><dd><p>  For an issue, whether the incident should be an error, or just a
  warning, or neither (just an FYI highlight). There is also a special
  type of error severity, “fatal”, discussed later.

</p></dd><dt>TextFormat</dt><dd><p>  An enum describing various text formats lint understands. Lint checks
  will typically only operate with the “raw” format, which is
  markdown-like (e.g. you can surround words with an asterisk to make
  it italics or two to make it bold, and so on).

</p></dd><dt>Vendor</dt><dd><p>  A <code>Vendor</code> is a simple data class which provides information about
  the provenance of a lint check: who wrote it, where to file issues,
  and so on.

</p></dd></dl><p></p>
<a class="target" name="writingalintcheck:basics">&nbsp;</a><a class="target" name="writingalintcheck:basics">&nbsp;</a><a class="target" name="toc2">&nbsp;</a><h1>Writing a Lint Check: Basics</h1>

<a class="target" name="preliminaries">&nbsp;</a><a class="target" name="writingalintcheck:basics/preliminaries">&nbsp;</a><a class="target" name="toc2.1">&nbsp;</a><h2>Preliminaries</h2>
<p>


(If you already know a lot of the basics but you're here because you've
run into a problem and you're consulting the docs, take a look at the
<a href="#frequentlyaskedquestions">frequently asked questions</a> chapter.)

</p>
<a class="target" name="%E2%80%9Clint?%E2%80%9D">&nbsp;</a><a class="target" name="writingalintcheck:basics/preliminaries/%E2%80%9Clint?%E2%80%9D">&nbsp;</a><a class="target" name="toc2.1.1">&nbsp;</a><h3>“Lint?”</h3>
<p>


The <code>lint</code> tool shipped with the C compiler and provided additional
static analysis of C code beyond what the compiler checked.

</p><p>

Android Lint was named in honor of this tool, and with the Android
prefix to make it really clear that this is a static analysis tool
intended for analysis of Android code, provided by the Android Open
Source Project — and to disambiguate it from the many other tools with
“lint“ in their names.

</p><p>

However, since then, Android Lint has broadened its support and is no
longer intended only for Android code. In fact, within Google, it is
used to analyze all Java and Kotlin code. One of the reasons for this
is that it can easily analyze both Java and Kotlin code without having
to implement the checks twice. Additional features are described in the
<a href="api-guide/../features.html.md">features</a> chapter.

</p><p>

We're planning to rename lint to reflect this new role, so we are
looking for good name suggestions.

</p>
<a class="target" name="apistability">&nbsp;</a><a class="target" name="writingalintcheck:basics/preliminaries/apistability">&nbsp;</a><a class="target" name="toc2.1.2">&nbsp;</a><h3>API Stability</h3>
<p>


Lint's APIs are still marked as @Beta, and we have made it very clear
all along that this is not a stable API, so custom lint checks may need
to be updated periodically to keep working.

</p><p>

However, ”some APIs are more stable than others“. In particular, the
detector API (described below) is much less likely to change than the
client API (which is not intended for lint check authors but for tools
integrating lint to run within, such as IDEs and build systems).

</p><p>

However, this doesn't mean the detector API won't change. A large part
of the API surface is external to lint; it's the AST libraries (PSI and
UAST) for Java and Kotlin from JetBrains; it's the bytecode library
(asm.ow2.io), it's the XML DOM library (org.w3c.dom), and so on. Lint
intentionally stays up to date with these, so any API or behavior
changes in these can affect your lint checks.

</p><p>

Lint's own APIs may also change. The current API has grown organically
over the last 10 years (the first version of lint was released in 2011)
and there are a number of things we'd clean up and do differently if
starting over. Not to mention rename and clean up inconsistencies.

</p><p>

However, lint has been pretty widely adopted, so at this point creating
a nicer API would probably cause more harm than good, so we're limiting
recent changes to just the necessary ones. An example of this is the
new <a href="#partialanalysis">partial analysis</a> architecture in 7.0
which is there to allow much better CI and incremental analysis
performance.

</p>
<a class="target" name="kotlin">&nbsp;</a><a class="target" name="writingalintcheck:basics/preliminaries/kotlin">&nbsp;</a><a class="target" name="toc2.1.3">&nbsp;</a><h3>Kotlin</h3>
<p>


We recommend that you implement your checks in Kotlin. Part of
the reason for that is that the lint API uses a number of Kotlin
features:

</p><p>

</p><ul>
<li class="asterisk"><strong class="asterisk">Named and default parameters</strong>: Rather than using builders, some
  construction methods, like <code>Issue.create()</code> have a lot of parameters
  with default parameters. The API is cleaner to use if you just
  specify what you need and rely on defaults for everything else.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk">Compatibility</strong>: We may add additional parameters over time. It
  isn't practical to add @JvmOverloads on everything.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk">Package-level functions</strong>: Lint's API includes a number of package
  level utility functions (in previous versions of the API these are all
  thrown together in a <code>LintUtils</code> class).

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk">Deprecations</strong>: Kotlin has support for simple API migrations. For
  example, in the below example, the new <code>@Deprecated</code> annotation on
  lines 1 through 7 will be added in an upcoming release, to ease
  migration to a new API. IntelliJ can automatically quickfix these
  deprecation replacements.</li></ul>

<p></p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-meta">@Deprecated(</span>
<span class="line">    <span class="hljs-meta-string">"Use the new report(Incident) method instead, which is more future proof"</span>,</span>
<span class="line">    ReplaceWith(</span>
<span class="line">        <span class="hljs-meta-string">"report(Incident(issue, message, location, null, quickfixData))"</span>,</span>
<span class="line">        <span class="hljs-meta-string">"com.android.tools.lint.detector.api.Incident"</span></span>
<span class="line">    )</span></span>
<span class="line">)</span>
<span class="line"><span class="hljs-meta">@JvmOverloads</span></span>
<span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">report</span><span class="hljs-params">(</span>
<span class="line">    issue: <span class="hljs-type">Issue</span>,</span>
<span class="line">    location: <span class="hljs-type">Location</span>,</span>
<span class="line">    message: <span class="hljs-type">String</span>,</span>
<span class="line">    quickfixData: <span class="hljs-type">LintFix</span>? = <span class="hljs-literal">null</span></span>
<span class="line">)</span></span> {</span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">}</span></div></code></pre><p>

As of 7.0, there is more Kotlin code in lint than remaining Java
code:
</p><div class="table">
<table class="table"><tbody><tr><th style="text-align:left"> Language </th><th style="text-align:right"> files </th><th style="text-align:right"> blank </th><th style="text-align:right"> comment </th><th style="text-align:right"> code </th></tr>
<tr><td style="text-align:left"> Kotlin </td><td style="text-align:right"> 420 </td><td style="text-align:right"> 14243 </td><td style="text-align:right"> 23239 </td><td style="text-align:right"> 130250 </td></tr>
<tr><td style="text-align:left"> Java </td><td style="text-align:right"> 289 </td><td style="text-align:right"> 8683 </td><td style="text-align:right"> 15205 </td><td style="text-align:right"> 101549 </td></tr>
</tbody></table><center><div class="tablecaption"><code>$ cloc lint/</code></div></center></div>

<p></p><p>

And that's for all of lint, including many old lint detectors which
haven't been touched in years. In the Lint API library,
<code>lint/libs/lint-api</code>, the code is 78% Kotlin and 22% Java.

</p>
<a class="target" name="concepts">&nbsp;</a><a class="target" name="writingalintcheck:basics/concepts">&nbsp;</a><a class="target" name="toc2.2">&nbsp;</a><h2>Concepts</h2>
<p>


Lint will search your source code for problems. There are many types of
problems, and each one is called an <code>Issue</code>, which has associated
metadata like a unique id, a category, an explanation, and so on.

</p><p>

Each instance that it finds is called an ”incident“.

</p><p>

The actual responsibility of searching for and reporting incidents is
handled by detectors — subclasses of <code>Detector</code>. Your lint check will
extend <code>Detector</code>, and when it has found a problem, it will ”report“
the incident to lint.

</p><p>

A <code>Detector</code> can analyze more than one <code>Issue</code>. For example, the
built-in <code>StringFormatDetector</code> analyzes formatting strings passed to
<code>String.format()</code> calls, and in the process of doing that discovers
multiple unrelated issues — invalid formatting strings, formatting
strings which should probably use the plurals API instead, mismatched
types, and so on. The detector could simply have a single issue called
“StringFormatProblems” and report everything as a StringFormatProblem,
but that's not a good idea. Each of these individual types of String
format problems should have their own explanation, their own category,
their own severity, and most importantly should be individually
configurable by the user such that they can disable or promote one of
these issues separately from the others.

</p><p>

A <code>Detector</code> can indicate which sets of files it cares about. These are
called “scopes”, and the way this works is that when you register your
<code>Issue</code>, you tell that issue which <code>Detector</code> class is responsible for
analyzing it, as well as which scopes the detector cares about.

</p><p>

If for example a lint check wants to analyze Kotlin files, it can
include the <code>Scope.JAVA_FILE</code> scope, and now that detector will be
included when lint processes Java or Kotin files.

</p><p>

</p><div class="admonition tip">The name <code>Scope.JAVA_FILE</code> may make it sound like there should also
   be a <code>Scope.KOTLIN_FILE</code>. However, <code>JAVA_FILE</code> here really refers to
   both Java and Kotlin files since the analysis and APIs are identical
   for both (using “UAST”, a universal abstract syntax tree). However,
   at this point we don't want to rename it since it would break a lot
   of existing checks. We might introduce an alias and deprecate this
   one in the future.</div>

<p></p><p>

When detectors implement various callbacks, they can analyze the
code, and if they find a problematic pattern, they can “report”
the incident. This means computing an error message, as well as
a “location”. A “location” for an incident is really an error
range — a file, and a starting offset and an ending offset. Locations
can also be linked together, so for example for a “duplicate
declaration” error, you can and should include both locations.

</p><p>

Many detector methods will pass in a <code>Context</code>, or a more specific
subclass of <code>Context</code> such as <code>JavaContext</code> or <code>XmlContext</code>. This
allows lint to provide access to the detectors information they may
need, without passing in a lot of parameters (and allowing lint to add
additional data over time without breaking signatures).

</p><p>

The <code>Context</code> classes also provide many convenience APIs. For example,
for <code>XmlContext</code> there are methods for creating locations for XML tags,
XML attributes, just the name part of an XML attribute and just the
value part of an XML attribute. For a <code>JavaContext</code> there are also
methods for creating locations, such as for a method call, including
whether to include the receiver and/or the argument list.

</p><p>

When you report an <code>Incident</code> you can also provide a <code>LintFix</code>; this is
a quickfix which the IDE can use to offer actions to take on the
warning. In some cases, you can offer a complete and correct fix (such
as removing an unused element). In other cases the fix may be less
clear; for example, the <code>AccessibilityDetector</code> asks you to set a
description for images; the quickfix will set the content attribute,
but will leave the text value as TODO and will select the string such
that the user can just type to replace it.

</p><p>

</p><div class="admonition tip">When reporting incidents, make sure that the error messages are not
   generic; try to be explicit and include specifics for the current
   scenario. For example, instead of just “Duplicate declaration”, use
   “<code>$name</code> has already been declared”. This isn't just for cosmetics;
   it also makes lint's <a href="#baselines">baseline
   mechanism</a> work better since it
   currently matches by id + file + message, not by line numbers which
   typically drift over time.</div>

<p></p>
<a class="target" name="clientapiversusdetectorapi">&nbsp;</a><a class="target" name="writingalintcheck:basics/clientapiversusdetectorapi">&nbsp;</a><a class="target" name="toc2.3">&nbsp;</a><h2>Client API versus Detector API</h2>
<p>


Lint's API has two halves:

</p><p>

</p><ul>
<li class="minus">The <strong class="asterisk">Client API</strong>: “Integrate (and run) lint from within a tool”.
  For example, both the IDE and the build system uses this API to embed
  and invoke lint to analyze the code in the project or editor.

<p></p><p>

</p></li>
<li class="minus">The <strong class="asterisk">Detector API</strong>: “Implement a new lint check”. This is the API
  which lets checkers analyze code and report problems that they find.</li></ul>

<p></p><p>

The class in the Client API which represents lint running in a tool is
called <code>LintClient</code>. This class is responsible for, among other things:

</p><p>

</p><ul>
<li class="asterisk">Reporting incidents found by detectors. For example, in the IDE, it
  will place error markers into the source editor, and in a build
  system, it may write warnings to the console or generate a report or
  even fail the build.

<p></p><p>

</p></li>
<li class="asterisk">Handling I/O. Detectors should never read files from disk directly.
  This allows lint checks to work smoothly in for example the IDE. When
  lint runs on the fly, and a lint check asks for the source file
  contents (or other supporting files), the <code>LintClient</code> in the IDE
  will implement the <code>readFile</code> method to first look in the open source
  editors and if the requested file is being edited, it will return the
  current (often unsaved!) contents.

<p></p><p>

</p></li>
<li class="asterisk">Handling network traffic. Lint checks should never open
  URLConnections themselves. By going through the lint API to request
  data for a URL, not only can the LintClient for example use any
  configured IDE proxy settings which is done in the IntelliJ
  integration of lint, but even the lint check's own unit tests can
  easily be tested because the special unit test implementation of a
  <code>LintClient</code> provides a simple way to provide exact responses for
  specific URLs:</li></ul>

<p></p><pre class="listing tilde"><code><span class="line">lint()</span>
<span class="line">  .files(...)</span>
<span class="line">  // Set up exactly the expected maven.google.com network output to</span>
<span class="line">  // ensure stable version suggestions in the tests</span>
<span class="line">  .networkData("https://maven.google.com/master-index.xml", ""</span>
<span class="line">       + "<span class="hljs-comment">&lt;!--?xml version='1.0' encoding='UTF-8'?--&gt;</span>\n"</span>
<span class="line">       + "<span class="hljs-tag">&lt;<span class="hljs-name">metadata</span>&gt;</span>\n"</span>
<span class="line">       + "  <span class="hljs-tag">&lt;<span class="hljs-name">com.android.tools.build</span>&gt;</span>"</span>
<span class="line">       + "<span class="hljs-tag">&lt;/<span class="hljs-name">com.android.tools.build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">metadata</span>&gt;</span>")</span>
<span class="line">  .networkData("https://maven.google.com/com/android/tools/build/group-index.xml", ""</span>
<span class="line">       + "<span class="hljs-comment">&lt;!--?xml version='1.0' encoding='UTF-8'?--&gt;</span>\n"</span>
<span class="line">       + "<span class="hljs-tag">&lt;<span class="hljs-name">com.android.tools.build</span>&gt;</span>\n"</span>
<span class="line">       + "  <span class="hljs-tag">&lt;<span class="hljs-name">gradle</span> <span class="hljs-attr">versions</span>=<span class="hljs-string">"\"</span><span class="hljs-attr">2.3.3</span>,<span class="hljs-attr">3.0.0-alpha1</span>\"/"&gt;</span>\n"</span>
<span class="line">       + "<span class="hljs-tag">&lt;/<span class="hljs-name">gradle</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.android.tools.build</span>&gt;</span>")</span>
<span class="line">.run()</span>
<span class="line">.expect(...)</span></code></pre><p>

And much, much, more. <strong class="asterisk">However, most of the implementation of
<code>LintClient</code> is intended for integration of lint itself, and as a check
author you don't need to worry about it.</strong> It's the detector API that
matters, and is also less likely to change than the client API.

</p><p>

</p><div class="admonition tip">The division between the two halves is not perfect; some classes
   do not fit neatly in between the two or historically were put in
   the wrong place, so this is a high level design to be aware of but
   which is not absolute.</div>

<p></p><p>

Also,

</p><p>

</p><div class="admonition warning">Because of the division between two separate packages, which in
   retrospect was a mistake, a number of APIs that are only intended
   for internal lint usage have been made <code>public</code> such that lint's
   code in one package can access it from the other. There's normally a
   comment explaining that this is for internal use only, but be aware
   that just because something is <code>public</code> or not <code>final</code> it's a good
   idea to call or override it.</div>

<p></p>
<a class="target" name="creatinganissue">&nbsp;</a><a class="target" name="writingalintcheck:basics/creatinganissue">&nbsp;</a><a class="target" name="toc2.4">&nbsp;</a><h2>Creating an Issue</h2>
<p>


For information on how to set up the project and to actually publish
your lint checks, see the <a href="#example:samplelintcheckgithubproject">sample</a> and
<a href="#publishingalintcheck">publishing</a> chapters.

</p><p>

<code>Issue</code> is a final class, so unlike <code>Detector</code>, you don't subclass
it, you instantiate it via <code>Issue.create</code>.

</p><p>

By convention, issues are registered inside the companion object of the
corresponding detector, but that is not required.

</p><p>

Here's an example:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SdCardDetector</span> : <span class="hljs-type">Detector</span></span>(), SourceCodeScanner {</span>
<span class="line">    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Issues {</span>
<span class="line">        <span class="hljs-meta">@JvmField</span></span>
<span class="line">        <span class="hljs-keyword">val</span> ISSUE = Issue.create(</span>
<span class="line">            id = <span class="hljs-string">"SdCardPath"</span>,</span>
<span class="line">            briefDescription = <span class="hljs-string">"Hardcoded reference to `/sdcard`"</span>,</span>
<span class="line">            explanation = <span class="hljs-string">"""</span>
<span class="line">                Your code should not reference the `/sdcard` path directly; \</span>
<span class="line">                instead use `Environment.getExternalStorageDirectory().getPath()`.</span>
<span class="line"></span>
<span class="line">                Similarly, do not reference the `/data/data/` path directly; it \</span>
<span class="line">                can vary in multi-user scenarios. Instead, use \</span>
<span class="line">                `Context.getFilesDir().getPath()`.</span>
<span class="line">                """</span>,</span>
<span class="line">            moreInfo = <span class="hljs-string">"https://developer.android.com/training/data-storage#filesExternal"</span>,</span>
<span class="line">            category = Category.CORRECTNESS,</span>
<span class="line">            severity = Severity.WARNING,</span>
<span class="line">            androidSpecific = <span class="hljs-literal">true</span>,</span>
<span class="line">            implementation = Implementation(</span>
<span class="line">                SdCardDetector::<span class="hljs-keyword">class</span>.java,</span>
<span class="line">                Scope.JAVA_FILE_SCOPE</span>
<span class="line">            )</span>
<span class="line">        )</span>
<span class="line">    }</span>
<span class="line">    ...</span></div></code></pre><p>

There are a number of things to note here.

</p><p>

On line 4, we have the <code>Issue.create()</code> call. We store the issue into a
property such that we can reference this issue both from the
<code>IssueRegistry</code>, where we provide the <code>Issue</code> to lint, and also in the
<code>Detector</code> code where we report incidents of the issue.

</p><p>

Note that <code>Issue.create</code> is a method with a lot of parameters (and we
will probably add more parameters in the future). Therefore, it's a
good practice to explicitly include the argument names (and therefore
to implement your code in Kotlin).

</p><p>

The <code>Issue</code> provides metadata about a type of problem.

</p><p>

The <strong class="asterisk"><code>id</code></strong> is a short, unique identifier for this issue. By
convention it is a combination of words, capitalized camel case (though
you can also add your own package prefix as in Java packages). Note
that the id is “user visible”; it is included in text output when lint
runs in the build system, such as this:

</p><pre class="listing backtick"><code><span class="line">src/main/kotlin/test/pkg/MyTest.kt:4: Warning: Do not hardcode "/sdcard/";</span>
<span class="line">      use Environment.getExternalStorageDirectory().getPath() instead [SdCardPath]</span>
<span class="line">    val s: String = "/sdcard/mydir"</span>
<span class="line">                     ~~~~~~~~~~~~~</span>
<span class="line">0 errors, 1 warnings</span></code></pre><p>

(Notice the <code>[SdCardPath]</code> suffix at the end of the error message.)

</p><p>

The reason the id is made known to the user is that the ID is how
they'll configure and/or suppress issues. For example, to suppress the
warning in the current method, use

</p><pre class="listing backtick"><code><span class="line"><span class="hljs-meta">@Suppress(<span class="hljs-params"><span class="hljs-string">"SdCardPath"</span></span>)</span></span></code></pre><p>

(or in Java, @SuppressWarnings). Note that there is an IDE quickfix to
suppress an incident which will automatically add these annotations, so
you don't need to know the ID in order to be able to suppress an
incident, but the ID will be visible in the annotation that it
generates, so it should be reasonably specific.

</p><p>

Also, since the namespace is global, try to avoid picking generic names
that could clash with others, or seem to cover a larger set of issues
than intended. For example, “InvalidDeclaration” would be a poor id
since that can cover a lot of potential problems with declarations
across a number of languages and technologies.

</p><p>

Next, we have the <strong class="asterisk"><code>briefDescription</code></strong>. You can think of this as a
“category report header“; this is a static description for all
incidents of this type, so it cannot include any specifics. This string
is used for example as a header in HTML reports for all incidents of
this type, and in the IDE, if you open the Inspections UI, the various
issues are listed there using the brief descriptions.

</p><p>

The <strong class="asterisk"><code>explanation</code></strong> is a multi line, ideally multi-paragraph
explanation of what the problem is. In some cases, the problem is self
evident, as in the case of ”Unused declaration“, but in many cases, the
issue is more subtle and might require additional explanation,
particularly for what the developer should <strong class="asterisk">do</strong> to address the
problem. The explanation is included both in HTML reports and in the
IDE inspection results window.

</p><p>

Note that even though we're using a raw string, and even though the
string is indented to be flush with the rest of the issue registration
for better readability, we don't need to call <code>trimIndent()</code> on
the raw string. Lint does that automatically.

</p><p>

However, we do need to add line continuations — those are the trailing
\'s at the end of the lines.

</p><p>

Note also that we have a Markdown-like simple syntax, described in the
“TextFormat” section below. You can use asterisks for italics or double
asterisks for bold, you can use apostrophes for code font, and so on.
In terminal output this doesn't make a difference, but the IDE,
explanations, incident error messages, etc, are all formatted using
these styles.

</p><p>

The <strong class="asterisk"><code>category</code></strong> isn't super important; the main use is that category
names can be treated as id's when it comes to issue configuration; for
example, a user can turn off all internationalization issues, or run
lint against only the security related issues. The category is also
used for locating related issues in HTML reports. If none of the
built-in categories are appropriate you can also create your own.

</p><p>

The <strong class="asterisk"><code>severity</code></strong> property is very important. An issue can be either a
warning or an error. These are treated differently in the IDE (where
errors are red underlines and warnings are yellow highlights), and in
the build system (where errors can optionally break the build and
warnings do not). There are some other severities too; ”fatal“ is like
error except these checks are designated important enough (and have
very few false positives) such that we run them during release builds,
even if the user hasn't explicitly run a lint target. There's also
“informational” severity, which is only used in one or two places, and
finally the “ignore” severity. This is never the severity you register
for an issue, but it's part of the severities a developer can configure
for a particular issue, thereby turning off that particular check.

</p><p>

You can also specify a <strong class="asterisk"><code>moreInfo</code></strong> URL which will be included in the
issue explanation as a “More Info” link to open to read more details
about this issue or underlying problem.

</p>
<a class="target" name="textformat">&nbsp;</a><a class="target" name="writingalintcheck:basics/textformat">&nbsp;</a><a class="target" name="toc2.5">&nbsp;</a><h2>TextFormat</h2>
<p>


All error messages and issue metadata strings in lint are interpreted
using simple Markdown-like syntax:
</p><div class="table">
<table class="table"><tbody><tr><th style="text-align:left"> Raw text format </th><th style="text-align:left"> Renders To </th></tr>
<tr><td style="text-align:left"> This is a `code symbol` </td><td style="text-align:left"> This is a <code>code symbol</code> </td></tr>
<tr><td style="text-align:left"> This is <code>*italics*</code> </td><td style="text-align:left"> This is <em class="asterisk">italics</em> </td></tr>
<tr><td style="text-align:left"> This is <code>**bold**</code> </td><td style="text-align:left"> This is <strong class="asterisk">bold</strong> </td></tr>
<tr><td style="text-align:left"> <a href="http://," class="url">http://,</a> <a href="https:// " class="url">https:// </a></td><td style="text-align:left"> <a href="http://"></a><a href="http://</a" class="url">http://, </a><a href="https://"></a><a href="https://</a" class="url">https:// </a></td></tr>
<tr><td style="text-align:left"> <code>\*not italics*</code> </td><td style="text-align:left"> <code>\*not italics*</code> </td></tr>
<tr><td style="text-align:left"> ```language\n text\n``` </td><td style="text-align:left"> (preformatted text block) </td></tr>
</tbody></table><center><div class="tablecaption">Supported markup in lint's markdown-like raw text format</div></center></div>

<p></p><p>

This is useful when error messages and issue explanations are shown in
HTML reports generated by Lint, or in the IDE, where for example the
error message tooltips will use formatting.

</p><p>

In the API, there is a <code>TextFormat</code> enum which encapsulates the
different text formats, and the above syntax is referred to as
<code>TextFormat.RAW</code>; it can be converted to <code>.TEXT</code> or <code>.HTML</code> for
example, which lint does when writing text reports to the console or
HTML reports to files respectively. As a lint check author you don't
need to know this (though you can for example with the unit testing
support decide which format you want to compare against in your
expected output), but the main point here is that your issue's brief
description, issue explanation, incident report messages etc, should
use the above “raw” syntax. Especially the first conversion; error
messages often refer to class names and method names, and these should
be surrounded by apostrophes.

</p>
<a class="target" name="issueimplementation">&nbsp;</a><a class="target" name="writingalintcheck:basics/issueimplementation">&nbsp;</a><a class="target" name="toc2.6">&nbsp;</a><h2>Issue Implementation</h2>
<p>


The last issue registration property is the <strong class="asterisk"><code>implementation</code></strong>. This
is where we glue our metadata to our specific implementation of an
analyzer which can find instances of this issue.

</p><p>

Normally, the <code>Implementation</code> provides two things:

</p><p>

</p><ul>
<li class="asterisk">The <code>.class</code> for our <code>Detector</code> which should be instantiated. In the
  code sample above it was <code>SdCardDetector</code>.

<p></p><p>

</p></li>
<li class="asterisk">The <code>Scope</code> that this issue's detector applies to. In the above
  example it was <code>Scope.JAVA_FILE</code>, which means it will apply to Java
  and Kotlin files.</li></ul>

<p></p>
<a class="target" name="scopes">&nbsp;</a><a class="target" name="writingalintcheck:basics/scopes">&nbsp;</a><a class="target" name="toc2.7">&nbsp;</a><h2>Scopes</h2>
<p>


The <code>Implementation</code> actually takes a <strong class="asterisk">set</strong> of scopes; we still refer
to this as a “scope”. Some lint checks want to analyze multiple types
of files. For example, the <code>StringFormatDetector</code> will analyze both the
resource files declaring the formatting strings across various locales,
as well as the Java and Kotlin files containing <code>String.format</code> calls
referencing the formatting strings.

</p><p>

There are a number of pre-defined sets of scopes in the <code>Scope</code>
class. <code>Scope.JAVA_FILE_SCOPE</code> is the most common, which is a
singleton set containing exactly <code>Scope.JAVA_FILE</code>, but you
can always create your own, such as for example
</p><pre class="listing backtick"><code><span class="line">    <span class="hljs-selector-tag">EnumSet</span><span class="hljs-selector-class">.of</span>(Scope.CLASS_FILE, Scope.JAVA_LIBRARIES)</span></code></pre><p>

When a lint issue requires multiple scopes, that means lint will
<strong class="asterisk">only</strong> run this detector if <strong class="asterisk">all</strong> the scopes are available in the
running tool. When lint runs a full batch run (such as a Gradle lint
target or a full “Inspect Code“ in the IDE), all scopes are available.

</p><p>

However, when lint runs on the fly in the editor, it only has access to
the current file; it won't re-analyze <em class="asterisk">all</em> files in the project for
every few keystrokes. So in this case, the scope in the lint driver
only includes the current source file's type, and only lint checks
which specify a scope that is a subset would run.

</p><p>

This is a common mistake for new lint check authors: the lint check
works just fine as a unit test, but they don't see working in the IDE
because the issue implementation requests multiple scopes, and <strong class="asterisk">all</strong>
have to be available.

</p><p>

Often, a lint check looks at multiple source file types to work
correctly in all cases, but it can still identify <em class="asterisk">some</em> problems given
individual source files. In this case, the <code>Implementation</code> constructor
(which takes a vararg of scope sets) can be handed additional sets of
scopes, called ”analysis scopes“. If the current lint client's scope
matches or is a subset of any of the analysis scopes, then the check
will run after all.

</p>
<a class="target" name="registeringtheissue">&nbsp;</a><a class="target" name="writingalintcheck:basics/registeringtheissue">&nbsp;</a><a class="target" name="toc2.8">&nbsp;</a><h2>Registering the Issue</h2>
<p>


Once you've created your issue, you need to provide it from
an <code>IssueRegistry</code>.

</p><p>

Here's an example <code>IssueRegistry</code>:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-keyword">package</span> com.example.lint.checks</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.client.api.IssueRegistry</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.client.api.Vendor</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.CURRENT_API</span>
<span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleIssueRegistry</span> : <span class="hljs-type">IssueRegistry</span></span>() {</span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> issues = listOf(SdCardDetector.ISSUE)</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> api: <span class="hljs-built_in">Int</span></span>
<span class="line">        <span class="hljs-keyword">get</span>() = CURRENT_API</span>
<span class="line"></span>
<span class="line">    <span class="hljs-comment">// works with Studio 4.1 or later; see</span></span>
<span class="line">    <span class="hljs-comment">// com.android.tools.lint.detector.api.Api / ApiKt</span></span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> minApi: <span class="hljs-built_in">Int</span></span>
<span class="line">        <span class="hljs-keyword">get</span>() = <span class="hljs-number">8</span></span>
<span class="line"></span>
<span class="line">    <span class="hljs-comment">// Requires lint API 30.0+; if you're still building for something</span></span>
<span class="line">    <span class="hljs-comment">// older, just remove this property.</span></span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> vendor: Vendor = Vendor(</span>
<span class="line">        vendorName = <span class="hljs-string">"Android Open Source Project"</span>,</span>
<span class="line">        feedbackUrl = <span class="hljs-string">"https://com.example.lint.blah.blah"</span>,</span>
<span class="line">        contact = <span class="hljs-string">"author@com.example.lint"</span></span>
<span class="line">    )</span>
<span class="line">}</span></div></code></pre><p>

On line 8, we're returning our issue. It's a list, so an
<code>IssueRegistry</code> can provide multiple issues.

</p><p>

The <strong class="asterisk"><code>api</code></strong> property should be written exactly like the way it
appears above in your own issue registry as well; this will record
which version of the lint API this issue registry was compiled against
(because this references a static final constant which will be copied
into the jar file instead of looked up dynamically when the jar is
loaded).

</p><p>

The <strong class="asterisk"><code>minApi</code></strong> property records the oldest lint API level this check
has been tested with.

</p><p>

Both of these are used at issue loading time to make sure lint checks
are compatible, but in recent versions of lint (7.0) lint will more
aggressively try to load older detectors even if they have been
compiled against older APIs since there's a high likelihood that they
will work (it checks all the lint APIs in the bytecode and uses
reflection to verify that they're still there).

</p><p>

The <strong class="asterisk"><code>vendor</code></strong> property is new as of 7.0, and gives lint authors a
way to indicate where the lint check came from. When users use lint,
they're running hundreds and hundreds of checks, and sometimes it's not
clear who to contact with requests or bug reports. When a vendor has
been specified, lint will include this information in error output and
reports.

</p><p>

The last step towards making the lint check available is to make
the <code>IssueRegistry</code> known via the service loader mechanism.

</p><p>

Create a file named exactly
</p><pre class="listing backtick"><code><span class="line"><span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">main</span>/<span class="hljs-selector-tag">resources</span>/<span class="hljs-selector-tag">META-INF</span>/<span class="hljs-selector-tag">services</span>/<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.lint</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.IssueRegistry</span></span></code></pre><p>

with the following contents (but where you substitute in your own
fully qualified class name for your issue registry):

</p><pre class="listing backtick"><code><span class="line"><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.lint</span><span class="hljs-selector-class">.checks</span><span class="hljs-selector-class">.SampleIssueRegistry</span></span></code></pre><p>

If you're not building your lint check using Gradle, you may not want
the <code>src/main/resources</code> prefix; the point is that your packaging of
the jar file should contain <code>META-INF/services/</code> at the root of the jar
file.

</p>
<a class="target" name="implementingadetector:scanners">&nbsp;</a><a class="target" name="writingalintcheck:basics/implementingadetector:scanners">&nbsp;</a><a class="target" name="toc2.9">&nbsp;</a><h2>Implementing a Detector: Scanners</h2>
<p>


We've finally come to the main task with writing a lint check:
implementing the <strong class="asterisk"><code>Detector</code></strong>.

</p><p>

Here's a trivial one:
</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDetector</span> : <span class="hljs-type">Detector</span></span>() {</span>
<span class="line">   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> {</span>
<span class="line">       context.report(ISSUE, Location.create(context.file),</span>
<span class="line">           <span class="hljs-string">"I complain a lot"</span>)</span>
<span class="line">   }</span>
<span class="line">}</span></div></code></pre><p>

This will just complain in every single file. Obviously, no real lint
detector does this; we want to do some analysis and <strong class="asterisk">conditionally</strong>
report incidents.

</p><p>

In order to make it simpler to perform analysis, Lint has dedicated
support for analyzing various file types. The way this works is that
you register interest, and then various callbacks will be invoked.

</p><p>

For example:

</p><p>

</p><ul>
<li class="asterisk">When implementing <strong class="asterisk"><code>XmlScanner</code></strong>, in an XML element you can be
  called back
<ul>
  <li class="minus">when any of a set of given tags are declared  (<code>visitElement</code>)
</li>
  <li class="minus">when any of a set of named attributes are declared
      (<code>visitAttribute</code>)
</li>
  <li class="minus">and you can perform your own document traversal via <code>visitDocument</code>

<p></p><p>

</p></li></ul>
</li><li class="asterisk">When implementing <strong class="asterisk"><code>SourceCodeScanner</code></strong>, in Kotlin and Java files
  you can be called back
<ul>
  <li class="minus">When a method of a given name is invoked (<code>getApplicableMethodNames</code>
      and <code>visitMethodCall</code>)
</li>
  <li class="minus">When a class of the given type is instantiated
      (<code>getApplicableConstructorTypes</code> and <code>visitConstructor</code>)
</li>
  <li class="minus">When a new class is declared which extends (possibly indirectly)
      a given class or interface (<code>applicableSuperClasses</code> and
      <code>visitClass</code>)
</li>
  <li class="minus">When annotated elements are referenced or combined
      (<code>applicableAnnotations</code> and <code>visitAnnotationUsage</code>)
</li>
  <li class="minus">When any AST nodes of given types appear (<code>getApplicableUastTypes</code>
      and <code>createUastHandler</code>)

<p></p><p>

</p></li></ul>
</li><li class="asterisk">When implementing a <strong class="asterisk"><code>ClassScanner</code></strong>, in <code>.class</code> and <code>.jar</code> files
  you can be called back
<ul>
  <li class="minus">when a method is invoked for a particular owner
      (<code>getApplicableCallOwners</code> and <code>checkCall</code>
</li>
  <li class="minus">when a given bytecode instruction occurs
      (<code>getApplicableAsmNodeTypes</code> and <code>checkInstruction</code>)
</li>
  <li class="minus">like with XmlScanner's <code>visitDocument</code>, you can perform your own
      ASM bytecode iteration via <code>checkClass</code>.

<p></p><p>

</p></li></ul>
</li><li class="asterisk">There are various other scanners too, for example <code>GradleScanner</code>
  which lets you visit <code>build.gradle</code> and <code>build.gradle.kts</code> DSL
  closures, <code>BinaryFileScanner</code> which visits resource files such as
  webp and png files, and <code>OtherFileScanner</code> which lets you visit
  unknown files.</li></ul>

<p></p><p>

</p><div class="admonition note">Note that <code>Detector</code> already implements empty stub methods for all
   of these interfaces, so if you for example implement
   <code>SourceFileScanner</code> in your detector, you don't need to go and add
   empty implementations for all the methods you aren't using.</div>

<p></p><p>

</p><div class="admonition tip">None of Lint's APIs require you to call <code>super</code> when you override
   methods; methods meant to be overridden are always empty so the
   super-call is superfluous.</div>

<p></p>
<a class="target" name="detectorlifecycle">&nbsp;</a><a class="target" name="writingalintcheck:basics/detectorlifecycle">&nbsp;</a><a class="target" name="toc2.10">&nbsp;</a><h2>Detector Lifecycle</h2>
<p>


Detector registration is done by detector class, not by detector
instance. Lint will instantiate detectors on your behalf. It will
instantiate the detector once per analysis, so you can stash state on
the detector in fields and accumulate information for analysis at the
end.

</p><p>

There are some callbacks both before each individual file is analyzed
(<code>beforeCheckFile</code> and <code>afterCheckFile</code>), as well as before and after
analysis of all the modules (<code>beforeCheckRootProject</code> and
<code>afterCheckRootProject</code>).

</p><p>

This is for example how the ”unused resources“ check works: we store
all the resource declarations and resource references we find in the
project as we process each file, and then in the
<code>afterCheckRootProject</code> method we analyze the resource graph and
compute any resource declarations that are not reachable in the
reference graph, and then we report each of these as unused.

</p>
<a class="target" name="scannerorder">&nbsp;</a><a class="target" name="writingalintcheck:basics/scannerorder">&nbsp;</a><a class="target" name="toc2.11">&nbsp;</a><h2>Scanner Order</h2>
<p>


Some lint checks involve multiple scanners. This is pretty common in
Android, where we want to cross check consistency between data in
resource files with the code usages. For example, the <code>String.format</code>
check makes sure that the arguments passed to <code>String.format</code> match the
formatting strings specified in all the translation XML files.

</p><p>

Lint defines an exact order in which it processes scanners, and within
scanners, data. This makes it possible to write some detectors more
easily because you know that you'll encounter one type of data before
the other; you don't have to handle the opposite order. For example, in
our <code>String.format</code> example, we know that we'll always see the
formatting strings before we see the code with <code>String.format</code> calls,
so we can stash the formatting strings in a map, and when we process
the formatting calls in code, we can immediately issue reports; we
don't have to worry about encountering a formatting call for a
formatting string we haven't processed yet.

</p><p>

Here's lint's defined order:

</p><p>

</p><ol start="1">
<li class="number">Android Manifest
</li>
<li class="number">Android resources XML files (alphabetical by folder type, so for
   example layouts are processed before value files like translations)
</li>
<li class="number">Kotlin and Java files
</li>
<li class="number">Bytecode (local <code>.class</code> files and library <code>.jar</code> files)
</li>
<li class="number">Gradle files
</li>
<li class="number">Other files
</li>
<li class="number">ProGuard files
</li>
<li class="number">Property Files</li></ol>

<p></p><p>

Similarly, lint will always process libraries before the modules
that depend on them.

</p><p>

</p><div class="admonition tip">If you need to access something from later in the iteration order,
   and it's not practical to store all the current data and instead
   handle it when the later data is encountered, note that lint has
   support for ”multi-pass analysis“: it can run multiple times over
   the data. The way you invoke this is via
   <code>context.driver.requestRepeat(this, …)</code>. This is actually how the
   unused resource analysis works. Note however that this repeat is
   only valid within the current module; you can't re-run the analysis
   through the whole dependency graph.</div>

<p></p>
<a class="target" name="implementingadetector:services">&nbsp;</a><a class="target" name="writingalintcheck:basics/implementingadetector:services">&nbsp;</a><a class="target" name="toc2.12">&nbsp;</a><h2>Implementing a Detector: Services</h2>
<p>


In addition to the scanners, lint provides a number of services
to make implementation simpler. These include

</p><p>

</p><ul>
<li class="asterisk"><strong class="asterisk"><code>ConstantEvaluator</code></strong>: Performs evaluation of AST expressions, so
  for example if we have the statements <code>x = 5; y = 2 * x</code>, the
  constant evaluator can tell you that y is 10. This constant evaluator
  can also be more permissive than a compiler's strict constant
  evaluator; e.g. it can return concatenated strings where not all
  parts are known, or it can use non-final initial values of fields.
  This can help you find <em class="asterisk">possible</em> bugs instead of <em class="asterisk">certain</em> bugs.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk"><code>TypeEvaluator</code></strong>: Attempts to provide the concrete type of an
  expression. For example, for the Java statements <code>Object s = new
  StringBuilder(); Object o = s</code>, the type evaluator can tell you that
  the type of <code>o</code> at this point is really <code>StringBuilder</code>.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk"><code>JavaEvaluator</code></strong>: Despite the unfortunate older name, this service
  applies to both Kotlin and Java, and can for example provide
  information about inheritance hierarchies, class lookup from fully
  qualified names, etc.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk"><code>DataFlowAnalyzer</code></strong>: Data flow analysis within a method.

<p></p><p>

</p></li>
<li class="asterisk">For Android analysis, there are several other important services,
  like the <code>ResourceRepository</code> and the <code>ResourceEvaluator</code>.

<p></p><p>

</p></li>
<li class="asterisk">Finally, there are a number of utility methods; for example there is
  an <code>editDistance</code> method used to find likely typos used by a number
  of checks.</li></ul>

<p></p>
<a class="target" name="scannerexample">&nbsp;</a><a class="target" name="writingalintcheck:basics/scannerexample">&nbsp;</a><a class="target" name="toc2.13">&nbsp;</a><h2>Scanner Example</h2>
<p>


Let's create a <code>Detector</code> using one of the above scanners,
<code>XmlScanner</code>, which will look at all the XML files in the project and
if it encounters a <code>&lt;bitmap&gt;</code> tag it will report that <code>&lt;vector&gt;</code> should
be used instead:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Detector</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Detector.XmlScanner</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Location</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.XmlContext</span>
<span class="line"><span class="hljs-keyword">import</span> org.w3c.dom.Element</span>
<span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDetector</span> : <span class="hljs-type">Detector</span></span>(), XmlScanner {</span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableElements</span><span class="hljs-params">()</span></span> = listOf(<span class="hljs-string">"bitmap"</span>)</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitElement</span><span class="hljs-params">(context: <span class="hljs-type">XmlContext</span>, element: <span class="hljs-type">Element</span>)</span></span> {</span>
<span class="line">        <span class="hljs-keyword">val</span> incident = Incident(context, ISSUE)</span>
<span class="line">            .message( <span class="hljs-string">"Use `&lt;vector&gt;` instead of `&lt;bitmap&gt;`"</span>)</span>
<span class="line">            .at(element)</span>
<span class="line">        context.report(incident))</span>
<span class="line">    }</span>
<span class="line">}</span></div></code></pre><p>

The above is using the new <code>Incident</code> API from Lint 7.0 and on; in
older versions you can use the following API, which still works in 7.0:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDetector</span> : <span class="hljs-type">Detector</span></span>(), XmlScanner {</span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableElements</span><span class="hljs-params">()</span></span> = listOf(<span class="hljs-string">"bitmap"</span>)</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitElement</span><span class="hljs-params">(context: <span class="hljs-type">XmlContext</span>, element: <span class="hljs-type">Element</span>)</span></span> {</span>
<span class="line">        context.report(ISSUE, context.getLocation(element),</span>
<span class="line">            <span class="hljs-string">"Use `&lt;vector&gt;` instead of `&lt;bitmap&gt;`"</span>)</span>
<span class="line">    }</span>
<span class="line">}</span></div></code></pre><p>

The second, older form, may seem simpler, but the new API allows a lot
more metadata to be attached to the report, such as an override
severity. You don't have to convert to the builder syntax to do this;
you could also have written the second form as

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line">context.report(Incident(ISSUE, context.getLocation(element),</span>
<span class="line">    <span class="hljs-string">"Use `&lt;vector&gt;` instead of `&lt;bitmap&gt;`"</span>))</span></div></code></pre>
<a class="target" name="analyzingkotlinandjavacode">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode">&nbsp;</a><a class="target" name="toc2.14">&nbsp;</a><h2>Analyzing Kotlin and Java Code</h2>

<a class="target" name="uast">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/uast">&nbsp;</a><a class="target" name="toc2.14.1">&nbsp;</a><h3>UAST</h3>
<p>


To analyze Kotlin and Java code, lint offers an abstract syntax tree,
or ”AST“, for the code.

</p><p>

This AST is called ”UAST“, for ”Universal Abstract Syntax Tree“, which
represents multiple languages in the same way, hiding the language
specific details like whether there is a semicolon at the end of the
statements or whether the way an annotation class is declared is as
<code>@interface</code> or <code>annotation class</code>, and so on.

</p><p>

This makes it possible to write a single analyzer which works
(”universally“) across all languages supported by UAST. And this is
very useful; most lint checks are doing something API or data-flow
specific, not something language specific. If however you do need to
implement something very language specific, see the next section,
“PSI”.

</p><p>

In UAST, each element is called a <strong class="asterisk"><code>UElement</code></strong>, and there are a
number of subclasses — <code>UFile</code> for the compilation unit, <code>UClass</code> for
a class, <code>UMethod</code> for a method, <code>UExpression</code> for an expression,
<code>UIfExpression</code> for an <code>if</code>-expression, and so on.

</p><p>

Here's a visualization of an AST in UAST for two equivalent programs
written in Kotlin and Java. These programs both result in the same
AST, shown on the right: a <code>UFile</code> compilation unit, containing
a <code>UClass</code> named <code>MyTest</code>, containing <code>UField</code> named s which has
an initializer setting the initial value to <code>hello</code>.

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="352" width="568" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 8,32 L 8,112 " style="fill:none;"></path>
<path d="M 8,160 L 8,256 " style="fill:none;"></path>
<path d="M 208,160 L 208,256 " style="fill:none;"></path>
<path d="M 232,32 L 232,112 " style="fill:none;"></path>
<path d="M 344,64 L 344,96 " style="fill:none;"></path>
<path d="M 344,128 L 344,160 " style="fill:none;"></path>
<path d="M 8,32 L 232,32 " style="fill:none;"></path>
<path d="M 320,32 L 368,32 " style="fill:none;"></path>
<path d="M 320,64 L 368,64 " style="fill:none;"></path>
<path d="M 296,96 L 392,96 " style="fill:none;"></path>
<path d="M 8,112 L 232,112 " style="fill:none;"></path>
<path d="M 296,128 L 392,128 " style="fill:none;"></path>
<path d="M 8,160 L 208,160 " style="fill:none;"></path>
<path d="M 320,160 L 376,160 " style="fill:none;"></path>
<path d="M 320,192 L 376,192 " style="fill:none;"></path>
<path d="M 8,256 L 208,256 " style="fill:none;"></path>
<path d="M 192,272 L 280,272 " style="fill:none;"></path>
<path d="M 352,272 L 536,272 " style="fill:none;"></path>
<path d="M 192,304 L 280,304 " style="fill:none;"></path>
<path d="M 352,304 L 536,304 " style="fill:none;"></path>
<path d="M 376,192 L 416,272 " style="fill:none;"></path>
<path d="M 280,272 L 320,192 " style="fill:none;"></path>
<path d="M 320,32 C 303.2,32 304,48 304,48 " style="fill:none;"></path>
<path d="M 368,32 C 384.8,32 384,48 384,48 " style="fill:none;"></path>
<path d="M 320,64 C 303.2,64 304,48 304,48 " style="fill:none;"></path>
<path d="M 368,64 C 384.8,64 384,48 384,48 " style="fill:none;"></path>
<path d="M 296,96 C 279.2,96 280,112 280,112 " style="fill:none;"></path>
<path d="M 392,96 C 408.8,96 408,112 408,112 " style="fill:none;"></path>
<path d="M 296,128 C 279.2,128 280,112 280,112 " style="fill:none;"></path>
<path d="M 392,128 C 408.8,128 408,112 408,112 " style="fill:none;"></path>
<path d="M 320,160 C 303.2,160 304,176 304,176 " style="fill:none;"></path>
<path d="M 376,160 C 392.8,160 392,176 392,176 " style="fill:none;"></path>
<path d="M 320,192 C 303.2,192 304,176 304,176 " style="fill:none;"></path>
<path d="M 376,192 C 392.8,192 392,176 392,176 " style="fill:none;"></path>
<path d="M 192,272 C 175.2,272 176,288 176,288 " style="fill:none;"></path>
<path d="M 280,272 C 296.8,272 296,288 296,288 " style="fill:none;"></path>
<path d="M 352,272 C 335.2,272 336,288 336,288 " style="fill:none;"></path>
<path d="M 536,272 C 552.8,272 552,288 552,288 " style="fill:none;"></path>
<path d="M 192,304 C 175.2,304 176,288 176,288 " style="fill:none;"></path>
<path d="M 280,304 C 296.8,304 296,288 296,288 " style="fill:none;"></path>
<path d="M 352,304 C 335.2,304 336,288 336,288 " style="fill:none;"></path>
<path d="M 536,304 C 552.8,304 552,288 552,288 " style="fill:none;"></path>
<g transform="translate(0,0)"><text text-anchor="middle" x="8" y="20">M</text><text text-anchor="middle" x="16" y="20">y</text><text text-anchor="middle" x="24" y="20">T</text><text text-anchor="middle" x="32" y="20">e</text><text text-anchor="middle" x="40" y="20">s</text><text text-anchor="middle" x="48" y="20">t</text><text text-anchor="middle" x="56" y="20">.</text><text text-anchor="middle" x="64" y="20">k</text><text text-anchor="middle" x="72" y="20">t</text><text text-anchor="middle" x="80" y="20">:</text><text text-anchor="middle" x="328" y="20">U</text><text text-anchor="middle" x="336" y="20">A</text><text text-anchor="middle" x="344" y="20">S</text><text text-anchor="middle" x="352" y="20">T</text><text text-anchor="middle" x="360" y="20">:</text><text text-anchor="middle" x="24" y="52">p</text><text text-anchor="middle" x="32" y="52">a</text><text text-anchor="middle" x="40" y="52">c</text><text text-anchor="middle" x="48" y="52">k</text><text text-anchor="middle" x="56" y="52">a</text><text text-anchor="middle" x="64" y="52">g</text><text text-anchor="middle" x="72" y="52">e</text><text text-anchor="middle" x="88" y="52">t</text><text text-anchor="middle" x="96" y="52">e</text><text text-anchor="middle" x="104" y="52">s</text><text text-anchor="middle" x="112" y="52">t</text><text text-anchor="middle" x="120" y="52">.</text><text text-anchor="middle" x="128" y="52">p</text><text text-anchor="middle" x="136" y="52">k</text><text text-anchor="middle" x="144" y="52">g</text><text text-anchor="middle" x="328" y="52">U</text><text text-anchor="middle" x="336" y="52">F</text><text text-anchor="middle" x="344" y="52">i</text><text text-anchor="middle" x="352" y="52">l</text><text text-anchor="middle" x="360" y="52">e</text><text text-anchor="middle" x="24" y="68">c</text><text text-anchor="middle" x="32" y="68">l</text><text text-anchor="middle" x="40" y="68">a</text><text text-anchor="middle" x="48" y="68">s</text><text text-anchor="middle" x="56" y="68">s</text><text text-anchor="middle" x="72" y="68">M</text><text text-anchor="middle" x="80" y="68">y</text><text text-anchor="middle" x="88" y="68">T</text><text text-anchor="middle" x="96" y="68">e</text><text text-anchor="middle" x="104" y="68">s</text><text text-anchor="middle" x="112" y="68">t</text><text text-anchor="middle" x="128" y="68">{</text><text text-anchor="middle" x="40" y="84">p</text><text text-anchor="middle" x="48" y="84">r</text><text text-anchor="middle" x="56" y="84">i</text><text text-anchor="middle" x="64" y="84">v</text><text text-anchor="middle" x="72" y="84">a</text><text text-anchor="middle" x="80" y="84">t</text><text text-anchor="middle" x="88" y="84">e</text><text text-anchor="middle" x="104" y="84">v</text><text text-anchor="middle" x="112" y="84">a</text><text text-anchor="middle" x="120" y="84">l</text><text text-anchor="middle" x="136" y="84">s</text><text text-anchor="middle" x="152" y="84">=</text><text text-anchor="middle" x="168" y="84">“</text><text text-anchor="middle" x="176" y="84">h</text><text text-anchor="middle" x="184" y="84">e</text><text text-anchor="middle" x="192" y="84">l</text><text text-anchor="middle" x="200" y="84">l</text><text text-anchor="middle" x="208" y="84">o</text><text text-anchor="middle" x="216" y="84">”</text><text text-anchor="middle" x="24" y="100">}</text><text text-anchor="middle" x="296" y="116">U</text><text text-anchor="middle" x="304" y="116">C</text><text text-anchor="middle" x="312" y="116">l</text><text text-anchor="middle" x="320" y="116">a</text><text text-anchor="middle" x="328" y="116">s</text><text text-anchor="middle" x="336" y="116">s</text><text text-anchor="middle" x="352" y="116">M</text><text text-anchor="middle" x="360" y="116">y</text><text text-anchor="middle" x="368" y="116">T</text><text text-anchor="middle" x="376" y="116">e</text><text text-anchor="middle" x="384" y="116">s</text><text text-anchor="middle" x="392" y="116">t</text><text text-anchor="middle" x="8" y="148">M</text><text text-anchor="middle" x="16" y="148">y</text><text text-anchor="middle" x="24" y="148">T</text><text text-anchor="middle" x="32" y="148">e</text><text text-anchor="middle" x="40" y="148">s</text><text text-anchor="middle" x="48" y="148">t</text><text text-anchor="middle" x="56" y="148">.</text><text text-anchor="middle" x="64" y="148">j</text><text text-anchor="middle" x="72" y="148">a</text><text text-anchor="middle" x="80" y="148">v</text><text text-anchor="middle" x="88" y="148">a</text><text text-anchor="middle" x="96" y="148">:</text><text text-anchor="middle" x="24" y="180">p</text><text text-anchor="middle" x="32" y="180">a</text><text text-anchor="middle" x="40" y="180">c</text><text text-anchor="middle" x="48" y="180">k</text><text text-anchor="middle" x="56" y="180">a</text><text text-anchor="middle" x="64" y="180">g</text><text text-anchor="middle" x="72" y="180">e</text><text text-anchor="middle" x="88" y="180">t</text><text text-anchor="middle" x="96" y="180">e</text><text text-anchor="middle" x="104" y="180">s</text><text text-anchor="middle" x="112" y="180">t</text><text text-anchor="middle" x="120" y="180">.</text><text text-anchor="middle" x="128" y="180">p</text><text text-anchor="middle" x="136" y="180">k</text><text text-anchor="middle" x="144" y="180">g</text><text text-anchor="middle" x="152" y="180">;</text><text text-anchor="middle" x="320" y="180">U</text><text text-anchor="middle" x="328" y="180">F</text><text text-anchor="middle" x="336" y="180">i</text><text text-anchor="middle" x="344" y="180">e</text><text text-anchor="middle" x="352" y="180">l</text><text text-anchor="middle" x="360" y="180">d</text><text text-anchor="middle" x="376" y="180">s</text><text text-anchor="middle" x="24" y="196">p</text><text text-anchor="middle" x="32" y="196">u</text><text text-anchor="middle" x="40" y="196">b</text><text text-anchor="middle" x="48" y="196">l</text><text text-anchor="middle" x="56" y="196">i</text><text text-anchor="middle" x="64" y="196">c</text><text text-anchor="middle" x="80" y="196">c</text><text text-anchor="middle" x="88" y="196">l</text><text text-anchor="middle" x="96" y="196">a</text><text text-anchor="middle" x="104" y="196">s</text><text text-anchor="middle" x="112" y="196">s</text><text text-anchor="middle" x="128" y="196">M</text><text text-anchor="middle" x="136" y="196">y</text><text text-anchor="middle" x="144" y="196">T</text><text text-anchor="middle" x="152" y="196">e</text><text text-anchor="middle" x="160" y="196">s</text><text text-anchor="middle" x="168" y="196">t</text><text text-anchor="middle" x="184" y="196">{</text><text text-anchor="middle" x="48" y="212">p</text><text text-anchor="middle" x="56" y="212">r</text><text text-anchor="middle" x="64" y="212">i</text><text text-anchor="middle" x="72" y="212">v</text><text text-anchor="middle" x="80" y="212">a</text><text text-anchor="middle" x="88" y="212">t</text><text text-anchor="middle" x="96" y="212">e</text><text text-anchor="middle" x="112" y="212">S</text><text text-anchor="middle" x="120" y="212">t</text><text text-anchor="middle" x="128" y="212">r</text><text text-anchor="middle" x="136" y="212">i</text><text text-anchor="middle" x="144" y="212">n</text><text text-anchor="middle" x="152" y="212">g</text><text text-anchor="middle" x="168" y="212">s</text><text text-anchor="middle" x="184" y="212">=</text><text text-anchor="middle" x="80" y="228">“</text><text text-anchor="middle" x="88" y="228">h</text><text text-anchor="middle" x="96" y="228">e</text><text text-anchor="middle" x="104" y="228">l</text><text text-anchor="middle" x="112" y="228">l</text><text text-anchor="middle" x="120" y="228">o</text><text text-anchor="middle" x="128" y="228">”</text><text text-anchor="middle" x="136" y="228">;</text><text text-anchor="middle" x="24" y="244">}</text><text text-anchor="middle" x="184" y="292">U</text><text text-anchor="middle" x="192" y="292">I</text><text text-anchor="middle" x="200" y="292">d</text><text text-anchor="middle" x="208" y="292">e</text><text text-anchor="middle" x="216" y="292">n</text><text text-anchor="middle" x="224" y="292">t</text><text text-anchor="middle" x="232" y="292">i</text><text text-anchor="middle" x="240" y="292">f</text><text text-anchor="middle" x="248" y="292">i</text><text text-anchor="middle" x="256" y="292">e</text><text text-anchor="middle" x="264" y="292">r</text><text text-anchor="middle" x="280" y="292">s</text><text text-anchor="middle" x="352" y="292">U</text><text text-anchor="middle" x="360" y="292">L</text><text text-anchor="middle" x="368" y="292">i</text><text text-anchor="middle" x="376" y="292">t</text><text text-anchor="middle" x="384" y="292">e</text><text text-anchor="middle" x="392" y="292">r</text><text text-anchor="middle" x="400" y="292">a</text><text text-anchor="middle" x="408" y="292">l</text><text text-anchor="middle" x="416" y="292">E</text><text text-anchor="middle" x="424" y="292">x</text><text text-anchor="middle" x="432" y="292">p</text><text text-anchor="middle" x="440" y="292">r</text><text text-anchor="middle" x="448" y="292">e</text><text text-anchor="middle" x="456" y="292">s</text><text text-anchor="middle" x="464" y="292">s</text><text text-anchor="middle" x="472" y="292">i</text><text text-anchor="middle" x="480" y="292">o</text><text text-anchor="middle" x="488" y="292">n</text><text text-anchor="middle" x="504" y="292">h</text><text text-anchor="middle" x="512" y="292">e</text><text text-anchor="middle" x="520" y="292">l</text><text text-anchor="middle" x="528" y="292">l</text><text text-anchor="middle" x="536" y="292">o</text></g></g></svg>

</p><p>

</p><div class="admonition tip">The name “UAST” is a bit misleading; it is not some sort of superset
   of all possible syntax trees; instead, think of this as the “Java
   view” of all code. So, for example, there isn’t a <code>UProperty</code> node
   which represents Kotlin properties. Instead, the AST will look the
   same as if the property had been implemented in Java: it will
   contain a private field and a public getter and a public setter
   (unless of course the Kotlin property specifies a private setter).
   If you’ve written code in Kotlin and have tried to access that
   Kotlin code from a Java file you will see the same thing — the
   “Java view” of Kotlin. The next section, “PSI“, will discuss how to
   do more language specific analysis.</div>

<p></p>
<a class="target" name="uastexample">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/uastexample">&nbsp;</a><a class="target" name="toc2.14.2">&nbsp;</a><h3>UAST Example</h3>
<p>


Here's an example (from the built-in <code>AlarmDetector</code> for Android) which
shows all of the above in practice; this is a lint check which makes
sure that if anyone calls <code>AlarmManager.setRepeating</code>, the second
argument is at least 5,000 and the third argument is at least 60,000.

</p><p>

Line 1 says we want to have line 3 called whenever lint comes across a
method to <code>setRepeating</code>.

</p><p>

On lines 8-4 we make sure we're talking about the correct method on the
correct class with the correct signature. This uses the <code>JavaEvaluator</code>
to check that the called method is a member of the named class. This is
necessary because the callback would also be invoked if lint came
across a method call like <code>Unrelated.setRepeating</code>; the
<code>visitMethodCall</code> callback only matches by name, not receiver.

</p><p>

On line 36 we use the <code>ConstantEvaluator</code> to compute the value of each
argument passed in. This will let this lint check not only handle cases
where you're specifying a specific value directly in the argument list,
but also for example referencing a constant from elsewhere.

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableMethodNames</span><span class="hljs-params">()</span></span>: List&lt;string&gt; = listOf(<span class="hljs-string">"setRepeating"</span>)</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitMethodCall</span><span class="hljs-params">(</span>
<span class="line">    context: <span class="hljs-type">JavaContext</span>,</span>
<span class="line">    node: <span class="hljs-type">UCallExpression</span>,</span>
<span class="line">    method: <span class="hljs-type">PsiMethod</span></span>
<span class="line">)</span></span> {</span>
<span class="line">    <span class="hljs-keyword">val</span> evaluator = context.evaluator</span>
<span class="line">    <span class="hljs-keyword">if</span> (evaluator.isMemberInClass(method, <span class="hljs-string">"android.app.AlarmManager"</span>) &amp;&amp;</span>
<span class="line">        evaluator.getParameterCount(method) == <span class="hljs-number">4</span></span>
<span class="line">    ) {</span>
<span class="line">        ensureAtLeast(context, node, <span class="hljs-number">1</span>, <span class="hljs-number">5000L</span>)</span>
<span class="line">        ensureAtLeast(context, node, <span class="hljs-number">2</span>, <span class="hljs-number">60000L</span>)</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ensureAtLeast</span><span class="hljs-params">(</span>
<span class="line">    context: <span class="hljs-type">JavaContext</span>,</span>
<span class="line">    node: <span class="hljs-type">UCallExpression</span>,</span>
<span class="line">    parameter: <span class="hljs-type">Int</span>,</span>
<span class="line">    min: <span class="hljs-type">Long</span></span>
<span class="line">)</span></span> {</span>
<span class="line">    <span class="hljs-keyword">val</span> argument = node.valueArguments[parameter]</span>
<span class="line">    <span class="hljs-keyword">val</span> value = getLongValue(context, argument)</span>
<span class="line">    <span class="hljs-keyword">if</span> (value &lt; min) {</span>
<span class="line">        <span class="hljs-keyword">val</span> message = <span class="hljs-string">"Value will be forced up to <span class="hljs-variable">$min</span> as of Android 5.1; "</span> +</span>
<span class="line">            <span class="hljs-string">"don't rely on this to be exact"</span></span>
<span class="line">        context.report(ISSUE, argument, context.getLocation(argument), message)</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLongValue</span><span class="hljs-params">(</span>
<span class="line">    context: <span class="hljs-type">JavaContext</span>,</span>
<span class="line">    argument: <span class="hljs-type">UExpression</span></span>
<span class="line">)</span></span>: <span class="hljs-built_in">Long</span> {</span>
<span class="line">    <span class="hljs-keyword">val</span> value = ConstantEvaluator.evaluate(context, argument)</span>
<span class="line">    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">is</span> Number) {</span>
<span class="line">        <span class="hljs-keyword">return</span> value.toLong()</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">return</span> java.lang.<span class="hljs-built_in">Long</span>.MAX_VALUE</span>
<span class="line">}</span></div></code></pre>
<a class="target" name="lookingupuast">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/lookingupuast">&nbsp;</a><a class="target" name="toc2.14.3">&nbsp;</a><h3>Looking up UAST</h3>
<p>


To write your detector's analysis, you need to know what the AST for
your code of interest looks like. Instead of trying to figure it out by
examining the elements under a debugger, a simple way to find out is to
”pretty print“ it, using the <code>UElement</code> extension method
<strong class="asterisk"><code>asRecursiveLogString</code></strong>.

</p><p>

For example, given the following unit test:

</p><pre class="listing tilde"><code><span class="line">lint().files(</span>
<span class="line">       kotlin(<span class="hljs-string">""</span></span>
<span class="line">               <span class="hljs-operator">+</span> <span class="hljs-string">"package test.pkg<span class="hljs-subst">\n</span>"</span></span>
<span class="line">               <span class="hljs-operator">+</span> <span class="hljs-string">"<span class="hljs-subst">\n</span>"</span></span>
<span class="line">               <span class="hljs-operator">+</span> <span class="hljs-string">"class MyTest {<span class="hljs-subst">\n</span>"</span></span>
<span class="line">               <span class="hljs-operator">+</span> <span class="hljs-string">"    val s: String = <span class="hljs-subst">\"</span>hello<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span></span>
<span class="line">               <span class="hljs-operator">+</span> <span class="hljs-string">"}<span class="hljs-subst">\n</span>"</span>), <span class="hljs-operator">...</span></span></code></pre><p>

If you evaluate <code>context.uastFile?.asRecursiveLogString()</code> from
one of the callbacks, it will print this:

</p><pre class="listing backtick"><code><span class="line">UFile (package = test.pkg)</span>
<span class="line">    UClass (name = MyTest)</span>
<span class="line">        UField (name = s)</span>
<span class="line">            UAnnotation (fqName = org.jetbrains.annotations.NotNull)</span>
<span class="line">            ULiteralExpression (value = "hello")</span>
<span class="line">        UAnnotationMethod (name = getS)</span>
<span class="line">        UAnnotationMethod (name = MyTest)</span></code></pre><p>

(This also illustrates the earlier point about UAST representing the
Java view of the code; here the read-only public Kotlin property ”s“ is
represented by both a private field <code>s</code> and a public getter method,
<code>getS()</code>.)

</p>
<a class="target" name="resolving">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/resolving">&nbsp;</a><a class="target" name="toc2.14.4">&nbsp;</a><h3>Resolving</h3>
<p>


When you have a method call, or a field reference, you may want to take
a look at the called method or field. This is called ”resolving“, and
UAST supports it directly; on a <code>UCallExpression</code> for example, call
<code>.resolve()</code>, which returns a <code>PsiMethod</code>, which is like a <code>UMethod</code>,
but may not represent a method we have source for (which for example
would be the case if you resolve a reference to the JDK or to a library
we do not have sources for). You can call <code>.toUElement()</code> on the
PSI element to try to convert it to UAST if source is available.

</p><p>

</p><div class="admonition warning">Resolving only works if lint has a correct classpath such that the
   referenced method, field or class are actually present. If it is
   not, resolve will return null, and various lint callbacks will not
   be invoked. This is a common source of questions for lint checks
   ”not working“; it frequently comes up in lint unit tests where a
   test file will reference some API that isn't actually included in
   the class path. The recommended approach for this is to declare
   local stubs. See the <a href="#lintcheckunittesting">unit testing</a> chapter
   for more details about this.</div>

<p></p>
<a class="target" name="psi">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/psi">&nbsp;</a><a class="target" name="toc2.14.5">&nbsp;</a><h3>PSI</h3>
<p>


PSI is short for ”Program Structure Interface“, and is IntelliJ's AST
abstraction used for all language modeling in the IDE.

</p><p>

Note that there is a <strong class="asterisk">different</strong> PSI representation for each
language. Java and Kotlin have completely different PSI classes
involved. This means that writing a lint check using PSI would involve
writing a lot of logic twice; once for Java, and once for Kotlin. (And
the Kotlin PSI is a bit trickier to work with.)

</p><p>

That's what UAST is for: there's a ”bridge“ from the Java PSI to UAST
and there's a bridge from the Kotlin PSI to UAST, and your lint check
just analyzes UAST.

</p><p>

However, there are a few scenarios where we have to use PSI.

</p><p>

The first, and most common one, is listed in the previous section on
resolving. UAST does not completely replace PSI; in fact, PSI leaks
through in part of the UAST API surface. For example,
<code>UMethod.resolve()</code> returns a <code>PsiMethod</code>. And more importantly,
<code>UMethod</code> <strong class="asterisk">extends</strong> <code>PsiMethod</code>.

</p><p>

</p><div class="admonition warning">For historical reasons, <code>PsiMethod</code> and other PSI classes contain
   some unfortunate APIs that only work for Java, such as asking for
   the method body. Because <code>UMethod</code> extends <code>PsiMethod</code>, you might be
   tempted to call <code>getBody()</code> on it, but this will return null from
   Kotlin. If your unit tests for your lint check only have test cases
   written in Java, you may not realize that your check is doing the
   wrong thing and won't work on Kotlin code. It should call <code>uastBody</code>
   on the <code>UMethod</code> instead. Lint's special detector for lint detectors
   looks for this and a few other scenarios (such as calling <code>parent</code>
   instead of <code>uastParent</code>), so be sure to configure it for your
   project.</div>

<p></p><p>

When you are dealing with ”signatures“ — looking at classes and
class inheritance, methods, parameters and so on — using PSI is
fine — and unavoidable since UAST does not represent bytecode
(though in the future it potentially could, via a decompiler)
or any other JVM languages than Kotlin and Java.

</p><p>

However, if you are looking at anything <em class="asterisk">inside</em> a method or class
or field initializer, you <strong class="asterisk">must</strong> use UAST.

</p><p>

The <strong class="asterisk">second</strong> scenario where you may need to use PSI is where you have
to do something language specific which is not represented in UAST. For
example, if you are trying to look up the names or default values of a
parameter, or whether a given class is a companion object, then you'll
need to dip into Kotlin PSI.

</p><p>

There is usually no need to look at Java PSI since UAST fully covers
it, unless you want to look at individual details like specific
whitespace between AST nodes, which is represented in PSI but not UAST.

</p><p>

</p><div class="admonition tip">You can find additional documentation from JetBrains for both
   <a href="https://plugins.jetbrains.com/docs/intellij/psi.html">PSI</a> and
   <a href="https://plugins.jetbrains.com/docs/intellij/uast.html">UAST</a>.
   Just note that their documentation is aimed at IDE plugin developers
   rather than lint developers.</div>

<p></p>
<a class="target" name="testing">&nbsp;</a><a class="target" name="writingalintcheck:basics/testing">&nbsp;</a><a class="target" name="toc2.15">&nbsp;</a><h2>Testing</h2>
<p>


Writing unit tests for the lint check is important, and this is covered
in detail in the dedicated <a href="#lintcheckunittesting">unit testing</a>
chapter.

</p><p>



</p>
<a class="target" name="example:samplelintcheckgithubproject">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject">&nbsp;</a><a class="target" name="toc3">&nbsp;</a><h1>Example: Sample Lint Check GitHub Project</h1>
<p>


The <a href="https://github.com/googlesamples/android-custom-lint-rules"></a><a href="https://github.com/googlesamples/android-custom-lint-rules" class="url">https://github.com/googlesamples/android-custom-lint-rules</a>
GitHub project provides a sample lint check which shows a working
skeleton.

</p><p>

This chapter walks through that sample project and explains
what and why.

</p>
<a class="target" name="projectlayout">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/projectlayout">&nbsp;</a><a class="target" name="toc3.1">&nbsp;</a><h2>Project Layout</h2>
<p>


Here's the project layout of the sample project:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="96" width="528" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 32,16 L 32,48 " style="fill:none;"></path>
<path d="M 72,16 L 72,48 " style="fill:none;"></path>
<path d="M 224,16 L 224,48 " style="fill:none;"></path>
<path d="M 296,16 L 296,48 " style="fill:none;"></path>
<path d="M 424,16 L 424,48 " style="fill:none;"></path>
<path d="M 488,16 L 488,48 " style="fill:none;"></path>
<path d="M 32,16 L 72,16 " style="fill:none;"></path>
<path d="M 224,16 L 296,16 " style="fill:none;"></path>
<path d="M 424,16 L 488,16 " style="fill:none;"></path>
<path d="M 72,32 L 216,32 " style="fill:none;"></path>
<path d="M 296,32 L 416,32 " style="fill:none;"></path>
<path d="M 32,48 L 72,48 " style="fill:none;"></path>
<path d="M 224,48 L 296,48 " style="fill:none;"></path>
<path d="M 424,48 L 488,48 " style="fill:none;"></path>
<polygon points="424,32 412,26.4 412,37.6 " style="stroke:none" transform="rotate(0,416,32 )"></polygon>
<polygon points="224,32 212,26.4 212,37.6 " style="stroke:none" transform="rotate(0,216,32 )"></polygon>
<g transform="translate(0,0)"><text text-anchor="middle" x="96" y="20">i</text><text text-anchor="middle" x="104" y="20">m</text><text text-anchor="middle" x="112" y="20">p</text><text text-anchor="middle" x="120" y="20">l</text><text text-anchor="middle" x="128" y="20">e</text><text text-anchor="middle" x="136" y="20">m</text><text text-anchor="middle" x="144" y="20">e</text><text text-anchor="middle" x="152" y="20">n</text><text text-anchor="middle" x="160" y="20">t</text><text text-anchor="middle" x="168" y="20">a</text><text text-anchor="middle" x="176" y="20">t</text><text text-anchor="middle" x="184" y="20">i</text><text text-anchor="middle" x="192" y="20">o</text><text text-anchor="middle" x="200" y="20">n</text><text text-anchor="middle" x="320" y="20">l</text><text text-anchor="middle" x="328" y="20">i</text><text text-anchor="middle" x="336" y="20">n</text><text text-anchor="middle" x="344" y="20">t</text><text text-anchor="middle" x="352" y="20">P</text><text text-anchor="middle" x="360" y="20">u</text><text text-anchor="middle" x="368" y="20">b</text><text text-anchor="middle" x="376" y="20">l</text><text text-anchor="middle" x="384" y="20">i</text><text text-anchor="middle" x="392" y="20">s</text><text text-anchor="middle" x="400" y="20">h</text><text text-anchor="middle" x="40" y="36">:</text><text text-anchor="middle" x="48" y="36">a</text><text text-anchor="middle" x="56" y="36">p</text><text text-anchor="middle" x="64" y="36">p</text><text text-anchor="middle" x="232" y="36">:</text><text text-anchor="middle" x="240" y="36">l</text><text text-anchor="middle" x="248" y="36">i</text><text text-anchor="middle" x="256" y="36">b</text><text text-anchor="middle" x="264" y="36">r</text><text text-anchor="middle" x="272" y="36">a</text><text text-anchor="middle" x="280" y="36">r</text><text text-anchor="middle" x="288" y="36">y</text><text text-anchor="middle" x="432" y="36">:</text><text text-anchor="middle" x="440" y="36">c</text><text text-anchor="middle" x="448" y="36">h</text><text text-anchor="middle" x="456" y="36">e</text><text text-anchor="middle" x="464" y="36">c</text><text text-anchor="middle" x="472" y="36">k</text><text text-anchor="middle" x="480" y="36">s</text></g></g></svg>

</p><p>

We have an application module, <code>app</code>, which depends (via an
<code>implementation</code> dependency) on a <code>library</code>, and the library itself has
a <code>lintPublish</code> dependency on the <code>checks</code> project.

</p>
<a class="target" name=":checks">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/:checks">&nbsp;</a><a class="target" name="toc3.2">&nbsp;</a><h2>:checks</h2>
<p>


The <code>checks</code> project is where the actual lint checks are implemented.
This project is a plain Kotlin or plain Java Gradle project:

</p><pre class="listing tilde"><code><span class="line">apply plugin: <span class="hljs-string">'java-library'</span></span>
<span class="line">apply plugin: <span class="hljs-string">'kotlin'</span></span></code></pre><p>



</p><div class="admonition tip">If you look at the sample project, you'll see a third plugin
   applied: <code>apply plugin: 'com.android.lint'</code>. This pulls in the
   standalone Lint Gradle plugin, which adds a lint target to this
   Kotlin project. This means that you can run <code>./gradlew lint</code> on the
   <code>:checks</code> project too. This is useful because lint ships with a
   dozen lint checks that look for mistakes in lint detectors! This
   includes warnings about using the wrong UAST methods, invalid id
   formats, words in messages which look like code which should
   probably be surrounded by apostrophes, etc.</div>

<p></p><p>

The Gradle file also declares the dependencies on lint APIs
that our detector needs:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line">dependencies {</span>
<span class="line">    compileOnly <span class="hljs-string">"com.android.tools.lint:lint-api:<span class="hljs-variable">$lintVersion</span>"</span></span>
<span class="line">    compileOnly <span class="hljs-string">"com.android.tools.lint:lint-checks:<span class="hljs-variable">$lintVersion</span>"</span></span>
<span class="line">    testImplementation <span class="hljs-string">"com.android.tools.lint:lint-tests:<span class="hljs-variable">$lintVersion</span>"</span></span>
<span class="line">}</span></div></code></pre><p>

The second dependency is usually not necessary; you just need to depend
on the Lint API. However, the built-in checks define a lot of
additional infrastructure which it's sometimes convenient to depend on,
such as <code>ApiLookup</code> which lets you look up the required API level for a
given method, and so on. Don't add the dependency until you need it.

</p>
<a class="target" name="lintversion?">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/lintversion?">&nbsp;</a><a class="target" name="toc3.3">&nbsp;</a><h2>lintVersion?</h2>
<p>


What is the <code>lintVersion</code> variable defined above?

</p><p>

Here's the top level build.gradle
</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line">buildscript {</span>
<span class="line">    ext {</span>
<span class="line">        kotlinVersion = <span class="hljs-string">'1.4.32'</span></span>
<span class="line"></span>
<span class="line">        <span class="hljs-comment">// Current lint target: Studio 4.2 / AGP 7</span></span>
<span class="line">        <span class="hljs-comment">//gradlePluginVersion = '4.2.0-beta06'</span></span>
<span class="line">        <span class="hljs-comment">//lintVersion = '27.2.0-beta06'</span></span>
<span class="line"></span>
<span class="line">        <span class="hljs-comment">// Upcoming lint target: Arctic Fox / AGP 7</span></span>
<span class="line">        gradlePluginVersion = <span class="hljs-string">'7.0.0-alpha10'</span></span>
<span class="line">        lintVersion = <span class="hljs-string">'30.0.0-alpha10'</span></span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    repositories {</span>
<span class="line">        google()</span>
<span class="line">        mavenCentral()</span>
<span class="line">    }</span>
<span class="line">    dependencies {</span>
<span class="line">        classpath <span class="hljs-string">"com.android.tools.build:gradle:<span class="hljs-variable">$gradlePluginVersion</span>"</span></span>
<span class="line">        classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="hljs-variable">$kotlinVersion</span>"</span></span>
<span class="line">    }</span>
<span class="line">}</span></div></code></pre><p>

The <code>$lintVersion</code> variable is defined on line 11. We don't technically
need to define the <code>$gradlePluginVersion</code> here or add it to the classpath on line 19, but that's done so that we can add the <code>lint</code>
plugin on the checks themselves, as well as for the other modules,
<code>:app</code> and <code>:library</code>, which do need it.

</p><p>

When you build lint checks, you're compiling against the Lint APIs
distributed on maven.google.com (which is referenced via <code>google()</code> in
Gradle files). These follow the Gradle plugin version numbers.

</p><p>

Therefore, you first pick which of lint's API you'd like to compile
against. You should use the latest available if possible.

</p><p>

Once you know the Gradle plugin version number, say 4.2.0-beta06, you
can compute the lint version number by simply adding <strong class="asterisk">23</strong> to the
major version of the gradle plugin, and leave everything the same:

</p><p>

<strong class="asterisk">lintVersion = gradlePluginVersion + 23.0.0</strong>

</p><p>

For example, 7 + 23 = 30, so AGP version <em class="asterisk">7.something</em> corresponds to
Lint version <em class="asterisk">30.something</em>. As another example; as of this writing the
current stable version of AGP is 4.1.2, so the corresponding version of
the Lint API is 27.1.2.

</p><p>

</p><div class="admonition tip">Why this arbitrary numbering — why can't lint just use the same
   numbers? This is historical; lint (and various other sibling
   libraries that lint depends on) was released earlier than the Gradle
   plugin; it was up to version 22 or so. When we then shipped the
   initial version of the Gradle plugin with Android Studio 1.0, we
   wanted to start the numbering over from “1” for this brand new
   artifact. However, some of the other libraries, like lint, couldn't
   just start over at 1, so we continued incrementing their versions in
   lockstep. Most users don't see this, but it's a wrinkle users of the
   Lint API have to be aware of.</div>

<p></p>
<a class="target" name=":libraryand:app">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/:libraryand:app">&nbsp;</a><a class="target" name="toc3.4">&nbsp;</a><h2>:library and :app</h2>
<p>


The <code>library</code> project depends on the lint check project, and will
package the lint checks as part of its payload. The <code>app</code> project
then depends on the <code>library</code>, and has some code which triggers
the lint check. This is there to demonstrate how lint checks can
be published and consumed, and this is described in detail in the
<a href="#publishingalintcheck">Publishing a Lint Check</a> chapter.

</p>
<a class="target" name="lintcheckprojectlayout">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/lintcheckprojectlayout">&nbsp;</a><a class="target" name="toc3.5">&nbsp;</a><h2>Lint Check Project Layout</h2>
<p>


The lint checks source project is very simple

</p><pre class="listing backtick"><code><span class="line"><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">build</span><span class="hljs-selector-class">.gradle</span></span>
<span class="line"><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">main</span>/<span class="hljs-selector-tag">resources</span>/<span class="hljs-selector-tag">META-INF</span>/<span class="hljs-selector-tag">services</span>/<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.lint</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.IssueRegistry</span></span>
<span class="line"><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">main</span>/<span class="hljs-selector-tag">java</span>/<span class="hljs-selector-tag">com</span>/<span class="hljs-selector-tag">example</span>/<span class="hljs-selector-tag">lint</span>/<span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">SampleIssueRegistry</span><span class="hljs-selector-class">.kt</span></span>
<span class="line"><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">main</span>/<span class="hljs-selector-tag">java</span>/<span class="hljs-selector-tag">com</span>/<span class="hljs-selector-tag">example</span>/<span class="hljs-selector-tag">lint</span>/<span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">SampleCodeDetector</span><span class="hljs-selector-class">.kt</span></span>
<span class="line"><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">test</span>/<span class="hljs-selector-tag">java</span>/<span class="hljs-selector-tag">com</span>/<span class="hljs-selector-tag">example</span>/<span class="hljs-selector-tag">lint</span>/<span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">SampleCodeDetectorTest</span><span class="hljs-selector-class">.kt</span></span></code></pre><p>

First is the build file, which we've discussed above.

</p>
<a class="target" name="serviceregistration">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/serviceregistration">&nbsp;</a><a class="target" name="toc3.6">&nbsp;</a><h2>Service Registration</h2>
<p>


Then there's the service registration file. Notice how this file is in
the source set <code>src/main/resources/</code>, which means that Gradle will
treat it as a resource and will package it into the output jar, in the
<code>META-INF/services</code> folder. This is using the service-provider loading facility in the JDK to register a service lint can look up. The
key is the fully qualified name for lint's <code>IssueRegistry</code> class.
And the <strong class="asterisk">contents</strong> of that file is a single line, the fully
qualified name of the issue registry:

</p><pre class="listing backtick"><code><span class="line"><span class="hljs-variable">$ </span>cat checks/src/main/resources/META-INF/services/com.android.tools.lint.client.api.IssueRegistry</span>
<span class="line">com.example.lint.checks.SampleIssueRegistry</span></code></pre><p>

(The service loader mechanism is understood by IntelliJ, so it will
correctly update the service file contents if the issue registry is
renamed etc.)

</p><p>

The service registration can contain more than one issue registry,
though there's usually no good reason for that, since a single issue
registry can provide multiple issues.

</p>
<a class="target" name="issueregistry">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/issueregistry">&nbsp;</a><a class="target" name="toc3.7">&nbsp;</a><h2>IssueRegistry</h2>
<p>


Next we have the <code>IssueRegistry</code> linked from the service registration.
Lint will instantiate this class and ask it to provide a list of
issues. These are then merged with lint's other issues when lint
performs its analysis.

</p><p>

In its simplest form we'd only need to have the following code
in that file:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-title">package</span> com.example.lint.checks</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.client.api.IssueRegistry</span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">SampleIssueRegistry</span> : <span class="hljs-type">IssueRegistry</span>() {</span>
<span class="line">    override val issues = listOf(<span class="hljs-type">SampleCodeDetector</span>.<span class="hljs-type">ISSUE</span>)</span>
<span class="line">}</span></span></code></pre><p>

However, we're also providing some additional metadata about these lint
checks, such as the <code>Vendor</code>, which contains information about the
author and (optionally) contact address or bug tracker information,
displayed to users when an incident is found.

</p><p>

We also provide some information about which version of lint's API the
check was compiled against, and the lowest version of the lint API that
this lint check has been tested with. (Note that the API versions are
not identical to the versions of lint itself; the idea and hope is that
the API may evolve at a slower pace than updates to lint delivering new
functionality).

</p>
<a class="target" name="detector">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/detector">&nbsp;</a><a class="target" name="toc3.8">&nbsp;</a><h2>Detector</h2>
<p>


The <code>IssueRegistry</code> references the <code>SampleCodeDetector.ISSUE</code>,
so let's take a look at <code>SampleCodeDetector</code>:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleCodeDetector</span> : <span class="hljs-type">Detector</span></span>(), UastScanner {</span>
<span class="line"></span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {</span>
<span class="line">        <span class="hljs-comment">/**</span>
<span class="line">         * Issue describing the problem and pointing to the detector</span>
<span class="line">         * implementation.</span>
<span class="line">         */</span></span>
<span class="line">        <span class="hljs-meta">@JvmField</span></span>
<span class="line">        <span class="hljs-keyword">val</span> ISSUE: Issue = Issue.create(</span>
<span class="line">            <span class="hljs-comment">// ID: used in @SuppressLint warnings etc</span></span>
<span class="line">            id = <span class="hljs-string">"ShortUniqueId"</span>,</span>
<span class="line">            <span class="hljs-comment">// Title -- shown in the IDE's preference dialog, as category headers in the</span></span>
<span class="line">            <span class="hljs-comment">// Analysis results window, etc</span></span>
<span class="line">            briefDescription = <span class="hljs-string">"Lint Mentions"</span>,</span>
<span class="line">            <span class="hljs-comment">// Full explanation of the issue; you can use some markdown markup such as</span></span>
<span class="line">            <span class="hljs-comment">// `monospace`, *italic*, and **bold**.</span></span>
<span class="line">            explanation = <span class="hljs-string">"""</span>
<span class="line">                    This check highlights string literals in code which mentions the word `lint`. \</span>
<span class="line">                    Blah blah blah.</span>
<span class="line"></span>
<span class="line">                    Another paragraph here.</span>
<span class="line">                    """</span>,</span>
<span class="line">            category = Category.CORRECTNESS,</span>
<span class="line">            priority = <span class="hljs-number">6</span>,</span>
<span class="line">            severity = Severity.WARNING,</span>
<span class="line">            implementation = Implementation(</span>
<span class="line">                SampleCodeDetector::<span class="hljs-keyword">class</span>.java,</span>
<span class="line">                Scope.JAVA_FILE_SCOPE</span>
<span class="line">            )</span>
<span class="line">        )</span>
<span class="line">    }</span>
<span class="line">}</span></div></code></pre><p>

The <code>Issue</code> registration is pretty self-explanatory, and the details
about issue registration are covered in the <a href="#writingalintcheck:basics">basics</a>
chapter. The excessive comments here are there to explain the sample,
and there are usually no comments in issue registration code like this.

</p><p>

Note how on line 29, the <code>Issue</code> registration names the <code>Detector</code>
class responsible for analyzing this issue: <code>SampleCodeDetector</code>. In
the above I deleted the body of that class; here it is now without the
issue registration at the end:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-keyword">package</span> com.example.lint.checks</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.client.api.UElementHandler</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Category</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Detector</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Detector.UastScanner</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Implementation</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Issue</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.JavaContext</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Scope</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Severity</span>
<span class="line"><span class="hljs-keyword">import</span> org.jetbrains.uast.UElement</span>
<span class="line"><span class="hljs-keyword">import</span> org.jetbrains.uast.ULiteralExpression</span>
<span class="line"><span class="hljs-keyword">import</span> org.jetbrains.uast.evaluateString</span>
<span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleCodeDetector</span> : <span class="hljs-type">Detector</span></span>(), UastScanner {</span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableUastTypes</span><span class="hljs-params">()</span></span>: List&lt;<span class="hljs-class"><span class="hljs-keyword">class</span>&lt;<span class="hljs-type">out uelement?=""</span>&gt;&gt; </span>{</span>
<span class="line">        <span class="hljs-keyword">return</span> listOf(ULiteralExpression::<span class="hljs-keyword">class</span>.java)</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createUastHandler</span><span class="hljs-params">(context: <span class="hljs-type">JavaContext</span>)</span></span>: UElementHandler {</span>
<span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : UElementHandler() {</span>
<span class="line">            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitLiteralExpression</span><span class="hljs-params">(node: <span class="hljs-type">ULiteralExpression</span>)</span></span> {</span>
<span class="line">                <span class="hljs-keyword">val</span> string = node.evaluateString() ?: <span class="hljs-keyword">return</span></span>
<span class="line">                <span class="hljs-keyword">if</span> (string.contains(<span class="hljs-string">"lint"</span>) &amp;&amp; string.matches(Regex(<span class="hljs-string">".*\\blint\\b.*"</span>))) {</span>
<span class="line">                    context.report(</span>
<span class="line">                        ISSUE, node, context.getLocation(node),</span>
<span class="line">                        <span class="hljs-string">"This code mentions `lint`: **Congratulations**"</span></span>
<span class="line">                    )</span>
<span class="line">                }</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span></div></code></pre><p>

This lint check is very simple; for Kotlin and Java files, it visits
all the literal strings, and if the string contains the word “lint”,
then it issues a warning.

</p><p>

This is using a very general mechanism of AST analysis; specifying the
relevant node types (literal expressions, on line 18) and visiting them
on line 23. Lint has a large number of convenience APIs for doing
higher level things, such as “call this callback when somebody extends
this class”, or “when somebody calls a method named ”foo“, and so on.
Explore the <code>SourceCodeScanner</code> and other <code>Detector</code> interfaces to see
what's possible. We'll hopefully also add more dedicated documentation
for this.

</p>
<a class="target" name="detectortest">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/detectortest">&nbsp;</a><a class="target" name="toc3.9">&nbsp;</a><h2>Detector Test</h2>
<p>


Last but not least, let's not forget the unit test:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-keyword">package</span> com.example.lint.checks</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.checks.infrastructure.TestFiles.java</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.checks.infrastructure.TestLintTask.lint</span>
<span class="line"><span class="hljs-keyword">import</span> org.junit.Test</span>
<span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleCodeDetectorTest</span> </span>{</span>
<span class="line">    <span class="hljs-meta">@Test</span></span>
<span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testBasic</span><span class="hljs-params">()</span></span> {</span>
<span class="line">        lint().files(</span>
<span class="line">            java(</span>
<span class="line">                <span class="hljs-string">"""</span>
<span class="line">                package test.pkg;</span>
<span class="line">                public class TestClass1 {</span>
<span class="line">                    // In a comment, mentioning "lint" has no effect</span>
<span class="line">                    private static String s1 = "Ignore non-word usages: linting";</span>
<span class="line">                    private static String s2 = "Let's say it: lint";</span>
<span class="line">                }</span>
<span class="line">                """</span></span>
<span class="line">            ).indented()</span>
<span class="line">        )</span>
<span class="line">        .issues(SampleCodeDetector.ISSUE)</span>
<span class="line">        .run()</span>
<span class="line">        .<span class="hljs-keyword">expect</span>(</span>
<span class="line">            <span class="hljs-string">"""</span>
<span class="line">            src/test/pkg/TestClass1.java:5: Warning: This code mentions lint: Congratulations [ShortUniqueId]</span>
<span class="line">                private static String s2 = "Let's say it: lint";</span>
<span class="line">                                           ∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼</span>
<span class="line">            0 errors, 1 warnings</span>
<span class="line">            """</span></span>
<span class="line">        )</span>
<span class="line">    }</span>
<span class="line">}</span></div></code></pre><p>

As you can see, writing a lint unit test is very simple, because
lint ships with a dedicated testing library; this is what the

</p><pre class="listing backtick"><code><span class="line">    testImplementation <span class="hljs-string">"com.android.tools.lint:lint-tests:<span class="hljs-variable">$lintVersion</span>"</span></span></code></pre><p>

dependency in build.gradle pulled in.

</p><p>

Unit testing lint checks is covered in depth in the
<a href="#lintcheckunittesting">unit </a><a href="#testing">testing</a> chapter, so we'll cut the
explanation of the above test short here.

</p><p>



</p>
<a class="target" name="publishingalintcheck">&nbsp;</a><a class="target" name="publishingalintcheck">&nbsp;</a><a class="target" name="toc4">&nbsp;</a><h1>Publishing a Lint Check</h1>
<p>


Lint will look for jar files with a service registry key for issue
registries.

</p><p>

You can manually point it to your custom lint checks jar files by using
the environment variable <code>ANDROID_LINT_JARS</code>:

</p><pre class="listing backtick"><code><span class="line"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> ANDROID_LINT_JARS=/path/to/first.jar:/path/to/second.jar</span></span></code></pre><p>
(On Windows, use <code>;</code> instead of <code>:</code> as the path separator)

</p><p>

However, that is only intended for development and as a workaround for
build systems that do not have direct support for lint or embedded lint
libraries, such as the internal Google build system.

</p>
<a class="target" name="android">&nbsp;</a><a class="target" name="publishingalintcheck/android">&nbsp;</a><a class="target" name="toc4.1">&nbsp;</a><h2>Android</h2>

<a class="target" name="aarsupport">&nbsp;</a><a class="target" name="publishingalintcheck/android/aarsupport">&nbsp;</a><a class="target" name="toc4.1.1">&nbsp;</a><h3>AAR Support</h3>
<p>


Android libraries are shipped as <code>.aar</code> files instead of <code>.jar</code> files.
This means that they can carry more than just the code payload. Under
the hood, <code>.aar</code> files are just zip files which contain many other
nested files, including api and implementation jars, resources,
proguard/r8 rules, and yes, lint jars.

</p><p>

For example, if we look at the contents of the timber logging library's
AAR file, we can see the lint.jar with several lint checks within as
part of the payload:

</p><pre class="listing backtick"><code><span class="line"><span class="hljs-meta">$</span><span class="bash"> jar tvf ~/.gradle/caches/.../jakewharton.timber/timber/4.5.1/?/timber-4.5.1.aar</span></span>
<span class="line">   216 Fri Jan 20 14:45:28 PST 2017 AndroidManifest.xml</span>
<span class="line">  8533 Fri Jan 20 14:45:28 PST 2017 classes.jar</span>
<span class="line"> 10111 Fri Jan 20 14:45:28 PST 2017 lint.jar</span>
<span class="line">    39 Fri Jan 20 14:45:28 PST 2017 proguard.txt</span>
<span class="line">     0 Fri Jan 20 14:45:24 PST 2017 aidl/</span>
<span class="line">     0 Fri Jan 20 14:45:28 PST 2017 assets/</span>
<span class="line">     0 Fri Jan 20 14:45:28 PST 2017 jni/</span>
<span class="line">     0 Fri Jan 20 14:45:28 PST 2017 res/</span>
<span class="line">     0 Fri Jan 20 14:45:28 PST 2017 libs/</span></code></pre><p>

The advantage of this approach is that when lint notices that you
depend on a library, and that library contains custom lint checks, then
lint will pull in those checks and apply them. This gives library
authors a way to provide their own additional checks enforcing usage.

</p>
<a class="target" name="lintpublishconfiguration">&nbsp;</a><a class="target" name="publishingalintcheck/android/lintpublishconfiguration">&nbsp;</a><a class="target" name="toc4.1.2">&nbsp;</a><h3>lintPublish Configuration</h3>
<p>


The Android Gradle library plugin provides some special configurations,
<code>lintConfig</code> and <code>lintPublish</code>.

</p><p>

The <code>lintPublish</code> configuration lets you reference another project, and
it will take that project's output jar and package it as a <code>lint.jar</code>
inside the AAR file.

</p><p>

The <a href="https://github.com/googlesamples/android-custom-lint-rules"></a><a href="https://github.com/googlesamples/android-custom-lint-rules" class="url">https://github.com/googlesamples/android-custom-lint-rules</a>
sample project demonstrates this setup.

</p><p>

The <code>:checks</code> project is a pure Kotlin library which depends on the
Lint APIs, implements a <code>Detector</code>, and provides an <code>IssueRegistry</code>
which is linked from <code>META-INF/services</code>.

</p><p>

Then in the Android library, the <code>:library</code> project applies the Android
Gradle library plugin. It then specifies a <code>lintPublish</code> configuration
referencing the checks lint project:

</p><pre class="listing tilde"><code><span class="line">apply plugin: <span class="hljs-string">'com.android.library'</span></span>
<span class="line">dependencies {</span>
<span class="line">    <span class="hljs-function">lintPublish <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">':checks'</span></span>)</span>
<span class="line">    <span class="hljs-comment">// other dependencies</span></span>
<span class="line">}</span></span></code></pre><p>

Finally, the sample <code>:app</code> project is an example of an Android app
which depends on the library, and the source code in the app contains a
violation of the lint check defined in the <code>:checks</code> project. If you
run <code>./gradlew :app:lint</code> to analyze the app, the build will fail
emitting the custom lint check.

</p>
<a class="target" name="localchecks">&nbsp;</a><a class="target" name="publishingalintcheck/android/localchecks">&nbsp;</a><a class="target" name="toc4.1.3">&nbsp;</a><h3>Local Checks</h3>
<p>


What if you aren't publishing a library, but you'd like to apply
some checks locally for your own codebase?

</p><p>

You can use a similar approach to <code>lintPublish</code>: In your app
module, specify

</p><pre class="listing tilde"><code><span class="line">apply plugin: <span class="hljs-string">'com.android.application'</span></span>
<span class="line">dependencies {</span>
<span class="line">    <span class="hljs-function">lintConfig <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">':checks'</span></span>)</span>
<span class="line">    <span class="hljs-comment">// other dependencies</span></span>
<span class="line">}</span></span></code></pre><p>

Now, when lint runs on this application, it will apply the checks
provided from the given project.

</p><p>

</p><div class="admonition warning">This mechanism works well on the CI server for enforcing local code
   conventions, and it also works for developers on your team; the
   errors should be flagged in the IDE (providing they are analyzing
   single-file scopes). However, there have been various bugs and
   difficulties around the lint checks getting rebuilt after changes or
   clean builds. There are some bugs in the Android Gradle Plugin issue
   tracker for this.</div>

<p></p>
<a class="target" name="unpublishing">&nbsp;</a><a class="target" name="publishingalintcheck/android/unpublishing">&nbsp;</a><a class="target" name="toc4.1.4">&nbsp;</a><h3>Unpublishing</h3>
<p>


If you end up “deleting” a lint check, perhaps because the original
conditions for the lint check are not true, don't just stop
distributing lint checks with your library. Instead, you'll want to
update your <code>IssueRegistry</code> to override the <code>deletedIssues</code> property to
return your deleted issue id or ids:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-comment">/**</span>
<span class="line"> * The issue id's from any issues that have been deleted from this</span>
<span class="line"> * registry. This is here such that when an issue no longer applies</span>
<span class="line"> * and is no longer registered, any existing mentions of the issue</span>
<span class="line"> * id in baselines, lint.xml files etc are gracefully handled.</span>
<span class="line"> */</span></span>
<span class="line">open val deletedIssues: <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">string</span>&gt; = emptyList()</span></code></pre><p>

The reason you'll want to do this is listed right there in the doc: If
you don't do this, and if users have for example listed your issue id
in their <code>build.gradle</code> file or in <code>lint.xml</code> to say change the
severity, then lint will report an error that it's an unknown id. This
is done to catch issue id typos. And if the user has a baseline file
listing incidents from your check, then if your issue id is not
registered as deleted, lint will think this is an issue that has been
“fixed“ since it's no longer reported, and lint will issue an
informational message that the baseline contains issues no longer
reported (which is done such that users can update their baseline
files, to ensure that the fixed issues aren't reintroduced again.)

</p><p>



</p>
<a class="target" name="lintcheckunittesting">&nbsp;</a><a class="target" name="lintcheckunittesting">&nbsp;</a><a class="target" name="toc5">&nbsp;</a><h1>Lint Check Unit Testing</h1>
<p>


Lint has a dedicated testing library for lint checks. To use it,
add this dependency to your lint check Gradle project:

</p><pre class="listing backtick"><code><span class="line">testImplementation <span class="hljs-string">"com.android.tools.lint:lint-tests:<span class="hljs-variable">$lintVersion</span>"</span></span></code></pre><p>

This lends itself nicely to test-driven development. When we get bug
reports of a false positive, we typically start by adding the text for
the repro case, ensure that the test is failing, and then work on the
bug fix (often setting breakpoints and debugging through the unit test)
until it passes.

</p>
<a class="target" name="creatingaunittest">&nbsp;</a><a class="target" name="lintcheckunittesting/creatingaunittest">&nbsp;</a><a class="target" name="toc5.1">&nbsp;</a><h2>Creating a Unit Test</h2>
<p>


Here's a sample lint unit test for a simple, sample lint check which
just issues warnings whenever it sees the word “lint” mentioned
in a string:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-keyword">package</span> com.example.lint.checks</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.checks.infrastructure.TestFiles.java</span>
<span class="line"><span class="hljs-keyword">import</span> com.android.tools.lint.checks.infrastructure.TestLintTask.lint</span>
<span class="line"><span class="hljs-keyword">import</span> org.junit.Test</span>
<span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleCodeDetectorTest</span> </span>{</span>
<span class="line">    <span class="hljs-meta">@Test</span></span>
<span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testBasic</span><span class="hljs-params">()</span></span> {</span>
<span class="line">        lint().files(</span>
<span class="line">            java(</span>
<span class="line">                <span class="hljs-string">"""</span>
<span class="line">                package test.pkg;</span>
<span class="line">                public class TestClass1 {</span>
<span class="line">                    // In a comment, mentioning "lint" has no effect</span>
<span class="line">                    private static String s1 = "Ignore non-word usages: linting";</span>
<span class="line">                    private static String s2 = "Let's say it: lint";</span>
<span class="line">                }</span>
<span class="line">                """</span></span>
<span class="line">            ).indented()</span>
<span class="line">        )</span>
<span class="line">        .issues(SampleCodeDetector.ISSUE)</span>
<span class="line">        .run()</span>
<span class="line">        .<span class="hljs-keyword">expect</span>(</span>
<span class="line">            <span class="hljs-string">"""</span>
<span class="line">            src/test/pkg/TestClass1.java:5: Warning: This code mentions lint: Congratulations [ShortUniqueId]</span>
<span class="line">                private static String s2 = "Let's say it: lint";</span>
<span class="line">                                           ∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼</span>
<span class="line">            0 errors, 1 warnings</span>
<span class="line">            """</span></span>
<span class="line">        )</span>
<span class="line">    }</span>
<span class="line">}</span></div></code></pre><p>

Lint's testing API is a “fluent API”; you chain method calls together,
and the return objects determine what is allowed next.

</p><p>

Notice how we construct a test object here on line 10 with the <code>lint()</code>
call. This is a “lint test task”, which has a number of setup methods
on it (such as the set of source files we want to analyze), the issues
it should consider, etc.

</p><p>

Then, on line 23, the <code>run()</code> method. This runs the lint unit test, and
then it returns a result object. On the result object we have a number
of methods to verify that the test succeeded. For a test making sure we
don't have false positives, you can just call <code>expectClean()</code>. But the
most common operation is to call <code>expect(output)</code>.

</p><p>

</p><div class="admonition tip">Notice how we're including the whole text output here; including not
   just the error message and line number, but lint's output of the
   relevant line and the error range (using ~~~~ characters).

<p></p><p>

   This is the recommended practice for lint checks. It may be tempting
   to avoid “duplication” of repeating error messages in the tests
   (“DRY”), so some developers have written tests where they just
   assert that a given test has say “2 warnings”. But this isn't
   testing that the error range is exactly what you expect (which
   matters a lot when users are seeing the lint check from the IDE,
   since that's the underlined region), and it could also continue to
   pass even if the errors flagged are no longer what you intended.

</p><p>

   Finally, even if the location is correct today, it may not be
   correct tomorrow. Several times in the past, some unit tests in
   lint's built-in checks have started failing after an update to the
   Kotlin compiler because of some changes to the AST which required
   tweaks here and there.</p></div>

<p></p>
<a class="target" name="computingtheexpectedoutput">&nbsp;</a><a class="target" name="lintcheckunittesting/computingtheexpectedoutput">&nbsp;</a><a class="target" name="toc5.2">&nbsp;</a><h2>Computing the Expected Output</h2>
<p>


You may wonder how we knew what to paste into our <code>expect</code> call
to begin with.

</p><p>

We didn't. When you write a test, simply start with
<code>expect("")</code>, and run the test. It will fail. You can now
copy the actual output into the <code>expect</code> call as the expected
output, provided of course that it's correct!

</p>
<a class="target" name="testfiles">&nbsp;</a><a class="target" name="lintcheckunittesting/testfiles">&nbsp;</a><a class="target" name="toc5.3">&nbsp;</a><h2>Test Files</h2>
<p>


On line 11, we construct a Java test file. We call <code>java(...)</code> and pass
in the source file contents. This constructs a <code>TestFile</code>, and there
are a number of different types of test source files, such as for
Kotlin files, manifest files, icons, property files, and so on.

</p><p>

Using test file descriptors like this has a number of advantages
over the traditional approach of checking in test files as sources:

</p><p>

</p><ul>
<li class="asterisk">Everything is kept together, so it's easier to look at a test and see
  what it analyzes and what the expected results are. This is
  particularly important for complex lint checks which test a lot of
  scenarios. As of this writing, <code>ApiDetectorTest</code> has 157 individual
  unit tests.

<p></p><p>

</p></li>
<li class="asterisk">Lint can provide a DSL to construct test files easily. For example,
  <code>projectProperties().compileSdk(17)</code> and
  <code>manifest().minSdk(5).targetSdk(17)</code> construct a <code>project.properties</code>
  and an <code>AndroidManifest.xml</code> file with the correct contents to
  specify for example the right <uses-sdk> element setting up the
  <code>minSdkVersion</code> and <code>targetSdkVersion</code>.

<p></p><p>

   For icons, we can construct bitmaps like this:</p></uses-sdk></li></ul>

<p></p><pre class="listing backtick"><code><span class="line">        <span class="hljs-selector-tag">image</span>("res/mipmap-hdpi/my_launcher2_round.png", <span class="hljs-number">50</span>, <span class="hljs-number">50</span>)</span>
<span class="line">           <span class="hljs-selector-class">.fillOval</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>xFFFFFFFF)</span>
<span class="line">           <span class="hljs-selector-class">.text</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, "x", <span class="hljs-number">0</span>xFFFFFFFF))</span></code></pre><p>


</p><ul>
<li class="asterisk">Similarly, when we construct <code>java()</code> or <code>kotlin()</code> test sources, we
  don't have to name the files, because lint will analyze the source
  code and figure out what the class file should be named and where to
  place it.

<p></p><p>

</p></li>
<li class="asterisk">We can easily “parameterize” our test files. For example, if you
  want to run your unit test against a 100K json file, you can
  construct it programmatically; you don't have to check one in.

<p></p><p>

</p></li>
<li class="asterisk">Since test sources often (deliberately!) have errors in them, this
  sometimes causes problems with the tooling; for example, some code
  review tools will flag “disallowed” constructs or things like tabs or
  trailing spaces, which may be deliberate in a lint unit test.

<p></p><p>

</p></li>
<li class="asterisk">Lint originally checked in test sources as individual files.
  Unfortunately over time, source files ended up getting reused by
  multiple tests. And that made it harder to make changes, or figure
  out whether test sources are still in use, and so on.

<p></p><p>

</p></li>
<li class="asterisk">Last but not least, because all the test construction methods
  specify the correct mime type for their string parameters, IntelliJ
  will actually syntax highlight the test source declarations! Here's
  how this looks:

<p></p><p>

  </p><center><div class="image" style=""><a href="api-guide/nested-syntax-highlighting.png"></a><center><span class="imagecaption">Screenshot of nested highlighting</span></center></div></center></li></ul>

<p></p>
<a class="target" name="trimmingindents?">&nbsp;</a><a class="target" name="lintcheckunittesting/trimmingindents?">&nbsp;</a><a class="target" name="toc5.4">&nbsp;</a><h2>Trimming indents?</h2>
<p>


Notice how in the above Kotlin unit tests we used raw strings, <strong class="asterisk">and</strong>
we indented the sources to be flush with the opening “”“ string
delimiter.

</p><p>

You might be tempted to call <code>.trimIndent()</code> on the raw string.
However, doing that would break the above nested syntax highlighting
method (or at least it used to). Therefore, instead, call <code>.indented()</code>
on the test file itself, not the string, as shown on line 20.

</p><p>

Note that we don't need to do anything with the <code>expect</code> call; lint
will automatically call <code>trimIndent()</code> on the string passed in to it.

</p>
<a class="target" name="dollarsinrawstrings">&nbsp;</a><a class="target" name="lintcheckunittesting/dollarsinrawstrings">&nbsp;</a><a class="target" name="toc5.5">&nbsp;</a><h2>Dollars in Raw Strings</h2>
<p>


Kotlin requires that raw strings have to escape the dollar ($)
character. That's normally not a problem, but for some source files, it
makes the source code look <strong class="asterisk">really</strong> messy and unreadable.

</p><p>

For that reason, lint will actually convert $ into ＄ (a unicode wide
dollar sign). Lint lets you use this character in test sources, and it
always converts the test output to use it (though it will convert in
the opposite direction when creating the test sources on disk).

</p>
<a class="target" name="quickfixes">&nbsp;</a><a class="target" name="lintcheckunittesting/quickfixes">&nbsp;</a><a class="target" name="toc5.6">&nbsp;</a><h2>Quickfixes</h2>
<p>


If your lint check registers quickfixes with the reported incidents,
it's trivial to test these as well.

</p><p>

For example, for a lint check result which flags two incidents, with a
single quickfix, the unit test looks like this:

</p><pre class="listing backtick"><code><span class="line">lint().files(<span class="hljs-operator">...</span>)</span>
<span class="line">    .run()</span>
<span class="line">    .expect(expected)</span>
<span class="line">    .expectFixDiffs(</span>
<span class="line">        <span class="hljs-string">""</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"Fix for res/layout/textsize.xml line 10: Replace with sp:<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"@@ -11 +11<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"-         android:textSize=<span class="hljs-subst">\"</span>14dp<span class="hljs-subst">\"</span> /&gt;<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"+         android:textSize=<span class="hljs-subst">\"</span>14sp<span class="hljs-subst">\"</span> /&gt;<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"Fix for res/layout/textsize.xml line 15: Replace with sp:<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"@@ -16 +16<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"-         android:textSize=<span class="hljs-subst">\"</span>14dip<span class="hljs-subst">\"</span> /&gt;<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"+         android:textSize=<span class="hljs-subst">\"</span>14sp<span class="hljs-subst">\"</span> /&gt;<span class="hljs-subst">\n</span>"</span>);</span></code></pre><p>

The <code>expectFixDiffs</code> method will iterate over all the incidents it
found, and in succession, apply the fix, diff the two sources, and
append this diff along with the fix message into the log.

</p><p>

When there are multiple fixes offered for a single incident, it will
iterate through all of these too:

</p><pre class="listing backtick"><code><span class="line">lint().files(<span class="hljs-operator">...</span>)</span>
<span class="line">    .run()</span>
<span class="line">    .expect(expected)</span>
<span class="line">    .expectFixDiffs(</span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"Fix for res/layout/autofill.xml line 7: Set autofillHints:<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"@@ -12 +12<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:layout_width=<span class="hljs-subst">\"</span>match_parent<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:layout_height=<span class="hljs-subst">\"</span>wrap_content<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"+         android:autofillHints=<span class="hljs-subst">\"</span>|<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:hint=<span class="hljs-subst">\"</span>hint<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:inputType=<span class="hljs-subst">\"</span>password<span class="hljs-subst">\"</span> &gt;<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"Fix for res/layout/autofill.xml line 7: Set importantForAutofill=<span class="hljs-subst">\"</span>no<span class="hljs-subst">\"</span>:<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"@@ -13 +13<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:layout_height=<span class="hljs-subst">\"</span>wrap_content<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:hint=<span class="hljs-subst">\"</span>hint<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"+         android:importantForAutofill=<span class="hljs-subst">\"</span>no<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:inputType=<span class="hljs-subst">\"</span>password<span class="hljs-subst">\"</span> &gt;<span class="hljs-subst">\n</span>"</span></span>
<span class="line">        <span class="hljs-operator">+</span> <span class="hljs-string">"  <span class="hljs-subst">\n</span>"</span>);</span></code></pre>
<a class="target" name="librarydependenciesandstubs">&nbsp;</a><a class="target" name="lintcheckunittesting/librarydependenciesandstubs">&nbsp;</a><a class="target" name="toc5.7">&nbsp;</a><h2>Library Dependencies and Stubs</h2>
<p>


Let's say you're writing a lint check for something like the Android
Jetpack library's <code>RecyclerView</code> widget.

</p><p>

In this case, it's highly likely that your unit test will reference
<code>RecyclerView</code>. But how does lint know what <code>RecyclerView</code> is? If it
doesn't, type resolve won't work, and as a result the detector won't.

</p><p>

You could make your test ”depend“ on the <code>RecyclerView</code>. This is
possible, using the <code>LibraryReferenceTestFile</code>, but is not recommended.

</p><p>

Instead, the recommended approach is to just use ”stubs“; create
skeleton classes which represent only the <strong class="asterisk">signatures</strong> of the
library, and in particular, only the subset that your lint check cares
about.

</p><p>

For example, for lint's own <code>RecyclerView</code> test, the unit test declares
a field holding the recycler view stub:

</p><pre class="listing backtick"><code><span class="line">private val recyclerViewStub = java(</span>
<span class="line">    <span class="hljs-string">"""</span>
<span class="line">    package android.support.v7.widget;</span>
<span class="line"></span>
<span class="line">    import android.content.Context;</span>
<span class="line">    import android.util.AttributeSet;</span>
<span class="line">    import android.view.View;</span>
<span class="line">    import java.util.List;</span>
<span class="line"></span>
<span class="line">    // Just a stub for lint unit tests</span>
<span class="line">    public class RecyclerView extends View {</span>
<span class="line">        public RecyclerView(Context context, AttributeSet attrs) {</span>
<span class="line">            super(context, attrs);</span>
<span class="line">        }</span>
<span class="line"></span>
<span class="line">        public abstract static class ViewHolder {</span>
<span class="line">            public ViewHolder(View itemView) {</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line"></span>
<span class="line">        public abstract static class Adapter&lt;vh extends="" viewholder=""&gt; {</span>
<span class="line">            public abstract void onBindViewHolder(VH holder, int position);</span>
<span class="line">            public void onBindViewHolder(VH holder, int position, List&lt;object&gt; payloads) {</span>
<span class="line">            }</span>
<span class="line">            public void notifyDataSetChanged() { }</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">    """</span></span>
<span class="line">).indented()</span></code></pre><p>

And now, all the other unit tests simply include <code>recyclerViewStub</code>
as one of the test files. For a larger example, see
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-master-dev:lint/libs/lint-tests/src/test/java/com/android/tools/lint/checks/SliceDetectorTest.kt">this test</a>.

</p>
<a class="target" name="binaryandcompiledsourcefiles">&nbsp;</a><a class="target" name="lintcheckunittesting/binaryandcompiledsourcefiles">&nbsp;</a><a class="target" name="toc5.8">&nbsp;</a><h2>Binary and Compiled Source Files</h2>
<p>


If you need to use binaries in your unit tests, there is
a special test file type for that: base64gzip. Here's an
example from a lint check which tries to recognize usage
of Cordova in the bytecode:

</p><pre class="listing backtick"><code><span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testVulnerableCordovaVersionInClasses</span><span class="hljs-params">()</span></span> {</span>
<span class="line">    lint().files(</span>
<span class="line">        base64gzip(</span>
<span class="line">            <span class="hljs-string">"bin/classes/org/apache/cordova/Device.class"</span>,</span>
<span class="line">            <span class="hljs-string">""</span> +</span>
<span class="line">                <span class="hljs-string">"yv66vgAAADIAFAoABQAPCAAQCQAEABEHABIHABMBAA5jb3Jkb3ZhVmVyc2lv"</span> +</span>
<span class="line">                <span class="hljs-string">"bgEAEkxqYXZhL2xhbmcvU3RyaW5nOwEABjxpbml0PgEAAygpVgEABENvZGUB"</span> +</span>
<span class="line">                <span class="hljs-string">"AA9MaW5lTnVtYmVyVGFibGUBAAg8Y2xpbml0PgEAClNvdXJjZUZpbGUBAAtE"</span> +</span>
<span class="line">                <span class="hljs-string">"ZXZpY2UuamF2YQwACAAJAQAFMi43LjAMAAYABwEAGW9yZy9hcGFjaGUvY29y"</span> +</span>
<span class="line">                <span class="hljs-string">"ZG92YS9EZXZpY2UBABBqYXZhL2xhbmcvT2JqZWN0ACEABAAFAAAAAQAJAAYA"</span> +</span>
<span class="line">                <span class="hljs-string">"BwAAAAIAAQAIAAkAAQAKAAAAHQABAAEAAAAFKrcAAbEAAAABAAsAAAAGAAEA"</span> +</span>
<span class="line">                <span class="hljs-string">"AAAEAAgADAAJAAEACgAAAB4AAQAAAAAABhICswADsQAAAAEACwAAAAYAAQAA"</span> +</span>
<span class="line">                <span class="hljs-string">"AAUAAQANAAAAAgAO"</span></span>
<span class="line">        )`</span>
<span class="line">    ).run().<span class="hljs-keyword">expect</span>(</span></code></pre><p>

Here, ”base64gzip“ means that the file is gzipped and then base64
encoded.

</p><p>

If you want to compute the base64gzip string for a given file, a simple
way to do it is to add this statement at the beginning of your test:

</p><pre class="listing backtick"><code><span class="line">assertEquals(<span class="hljs-string">""</span>, TestFiles.toBase64gzip(<span class="hljs-name">File</span>(<span class="hljs-string">"/tmp/mybinary.bin"</span>)))</span></code></pre><p>

The test will fail, and now you have your output to copy/paste into the
test.

</p><p>

However, if you're writing byte-code based tests, don't just hard code
in the .class file or .jar file contents like this. Lint's own unit
tests did that, and it's hard to later reconstruct what the byte code
was later if you need to make changes or extend it to other bytecode
formats.

</p><p>

Instead, use the new <code>compiled</code> or <code>bytecode</code> test files. The key here
is that they automate a bit of the above process: the test file
provides a source test file, as well as a set of corresponding binary
files (since a single source file can create multiple class files, and
for Kotlin, some META-INF data).

</p><p>

Initially, you just specify the sources, and when no binary data
has been provided, lint will instead attempt to compile the sources
and emit the full test file registration.

</p><p>

This isn't just a convenience; lint's test infrastructure also uses
this to test some additional scenarios (for example, in a multi- module
project it will only provide the binaries, not the sources, for
upstream modules.)

</p>
<a class="target" name="mydetectorisn'tinvokedfromatest!">&nbsp;</a><a class="target" name="lintcheckunittesting/mydetectorisn'tinvokedfromatest!">&nbsp;</a><a class="target" name="toc5.9">&nbsp;</a><h2>My Detector Isn't Invoked From a Test!</h2>
<p>


One common question we hear is
</p><blockquote>
 My Detector works fine when I run it in the IDE or from Gradle, but
 from my unit test, my detector is never called! Why?</blockquote>

<p></p><p>

This is almost always because the test sources are referring to some
library or dependency which isn't on the class path. See the ”Library
Dependencies and Stubs“ section above, as well as the <a href="#frequentlyaskedquestions">frequently asked
questions</a>.

</p><p>



</p>
<a class="target" name="addingquickfixes">&nbsp;</a><a class="target" name="addingquickfixes">&nbsp;</a><a class="target" name="toc6">&nbsp;</a><h1>Adding Quick Fixes</h1>

<a class="target" name="introduction">&nbsp;</a><a class="target" name="addingquickfixes/introduction">&nbsp;</a><a class="target" name="toc6.1">&nbsp;</a><h2>Introduction</h2>
<p>


When your detector reports an incident, it can also provide one or more
“quick fixes“, which are actions the users can invoke in the IDE (or,
for safe fixes, in batch mode) to address the reported incident.

</p><p>

For example, if the lint check reports an unused resource, a quick fix
could offer to remove the unused resource.

</p><p>

In some cases, quick fixes can take partial steps towards fixing the
problem, but not fully. For example, the accessibility lint check which
makes sure that for images you set a content description, the quickfix
can offer to add it — but obviously it doesn't know what description
to put. In that case, the lint fix will go ahead and add the attribute
declaration with the correct namespace and attribute name, but will
leave the value up to the user (so it uses a special quick fix provided
by lint to place a TODO marker as the value, along with selecting just
that TODO string such that the user can type to replace without having
to manually delete the TODO string first.)

</p>
<a class="target" name="thelintfixbuilderclass">&nbsp;</a><a class="target" name="addingquickfixes/thelintfixbuilderclass">&nbsp;</a><a class="target" name="toc6.2">&nbsp;</a><h2>The LintFix builder class</h2>
<p>


The class in lint which represents a quick fix is <code>LintFix</code>.

</p><p>

Note that <code>LintFix</code> is <strong class="asterisk">not</strong> a class you can subclass and then for
example implement your own arbitrary code in something like a
<code>perform()</code> method.

</p><p>

Instead, <code>LintFix</code> has a number of builders where you <em class="asterisk">describe</em> the
action that you would like the quickfix to take. Then, lint will offer
that quickfix in the IDE, and when the user invokes it, lint runs its
own implementation of the various descriptors.

</p><p>

The historical reason for this is that many of the quickfixes in lint
depended on machinery in the IDE (such as code and import cleanup after
an edit operation) that isn't available in lint itself, along with
other concepts that only make sense in the IDE, such as moving the
caret, opening files, selecting text, and so on.

</p><p>

More recently, this is also used to persist quickfixes properly for
later reuse; this is required for <a href="#partialanalysis">partial
analysis</a>.

</p>
<a class="target" name="creatingalintfix">&nbsp;</a><a class="target" name="addingquickfixes/creatingalintfix">&nbsp;</a><a class="target" name="toc6.3">&nbsp;</a><h2>Creating a LintFix</h2>
<p>


Lint fixes use a ”fluent API“; you first construct a <code>LintFix</code>, and on
that method you call various available type methods, which will then
further direct you to the allowed options.

</p><p>

For example, to create a lint fix to set an XML attribute of a given
name to ”true“, use something like this:

</p><pre class="listing tilde"><code><span class="line">LintFix fix = fix().<span class="hljs-keyword">set</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">"singleLine"</span>, <span class="hljs-string">"true"</span>).build()</span></code></pre><p>

Here the <code>fix()</code> method is provided by the <code>Detector</code> super class, but
that's just a utility method for <code>LintFix.fix()</code> (or in older versions,
<code>LintFix.create()</code>).

</p><p>

There are a number of additional, common methods you can set on
the <code>fix()</code> object:

</p><p>

</p><ul>
<li class="asterisk"><code>name</code>: Sets the description of the lint fix. This should be brief;
  it's in the quickfix popup shown to the user.

<p></p><p>

</p></li>
<li class="asterisk"><code>sharedName</code>: This sets the ”shared“ or ”family“ name: all fixes in
  the file will with the same name can be applied in a single
  invocation by the user. For example, if you register 500 ”Remove
  unused import“ quickfixes in a file, you don't want to force the user
  to have to invoke each and every one. By setting the shared name, the
  user will be offered to <strong class="asterisk">Fix All <em class="asterisk">$family name</em> problems in the
  current file</strong>, which they can then perform to have all 500
  individual fixes applied in one go.

<p></p><p>

</p></li>
<li class="asterisk"><code>autoFix</code>: If you get a lint report and you notice there are a lot of
  incidents that lint can fix automatically, you don't want to have to
  go and open each and every file and all the fixes in the file.
  Therefore, lint can apply the fixes in batch mode; the Gradle
  integration has a <code>lintFix</code> target to perform this, and the <code>lint</code>
  command has an <code>--apply-suggestions</code> option.

<p></p><p>

  However, many quick fixes require user intervention. Not just the
  ones where the user has to choose among alternatives, and not just
  the ones where the quick fix inserts a placeholder value like TODO.
  Take for example lint's built-in check which requires overrides of a
  method annotated with <code>@CallSuper</code> to invoke <code>super.</code> on the
  overridden method. Where should we insert the call — at the
  beginning? At the end?

</p><p>

  Therefore, lint has the <code>autoFix</code> property you can set on a quickfix.
  This indicates that this fix is ”safe“ and can be performed in batch
  mode. When the <code>lintFix</code> target runs, it will only apply fixes marked
  safe in this way.</p></li></ul>

<p></p>
<a class="target" name="availablefixes">&nbsp;</a><a class="target" name="addingquickfixes/availablefixes">&nbsp;</a><a class="target" name="toc6.4">&nbsp;</a><h2>Available Fixes</h2>
<p>


The current set of available quick fix types are:

</p><p>

</p><ul>
<li class="asterisk"><code>fix().replace</code>: String replacements. This is the most general
  mechanism, and allows you to perform arbitrary edits to the source
  code. In addition to the obvious ”replace old string with new“, the
  old string can use a different location range than the incident
  range, you can match with regular expressions (and perform
  replacements on a specific group within the regular expression), and
  so on.

<p></p><p>

  This fix is also the most straightforward way to <strong class="asterisk">delete</strong> text.

</p><p>

  It offers some useful cleanup operations:

</p><p>

</p><ul>
  <li class="minus">Source code cleanup, which will run the IDE's code formatter on the
      modified source code range. This will apply the user's code
      preferences, such as whether there should be a space between a cast
      and the expression, and so on.

<p></p><p>

</p></li>
  <li class="minus">Import cleanup. That means that if you are referencing a new type,
      you don't have to worry about checking whether it is imported and
      if not adding an import statement; you can simply write your string
      replacements using the fully qualified names, and then tag the
      quickfix with the import cleanup option, and when the quickfix is
      performed the import will be added if necessary and all the fully
      qualified references replaced with simple names. And this will also
      correctly handle the scenario where the symbols cannot be replaced
      with simple names because there is a conflicting import of the same
      name from a different package.

<p></p><p>

</p></li></ul>
</li><li class="asterisk"><code>fix().annotate</code>: Annotating an element. This will add (or optionally
  replace) an annotation on a source element such as a method. It will
  also handle import management.

<p></p><p>

</p></li>
<li class="asterisk"><code>fix().set</code>: Add XML attributes. This will insert an attribute into
  the given element, applying the user's code style preferences for
  where to insert the attribute. (In Android XML for example there's a
  specific sorting convention which is generally alphabetical, except
  layout params go before other attributes, and width goes before
  height.)

<p></p><p>

  You can either set the value to something specific, or place the
  caret inside the newly created empty attribute value, or set it
  to TODO and select that text for easy type-to-replace.</p></li></ul>

<p></p><p>

</p><div class="admonition tip">If you use the <code>todo()</code> quickfix, it's a good idea to special case
   your lint check to deliberately not accept ”TODO“ as a valid value.
   For example, for lint's accessibility check which makes sure you set
   a content description, it will complain both when you haven't set
   the content description attribute, <strong class="asterisk">and</strong> if the text is set to
   ”TODO“. That way, if the user applies the quickfix, which creates
   the attribute in the right place and moves the focus to the right
   place, the editor is still showing a warning that the content
   description should be set.</div>

<p></p><p>

</p><ul>
<li class="asterisk"><code>fix().unset</code>: Remove XML attribute. This is a special case of add
  attribute.

<p></p><p>

</p></li>
<li class="asterisk"><code>fix().url</code>: Show URL. In some cases, you can't ”fix“ or do anything
  local to address the problem, but you really want to direct the
  user's attention to additional documentation. In that case, you can
  attach a ”show this URL“ quick fix to the incident which will open
  the browser with the given URL when invoked. For example, in a
  complicated deprecation where you want users to migrate from one
  approach to a completely different one that you cannot automate, you
  could use something like this:</li></ul>

<p></p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">val</span> message = <span class="hljs-string">"Job scheduling with `GcmNetworkManager` is deprecated: Use AndroidX `WorkManager` instead"</span></span>
<span class="line"><span class="hljs-keyword">val</span> fix = fix()</span>
<span class="line">.url(<span class="hljs-string">"https://developer.android.com/topic/libraries/architecture/workmanager/migrating-gcm"</span>)</span>
<span class="line">.build()</span></code></pre>
<a class="target" name="combiningfixes">&nbsp;</a><a class="target" name="addingquickfixes/combiningfixes">&nbsp;</a><a class="target" name="toc6.5">&nbsp;</a><h2>Combining Fixes</h2>
<p>


You might notice that lint's APIs to report incidents only takes a
<strong class="asterisk">single</strong> quick fix instead of a list of fixes.

</p><p>

But let's say that it <em class="asterisk">did</em> take a list of quick fixes.

</p><p>

</p><ul>
<li class="minus">Should they <em class="asterisk">all</em> be performed as a single unit? That makes sense if
  you're trying to write a quickfix which performs multiple string
  replacements.

<p></p><p>

</p></li>
<li class="minus">Or should they be offered as separate alternatives for the user to
  choose between? That makes sense if the incident says for example
  that you must set at least one attribute among three possibilities;
  in this case we may want to add quickfixes for setting each attribute.</li></ul>

<p></p><p>

Both scenarios have their uses, so lint makes this explicit:

</p><p>

</p><ul>
<li class="minus"><code>fix().composite</code>: create a ”composite“ fix, which composes the fix
  out of multiple individual fixes, or

<p></p><p>

</p></li>
<li class="minus"><code>fix().alternatives</code>: create an ”alternatives“ fix, which holds a
  number of individual fixes, which lint will present as separate
  options to the user.</li></ul>

<p></p><p>

Here's an example of how to create a composite fix, which will be
performed as a unit; here we're both setting a new attribute and
deleting a previous attribute:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">val</span> fix = fix().name(<span class="hljs-string">"Replace with singleLine=\"true\""</span>)</span>
<span class="line">    .composite(</span>
<span class="line">        fix().<span class="hljs-keyword">set</span>(ANDROID_URI, <span class="hljs-string">"singleLine"</span>, <span class="hljs-string">"true"</span>).build(),</span>
<span class="line">        fix().unset(namespace, oldAttributeName).build()</span>
<span class="line">    )</span></code></pre><p>

And here's an example of how to create an alternatives fix, which are
offered to the user as separate options; this is from our earlier
example of the accessibility check which requires you to set a content
description, which can be set either on the ”text“ attribute or the
“contentDescription” attribute:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">val</span> fix = fix().alternatives(</span>
<span class="line">    fix().<span class="hljs-keyword">set</span>().todo(ANDROID_URI, <span class="hljs-string">"text"</span>).build(),</span>
<span class="line">    fix().<span class="hljs-keyword">set</span>().todo(ANDROID_URI, <span class="hljs-string">"contentDescription"</span>)</span>
<span class="line">    .build())</span></code></pre>
<a class="target" name="refactoringjavaandkotlincode">&nbsp;</a><a class="target" name="addingquickfixes/refactoringjavaandkotlincode">&nbsp;</a><a class="target" name="toc6.6">&nbsp;</a><h2>Refactoring Java and Kotlin code</h2>
<p>


It would be nice if there was an AST manipulation API, similar to UAST
for visiting ASTs, that quickfixes could use to implement refactorings,
but we don't have a library like that. And it's unlikely it would work
well; when you rewrite the user's code you typically have to take
language specific conventions into account.

</p><p>

Therefore, today, when you create quickfixes for Kotlin and Java code,
if the quickfix isn't something simple which would work for both
languages, then you need to conditionally create either the Kotlin
version or the Java version of the quickfix based on whether the source
file it applies to is in Kotlin or Java. (For an easy way to check you
can use the <code>isKotlin</code> or <code>isJava</code> package level methods in
<code>com.android.tools.lint.detector.api</code>.)

</p><p>

However, it's often the case that the quickfix is something simple
which would work for both; that's true for most of the built-in lint
checks with quickfixes for Kotlin and Java.

</p>
<a class="target" name="regularexpressionsandbackreferences">&nbsp;</a><a class="target" name="addingquickfixes/regularexpressionsandbackreferences">&nbsp;</a><a class="target" name="toc6.7">&nbsp;</a><h2>Regular Expressions and Back References</h2>
<p>


The <code>replace</code> string quick fix allows you to match the text to
with regular expressions.

</p><p>

You can also use back references in the regular expression such
that the quick fix replacement text includes portions from the
original string.

</p><p>

Here's an example from lint's <code>AssertDetector</code>:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"><span class="hljs-keyword">val</span> fix = fix().name(<span class="hljs-string">"Surround with desiredAssertionStatus() check"</span>)</span>
<span class="line">    .replace()</span>
<span class="line">    .range(context.getLocation(assertCall))</span>
<span class="line">    .pattern(<span class="hljs-string">"(.*)"</span>)</span>
<span class="line">    .with(<span class="hljs-string">"if (javaClass.desiredAssertionStatus()) { \\k&lt;1&gt; }"</span>)</span>
<span class="line">    .reformat(<span class="hljs-literal">true</span>)</span>
<span class="line">    .build()</span></div></code></pre><p>

The replacement string's back reference above, on line 5, is \k&lt;1&gt;. If
there were multiple regular expression groups in the replacement
string, this could have been \k&lt;2&gt;, \k&lt;3&gt;, and so on.

</p><p>

Here's how this looks when applied, from its unit test:

</p><pre class="listing tilde"><code><span class="line">lint().files().run().expectFixDiffs(</span>
<span class="line">    <span class="hljs-string">"""</span>
<span class="line">    Fix for src/test/pkg/AssertTest.kt line 18: Surround with desiredAssertionStatus() check:</span>
<span class="line">    @@ -18 +18</span>
<span class="line">    -         assert(expensive()) // WARN</span>
<span class="line">    +         if (javaClass.desiredAssertionStatus()) { assert(expensive()) } // WARN</span>
<span class="line">    """</span></span>
<span class="line">)</span></code></pre>
<a class="target" name="emittingquickfixxmltoapplyonci">&nbsp;</a><a class="target" name="addingquickfixes/emittingquickfixxmltoapplyonci">&nbsp;</a><a class="target" name="toc6.8">&nbsp;</a><h2>Emitting quick fix XML to apply on CI</h2>
<p>


Note that the <code>lint</code> has an option (<code>--describe-suggestions</code>) to emit
an XML file which describes all the edits to perform on documents to
apply a fix. This maps all quick fixes into chapter edits (including
XML logic operations). This can be (and is, within Google) used to
integrate with code review tools such that the user can choose whether
to auto-fix a suggestion right from within the code review tool.

</p>
<a class="target" name="partialanalysis">&nbsp;</a><a class="target" name="partialanalysis">&nbsp;</a><a class="target" name="toc7">&nbsp;</a><h1>Partial Analysis</h1>

<a class="target" name="about">&nbsp;</a><a class="target" name="partialanalysis/about">&nbsp;</a><a class="target" name="toc7.1">&nbsp;</a><h2>About</h2>
<p>


This chapter describes Lint's “partial analysis”; its architecture and
APIs for allowing lint results to be cached.

</p><p>

This focuses on how to write or update existing lint checks such that
they work correctly under partial analysis. For other details about
partial analysis, such as the client side implemented by the build
system, see the lint internal docs folder.

</p><p>

</p><div class="admonition note">Note that while lint has this architecture, and all lint detectors
   must support it, the checks may not run in partial analysis mode;
   they may instead run in “global analysis mode”, which is how lint
   has worked up until this point.

<p></p><p>

   This is because coordinating partial results and merging is
   performed by the <code>LintClient</code>; e.g. in the IDE, there's no good
   reason to do all this extra work (because all sources are generally
   available, including “downstream” module info like the
   <code>minSdkVersion</code>).

</p><p>

   Right now, only the Android Gradle Plugin turns on partial analysis
   mode. But that's a very important client, since it's usually how
   lint checks are performed on continuous integration servers to
   validate code reviews.</p></div>

<p></p>
<a class="target" name="theproblem">&nbsp;</a><a class="target" name="partialanalysis/theproblem">&nbsp;</a><a class="target" name="toc7.2">&nbsp;</a><h2>The Problem</h2>
<p>


Many lint checks require “global” analysis. For example you can't
determine whether a particular string defined in a library module is
unused unless you look at all modules transitively consuming this
library as well.

</p><p>

However, many developers run lint as part of their continuous
integration. Particularly in large projects, analyzing all modules for
every check-in is too costly.

</p><p>

This chapter describes lint's architecture for handling this, such
that module results can be cached.

</p>
<a class="target" name="overview">&nbsp;</a><a class="target" name="partialanalysis/overview">&nbsp;</a><a class="target" name="toc7.3">&nbsp;</a><h2>Overview</h2>
<p>


Briefly stated, lint's architecture for this is “map reduce”: lint now
has two separate phases, analyze and report (map and reduce
respectively):

</p><p>

</p><ul>
<li class="asterisk"><strong class="asterisk">analyze</strong> - where lint analyzes source code of a single module in
  isolation, and stores some intermediate partial results (map)

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk">report</strong> - where lint reads in the previously stored module results,
  and performs some post-processing on this data to generate an actual
  lint report.</li></ul>

<p></p><p>

Crucially, the individual module results can be cached, such that if
nothing has changed in a module, the module results continue to be
valid (unless signatures have changed in libraries it depends on.)

</p><p>

Making this work requires some modifications to any <code>Detector</code> which
considers data from outside the current module. However, there are some
very common scenarios that lint has special support for to make this
easier.

</p><p>

Detectors fit into one of the following categories (and these
categories will be explained in subsequent sessions) :

</p><p>

</p><ol start="1">
<li class="number">Local analysis which doesn't depend on anything else. For example,
   a lint check which flags typos can report incidents immediately.
   Lint calls these “definite incidents”.

<p></p><p>

</p></li>
<li class="number">Local analysis which depends on a few, common conditions. For
   example, in Android, a check may only apply if the <code>minSdkVersion &lt;
   21</code>. Lint has special support for this; you basically report an
   incident and attach a “constraint” to it. Lint calls these, and
   incidents reported as part of #3 below, as “provisional incidents”.

<p></p><p>

</p></li>
<li class="number">Analysis which depends on some conditions of downstream modules that
   are not part of the built-in constraints. For example, a lint check
   may only apply if the consuming module depends on a certain version
   of a networking library. In this case, the detector will report the
   incident and attach a map to it, with whatever data it needs to
   consult later to decide if the incident actually should be reported.
   When the detector reports incidents this way, it has to also
   override a callback method. Lint will record these incidents, and
   during reporting, call the detector and pass it back its data map
   and provisional incidents such that it can decide whether the
   incidents should indeed be reported.

<p></p><p>

</p></li>
<li class="number">Last, and least, there are some scenarios where you cannot compute
   provisional incidents up front and filter them later (or doing so
   would be very costly). For example, unused resources fit into this
   category. We don't want to report every single resource declaration
   as unused and then filter later. Instead, we compute the resource
   usage graph within the module analysis. And in the reporting task,
   we then load all the partial usage graphs, and merge them together
   and walk the graph to report all the unused resources. To support
   this, lint provides a map per module for detectors to put their data
   into, and you can put maps into the map to model structured data.
   Lint will persist these, and in the reporting task the lint
   detectors will be passed their data to do their post-processing and
   reporting based on their data.</li></ol>

<p></p><p>

These are listed in increasing order of effort, and thankfully, they're
also listed in order of frequency. For lint's built-in checks (~385),

</p><p>

</p><ul>
<li class="asterisk">89% needed no work at all.
</li>
<li class="asterisk">6% were updated to report incidents with constraints
</li>
<li class="asterisk">4% were updated to report incidents with data for later filtering
</li>
<li class="asterisk">1% were updated to perform map recording and later reduce filtering</li></ul>

<p></p>
<a class="target" name="doesmydetectorneedwork?">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?">&nbsp;</a><a class="target" name="toc7.4">&nbsp;</a><h2>Does My Detector Need Work?</h2>
<p>


At this point you're probably wondering whether your checks are in the
89% category where you don't need to do anything, or in the remaining
11%. How do you know?

</p><p>

Lint has several built-in mechanisms to try to catch problems. There
are a few scenarios it cannot detect, and these are described below,
but for the vast majority, simply running your unit tests (which are
comprehensive, right?) should create unit test failures if your
detector is doing something it shouldn't.

</p>
<a class="target" name="catchingmistakes:blockingaccesstomainproject">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?/catchingmistakes:blockingaccesstomainproject">&nbsp;</a><a class="target" name="toc7.4.1">&nbsp;</a><h3>Catching Mistakes: Blocking Access to Main Project</h3>
<p>


In Android checks, it's very common to try to access the main (“app”)
project, to see what the real <code>minSdkVersion</code> is, since the app
<code>minSdkVersion</code> can be higher than the one in the library. For the
<code>targetSdkVersion</code> it's even more important, since the library
<code>targetSdkVersion</code> has no meaningful relationship to the app one.

</p><p>

When you run lint unit tests, as of 7.0, it will now run your tests
twice — once with global analysis (the previous behavior), and once
with partial analysis. When lint is running in partial analysis, a
number of calls, such as looking up the main project, or consulting the
merged manifest, is not allowed during the analysis phase. Attempting
to do so will generate an error:

</p><pre class="listing backtick"><code><span class="line">    SdCardTest.java: Error: The lint detector</span>
<span class="line">        com.android.tools.lint.checks.SdCardDetector</span>
<span class="line">    called context.getMainProject() during module analysis.</span>
<span class="line"></span>
<span class="line">    This does not work correctly when running in Lint Unit Tests.</span>
<span class="line"></span>
<span class="line">    In particular, there may be false positives or false negatives because</span>
<span class="line">    the lint check may be using the minSdkVersion or manifest information</span>
<span class="line">    from the library instead of any consuming app module.</span>
<span class="line"></span>
<span class="line">    Contact the vendor of the lint issue to get it fixed/updated (if</span>
<span class="line">    known, listed below), and in the meantime you can try to work around</span>
<span class="line">    this by disabling the following issues:</span>
<span class="line"></span>
<span class="line">    "SdCardPath"</span>
<span class="line"></span>
<span class="line">    Issue Vendor:</span>
<span class="line">    Vendor: Android Open Source Project</span>
<span class="line">    Contact: https://groups.google.com/g/lint-dev</span>
<span class="line">    Feedback: https://issuetracker.google.com/issues/new?component=192708</span>
<span class="line"></span>
<span class="line">    Call stack: Context.getMainProject(Context.kt:117)←SdCardDetector$createUastHandler$1.visitLiteralExpression(SdCardDetector.kt:66)</span>
<span class="line">        ←UElementVisitor$DispatchPsiVisitor.visitLiteralExpression(UElementVisitor.kt:791)</span>
<span class="line">        ←ULiteralExpression$DefaultImpls.accept(ULiteralExpression.kt:38)</span>
<span class="line">        ←JavaULiteralExpression.accept(JavaULiteralExpression.kt:24)←UVariableKt.visitContents(UVariable.kt:64)</span>
<span class="line">        ←UVariableKt.access$visitContents(UVariable.kt:1)←UField$DefaultImpls.accept(UVariable.kt:92)</span>
<span class="line">        ...</span></code></pre><p>

Specific examples of information many lint checks look at in this
category:

</p><p>

</p><ul>
<li class="asterisk"><code>minSdkVersion</code> and <code>targetSdkVersion</code>
</li>
<li class="asterisk">The merged manifest
</li>
<li class="asterisk">The resource repository
</li>
<li class="asterisk">Whether the main module is an Android project</li></ul>

<p></p>
<a class="target" name="catchingmistakes:simulatedappmodule">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?/catchingmistakes:simulatedappmodule">&nbsp;</a><a class="target" name="toc7.4.2">&nbsp;</a><h3>Catching Mistakes: Simulated App Module</h3>
<p>


Lint will also modify the unit test when running the test in partial
analysis mode. In particular, let's say your test has a manifest which
sets <code>minSdkVersion</code> to 21.

</p><p>

Lint will instead run the analysis task on a modified test project
where the <code>minSdkVersion</code> is set to 1, and then run the reporting task
where <code>minSdkVersion</code> is set back to 21. This ensures that lint checks
will correctly use the <code>minSdkVersion</code> from the main project, not the
library.

</p>
<a class="target" name="catchingmistakes:diffingresults">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?/catchingmistakes:diffingresults">&nbsp;</a><a class="target" name="toc7.4.3">&nbsp;</a><h3>Catching Mistakes: Diffing Results</h3>
<p>


Lint will also diff the report output from running the same unit tests
both in global analysis mode and in partial analysis mode. We expect
the results to always be identical, and in some cases if the module
analysis is not written correctly, they're not.

</p>
<a class="target" name="catchingmistakes:remainingissues">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?/catchingmistakes:remainingissues">&nbsp;</a><a class="target" name="toc7.4.4">&nbsp;</a><h3>Catching Mistakes: Remaining Issues</h3>
<p>


The above three mechanisms will catch most problems related to partial
analysis. However, there are a few remaining scenarios to be aware of:

</p><p>

</p><ul>
<li class="asterisk">Resolving into library source code. If you have a Kotlin or Java
  function call AST node (<code>UCallExpression</code>) you can call <code>resolve()</code>
  on it to find the called <code>PsiMethod</code>, and from there you can look at
  its source code, to make some decisions.

<p></p><p>

  For example, lint's API Check uses this to see if a given method is a
  version-check utility (“<code>SDK_INT &gt; 21</code>?”); it resolves the method
  call in <code>if (isOnLollipop()) { ... }</code> and looks at its method body to
  see if the return value corresponds to a proper <code>SDK_INT</code> check.

</p><p>

  In partial analysis mode, you cannot look at source files from
  libraries you depend on; they will only be provided in binary
  (bytecode inside a jar file) form.

</p><p>

  This means that instead, you need to aggregate data along the way.
  For example, the way lint handles the version check method lookup is
  to look for SDK_INT comparisons, and if found, stores a reference to
  the method in the partial results map which it can later consult
  from downstream modules.

</p><p>

</p></li>
<li class="asterisk">Multiple passes across the modules (lint has a way to request
  multiple passes; this was used by a few lint checks like the unused
  resource detector; the multiple passes now only apply to the local
  module)</li></ul>

<p></p><p>

In order to test for correct operation of your check, you should add
your own individual unit test for a multi-module project.

</p><p>

Lint's unit test infrastructure makes this easy; just use relative
paths in the test file descriptions.

</p><p>

For example, if you have the following unit test declaration:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line">   lint().files(</span>
<span class="line">       manifest().minSdk(<span class="hljs-number">15</span>),</span>
<span class="line">       manifest().to(<span class="hljs-string">"../app/AndroidManifest.xml"</span>).minSdk(<span class="hljs-number">21</span>),</span>
<span class="line">       xml(</span>
<span class="line">           <span class="hljs-string">"res/layout/linear.xml"</span>,</span>
<span class="line">           <span class="hljs-string">"&lt;linearlayout ...="</span><span class="hljs-string">"&gt;"</span> + ...</span></div></code></pre><p>

The second <code>manifest()</code> call here on line 3 does all the heavy lifting:
the fact that you're referencing <code>../app</code> means it will create another
module named “app”, and it will add a dependency from that module on
this one. It will also mark the current module as a library. This is
based on the name patterns; if you for example reference say <code>../lib1</code>,
it will assume the current module is an app module and the dependency
will go from here to the library.

</p><p>

Finally, to test a multi-module setup where the code in the other
module is only available as binary, lint has a new special test file
type. The <code>CompiledSourceFile</code> can be constructed via either
<code>compiled()</code>, if you want to make both the source code and the class
file available in the project, or <code>bytecode()</code> if you want to only
provide the bytecode. In both cases you include the source code in the
test file declaration, and the first time you run your test it will try
to run compilation and emit the extra base64 string to include the test
file. By having the sources included for the binary it's easy to
regenerate bytecode tests later (this was an issue with some of lint's
older unit tests; we recently decompiled them and created new test
files using this mechanism to make the code more maintainable.

</p><p>

Lint's partial analysis testing support will automatically only use
binaries for the dependencies (even if using <code>CompiledSourceFile</code> with
sources).

</p><p>

</p><div class="admonition note">Lint's testing infrastructure may try to automate this testing at
   some point; e.g. by looking at the error locations from a global
   analysis, it can then create a new project where only the source
   file with the warnings is provided as source, and all the other test
   files are placed in a separate module, and then represented only as
   binaries (through a lint AST to PsiCompiled pretty printer.)</div>

<p></p>
<a class="target" name="incidents">&nbsp;</a><a class="target" name="partialanalysis/incidents">&nbsp;</a><a class="target" name="toc7.5">&nbsp;</a><h2>Incidents</h2>
<p>


In the past, you would typically report problems like this:
</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line">    context.report(</span>
<span class="line">        ISSUE,</span>
<span class="line">        element,</span>
<span class="line">        context.getNameLocation(element),</span>
<span class="line">        <span class="hljs-string">"Missing `contentDescription` attribute on image"</span></span>
<span class="line">    )</span></div></code></pre><p>

At some point, we added support for quickfixes, so the
report method took an additional parameter, line 6:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line">    context.report(</span>
<span class="line">        ISSUE,</span>
<span class="line">        element,</span>
<span class="line">        context.getNameLocation(element),</span>
<span class="line">        <span class="hljs-string">"Missing `contentDescription` attribute on image"</span>,</span>
<span class="line">        fix().<span class="hljs-keyword">set</span>().todo(ANDROID_URI, ATTR_CONTENT_DESCRIPTION).build()</span>
<span class="line">)</span></div></code></pre><p>

Now that we need to attach various additional data (like constraints
and maps), we don't really want to just add more parameters.

</p><p>

Instead, this tuple of data about a particular occurrence of a problem
is called an “incident”, and there is a new <code>Incident</code> class which
represents it. To report an incident you simply call
<code>context.report(incident)</code>. There are several ways to create these
incidents. The easiest is to simply edit your existing call above by
adding <code>Incident(</code> (or from Java, <code>new Incident(</code>) inside the
<code>context.report</code> block like this:

</p><pre class="listing tilde"><code><span class="line">    context.report(Incident(</span>
<span class="line">        ISSUE,</span>
<span class="line">        element,</span>
<span class="line">        context.getNameLocation(element),</span>
<span class="line">        <span class="hljs-string">"Missing `contentDescription` attribute on image"</span></span>
<span class="line">    ))</span></code></pre><p>

and then reformatting the source code:

</p><pre class="listing tilde"><code><span class="line">    context.report(</span>
<span class="line">        Incident(</span>
<span class="line">            ISSUE,</span>
<span class="line">            element,</span>
<span class="line">            context.getNameLocation(element),</span>
<span class="line">            <span class="hljs-string">"Missing `contentDescription` attribute on image"</span></span>
<span class="line">        )</span>
<span class="line">)</span></code></pre><p>

<code>Incident</code> has a number of overloaded constructors to make it easy to
construct it from existing report calls.

</p><p>

There are other ways to construct it too, for example like the
following:

</p><pre class="listing tilde"><code><span class="line">    Incident(context)</span>
<span class="line">        .issue(ISSUE)</span>
<span class="line">        .scope(node)</span>
<span class="line">        .location(context.getLocation(node))</span>
<span class="line">        .message(<span class="hljs-string">"Do not hardcode \"/sdcard/\""</span>).report()</span></code></pre><p>

That are additional methods you can fall too, like <code>fix()</code>, and
conveniently, <code>at()</code> which specifies not only the scope node but
automatically computes and records the location of that scope node too,
such that the following is equivalent:

</p><pre class="listing tilde"><code><span class="line">    Incident(context)</span>
<span class="line">        .issue(ISSUE)</span>
<span class="line">        .at(node)</span>
<span class="line">        .message(<span class="hljs-string">"Do not hardcode \"/sdcard/\""</span>).report()</span></code></pre><p>

So step one to partial analysis is to convert your code to report
incidents instead of the passing in all the individual properties of an
incident. Note that for backwards compatibility, if your check doesn't
need any work for partial analysis, you can keep calling the older
report methods; they will be redirected to an <code>Incident</code> call
internally, but since you don't need to attach data you don't have to
make any changes

</p>
<a class="target" name="constraints">&nbsp;</a><a class="target" name="partialanalysis/constraints">&nbsp;</a><a class="target" name="toc7.6">&nbsp;</a><h2>Constraints</h2>
<p>


If your check needs to be conditional, perhaps on the <code>minSdkVersion</code>,
you need to attach a “constraint” to your report call.

</p><p>

All the constraints are built in; there isn't a way to implement your
own. For custom logic, see the next section: LintMaps.

</p><p>

Here are the current constraints, though this list may grow over time:

</p><p>

</p><ul>
<li class="asterisk">minSdkAtLeast(Int)
</li>
<li class="asterisk">minSdkLessThan(Int)
</li>
<li class="asterisk">targetSdkAtLeast(Int)
</li>
<li class="asterisk">targetSdkLessThan(Int)
</li>
<li class="asterisk">isLibraryProject()
</li>
<li class="asterisk">isAndroidProject()
</li>
<li class="asterisk">notLibraryProject()
</li>
<li class="asterisk">notAndroidProject()</li></ul>

<p></p><p>

These are package-level functions, though from Java you can access them
from the <code>Constraints</code> class.

</p><p>

Recording an incident with a constraint is easy; first construct the
<code>Incident</code> as before, and then report them via
<code>context.report(incident, constraint)</code>:

</p><pre class="listing tilde"><code><span class="line">    String message =</span>
<span class="line">        <span class="hljs-string">"One or more images in this project can be converted to "</span></span>
<span class="line">        + <span class="hljs-string">"the WebP format which typically results in smaller file sizes, "</span></span>
<span class="line">        + <span class="hljs-string">"even for lossless conversion"</span>;</span>
<span class="line">    Incident incident = <span class="hljs-keyword">new</span> Incident(WEBP_ELIGIBLE, location, message);</span>
<span class="line">    context.report(incident, minSdkAtLeast(<span class="hljs-number">18</span>));</span></code></pre><p>

Finally, note that you can combine constraints; there are both “and”
and “or” operators defined for the <code>Constraint</code> class. so the following
is valid:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">val</span> constraint = targetSdkAtLeast(<span class="hljs-number">23</span>) and notLibraryProject()</span>
<span class="line">    context.report(incident, constraint)</span></code></pre><p>

That's all you have to do. Lint will record this provisional incident,
and when it is performing reporting, it will evaluate these constraints
on its own and only report incidents that meet the constraint.

</p>
<a class="target" name="incidentlintmaps">&nbsp;</a><a class="target" name="partialanalysis/incidentlintmaps">&nbsp;</a><a class="target" name="toc7.7">&nbsp;</a><h2>Incident LintMaps</h2>
<p>


In some cases, you cannot use one of the built-in constraints; you have
to do your own “filtering” from the reporting task, where you have
access to the main module.

</p><p>

In that case, you call <code>context.report(incident, map)</code> instead.

</p><p>

Like <code>Incident</code>, <code>LintMap</code> is a new data holder class in lint which
makes it convenient to pass around (and more importantly, persist)
data. All the set methods return the map itself, so you can easily
chain property calls.

</p><p>

Here's an example:

</p><pre class="listing tilde"><code><span class="line">    context.report(</span>
<span class="line">        incident,</span>
<span class="line">        map()</span>
<span class="line">            .put(KEY_OVERRIDES, overrides)</span>
<span class="line">            .put(KEY_IMPLICIT, implicitlyExportedPreS)</span>
<span class="line">    )</span></code></pre><p>

Here, <code>map()</code> is a method defined by <code>Detector</code> to create a new
<code>LintMap</code>, similar to how <code>fix()</code> constructs a new <code>LintFix</code>.

</p><p>

Note however that when reporting data, you need to do the post
processing yourself. To do this, you need to override this method:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-comment">/**</span>
<span class="line">     * Filter which looks at incidents previously reported via</span>
<span class="line">     * [Context.report] with a [LintMap], and returns false if the issue</span>
<span class="line">     * does not apply in the current reporting project context, or true</span>
<span class="line">     * if the issue should be reported. For issues that are accepted,</span>
<span class="line">     * the detector is also allowed to mutate the issue, such as</span>
<span class="line">     * customizing the error message further.</span>
<span class="line">     */</span></span>
<span class="line">    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filterIncident</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, incident: <span class="hljs-type">Incident</span>, map: <span class="hljs-type">LintMap</span>)</span></span>: <span class="hljs-built_in">Boolean</span> { }</span></code></pre><p>

For example, for the above report call, the corresponding
implementation of <code>filterIncident</code> looks like this:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filterIncident</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, incident: <span class="hljs-type">Incident</span>, map: <span class="hljs-type">LintMap</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {</span>
<span class="line">        <span class="hljs-keyword">if</span> (context.mainProject.targetSdk &lt; <span class="hljs-number">19</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span>
<span class="line">        <span class="hljs-keyword">if</span> (map.getBoolean(KEY_IMPLICIT, <span class="hljs-literal">false</span>) == <span class="hljs-literal">true</span> &amp;&amp; context.mainProject.targetSdk &gt;= <span class="hljs-number">31</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span>
<span class="line">        <span class="hljs-keyword">return</span> map.getBoolean(KEY_OVERRIDES, <span class="hljs-literal">false</span>) == <span class="hljs-literal">false</span></span>
<span class="line">    }</span></code></pre><p>

Note also that you are allowed to modify incidents here before
reporting them. The most common reason scenario for this is changing
the incident message, perhaps to reflect data not known at module
analysis time. For example, lint's API check creates messages like this:

</p><p>

<em class="asterisk">Error: Cast from AudioFormat to Parcelable requires API level 24 (current min is 21)</em>

</p><p>

At module analysis time when the incident was created, the minSdk being
21 was not known (and in fact can vary if this library is consumed by
many different app modules!)

</p><p>

</p><div class="admonition warning">You must store state in the lint map; don't try to store it in the
   detector itself as instance state. That won't work because the
   detector instance that <code>filterInstance</code> is called on is not the same
   instance as the one which originally reported it. If you think about
   it, that makes sense; when module results are cached, the same
   reported data can be used over and over again for repeated builds,
   each time for new detector instances in the reporting task.</div>

<p></p>
<a class="target" name="modulelintmaps">&nbsp;</a><a class="target" name="partialanalysis/modulelintmaps">&nbsp;</a><a class="target" name="toc7.8">&nbsp;</a><h2>Module LintMaps</h2>
<p>


The last (and most involved) scenario for partial analysis is one where
you cannot just create incidents and filter or customize them later.

</p><p>

The most complicated example of this is lint's built-in
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-master-dev:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/UnusedResourceDetector.java">UnusedResourceDetector</a>, which locates unused resources. This “requires”
global analysis, since we want to include all resources in the entire
project. We also cannot just store lists of “resources declared” and
“resources referenced“ since we really want to treat this as a graph.
For example if <code>@layout/main</code> is including <code>@drawable/icon</code>, then a
naive approach would see the icon as referenced (by main) and therefore
mark it as not unused. But what we want is that if the icon is <strong class="asterisk">only</strong>
referenced from main, and if main is unused, then so is the icon.

</p><p>

To handle this, we model the resources as a graph, with edges
representing references.

</p><p>

When analyzing individual modules, we create the resource graph for
just that model, and we store that in the results. That means we store
it in the module's <code>LintMap</code>. This is a map for the whole module
maintained by lint, so you can access it repeatedly and add to it.
(This is also where lint's API check stores the <code>SDK_INT</code> comparison
functions as described earlier in this chapter).

</p><p>

The unused resource detector creates a persistence string for the
graph, and records that in the map.

</p><p>

Then, during reporting, it is given access to <em class="asterisk">all</em> the lint maps for
all the modules that the reporting module depends on, including itself.
It then merges all the graphs into a single reference graph.

</p><p>

For example, let's say in module 1 we have layout A which includes
drawables B and D, and B in turn depends on color C. We get a resource
graph like the following:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="176" width="360" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 40,48 L 40,112 " style="fill:none;"></path>
<path d="M 56,32 L 104,32 " style="fill:none;"></path>
<path d="M 144,32 L 192,32 " style="fill:none;"></path>
<path d="M 40,112 L 72,112 " style="fill:none;"></path>
<path d="M 40,16 C 23.2,16 24,32 24,32 " style="fill:none;"></path>
<path d="M 40,16 C 56.8,16 56,32 56,32 " style="fill:none;"></path>
<path d="M 128,16 C 111.2,16 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,16 C 144.8,16 144,32 144,32 " style="fill:none;"></path>
<path d="M 216,16 C 199.2,16 200,32 200,32 " style="fill:none;"></path>
<path d="M 216,16 C 232.8,16 232,32 232,32 " style="fill:none;"></path>
<path d="M 40,48 C 23.2,48 24,32 24,32 " style="fill:none;"></path>
<path d="M 40,48 C 56.8,48 56,32 56,32 " style="fill:none;"></path>
<path d="M 128,48 C 111.2,48 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,48 C 144.8,48 144,32 144,32 " style="fill:none;"></path>
<path d="M 216,48 C 199.2,48 200,32 200,32 " style="fill:none;"></path>
<path d="M 216,48 C 232.8,48 232,32 232,32 " style="fill:none;"></path>
<path d="M 96,96 C 79.2,96 80,112 80,112 " style="fill:none;"></path>
<path d="M 96,96 C 112.8,96 112,112 112,112 " style="fill:none;"></path>
<path d="M 96,128 C 79.2,128 80,112 80,112 " style="fill:none;"></path>
<path d="M 96,128 C 112.8,128 112,112 112,112 " style="fill:none;"></path>
<polygon points="200,32 188,26.4 188,37.6 " style="stroke:none" transform="rotate(0,192,32 )"></polygon>
<polygon points="112,32 100,26.4 100,37.6 " style="stroke:none" transform="rotate(0,104,32 )"></polygon>
<polygon points="80,112 68,106.4 68,117.6 " style="stroke:none" transform="rotate(0,72,112 )"></polygon>
<g transform="translate(0,0)"><text text-anchor="middle" x="40" y="36">A</text><text text-anchor="middle" x="128" y="36">B</text><text text-anchor="middle" x="216" y="36">C</text><text text-anchor="middle" x="96" y="116">D</text></g></g></svg>

</p><p>

Then in another module, we have the following resource reference graph:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="96" width="360" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 56,32 L 104,32 " style="fill:none;"></path>
<path d="M 144,32 L 192,32 " style="fill:none;"></path>
<path d="M 40,16 C 23.2,16 24,32 24,32 " style="fill:none;"></path>
<path d="M 40,16 C 56.8,16 56,32 56,32 " style="fill:none;"></path>
<path d="M 128,16 C 111.2,16 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,16 C 144.8,16 144,32 144,32 " style="fill:none;"></path>
<path d="M 216,16 C 199.2,16 200,32 200,32 " style="fill:none;"></path>
<path d="M 216,16 C 232.8,16 232,32 232,32 " style="fill:none;"></path>
<path d="M 40,48 C 23.2,48 24,32 24,32 " style="fill:none;"></path>
<path d="M 40,48 C 56.8,48 56,32 56,32 " style="fill:none;"></path>
<path d="M 128,48 C 111.2,48 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,48 C 144.8,48 144,32 144,32 " style="fill:none;"></path>
<path d="M 216,48 C 199.2,48 200,32 200,32 " style="fill:none;"></path>
<path d="M 216,48 C 232.8,48 232,32 232,32 " style="fill:none;"></path>
<polygon points="200,32 188,26.4 188,37.6 " style="stroke:none" transform="rotate(0,192,32 )"></polygon>
<polygon points="112,32 100,26.4 100,37.6 " style="stroke:none" transform="rotate(0,104,32 )"></polygon>
<g transform="translate(0,0)"><text text-anchor="middle" x="40" y="36">E</text><text text-anchor="middle" x="128" y="36">B</text><text text-anchor="middle" x="216" y="36">D</text></g></g></svg>

</p><p>

In the reporting task, we merge the two graphs like the following:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="256" width="360" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 40,128 L 40,192 " style="fill:none;"></path>
<path d="M 128,48 L 128,88 " style="fill:none;"></path>
<path d="M 128,128 L 128,168 " style="fill:none;"></path>
<path d="M 56,112 L 104,112 " style="fill:none;"></path>
<path d="M 144,112 L 192,112 " style="fill:none;"></path>
<path d="M 40,192 L 104,192 " style="fill:none;"></path>
<path d="M 128,16 C 111.2,16 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,16 C 144.8,16 144,32 144,32 " style="fill:none;"></path>
<path d="M 128,48 C 111.2,48 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,48 C 144.8,48 144,32 144,32 " style="fill:none;"></path>
<path d="M 40,96 C 23.2,96 24,112 24,112 " style="fill:none;"></path>
<path d="M 40,96 C 56.8,96 56,112 56,112 " style="fill:none;"></path>
<path d="M 128,96 C 111.2,96 112,112 112,112 " style="fill:none;"></path>
<path d="M 128,96 C 144.8,96 144,112 144,112 " style="fill:none;"></path>
<path d="M 216,96 C 199.2,96 200,112 200,112 " style="fill:none;"></path>
<path d="M 216,96 C 232.8,96 232,112 232,112 " style="fill:none;"></path>
<path d="M 40,128 C 23.2,128 24,112 24,112 " style="fill:none;"></path>
<path d="M 40,128 C 56.8,128 56,112 56,112 " style="fill:none;"></path>
<path d="M 128,128 C 111.2,128 112,112 112,112 " style="fill:none;"></path>
<path d="M 128,128 C 144.8,128 144,112 144,112 " style="fill:none;"></path>
<path d="M 216,128 C 199.2,128 200,112 200,112 " style="fill:none;"></path>
<path d="M 216,128 C 232.8,128 232,112 232,112 " style="fill:none;"></path>
<path d="M 128,176 C 111.2,176 112,192 112,192 " style="fill:none;"></path>
<path d="M 128,176 C 144.8,176 144,192 144,192 " style="fill:none;"></path>
<path d="M 128,208 C 111.2,208 112,192 112,192 " style="fill:none;"></path>
<path d="M 128,208 C 144.8,208 144,192 144,192 " style="fill:none;"></path>
<polygon points="200,112 188,106.4 188,117.6 " style="stroke:none" transform="rotate(0,192,112 )"></polygon>
<polygon points="136,168 124,162.4 124,173.6 " style="stroke:none" transform="rotate(90,128,168 )"></polygon>
<polygon points="136,88 124,82.4 124,93.6 " style="stroke:none" transform="rotate(90,128,88 )"></polygon>
<polygon points="112,192 100,186.4 100,197.6 " style="stroke:none" transform="rotate(0,104,192 )"></polygon>
<polygon points="112,112 100,106.4 100,117.6 " style="stroke:none" transform="rotate(0,104,112 )"></polygon>
<g transform="translate(0,0)"><text text-anchor="middle" x="128" y="36">E</text><text text-anchor="middle" x="40" y="116">A</text><text text-anchor="middle" x="128" y="116">B</text><text text-anchor="middle" x="216" y="116">C</text><text text-anchor="middle" x="128" y="196">D</text></g></g></svg>

</p><p>

Once that's done, it can proceed precisely as before: analyze the graph
and report all the resources that are not reachable from the reference
roots (e.g. manifest and used code).

</p><p>

The way this works in code is that you report data into the module by
first looking up the module data map, by calling this method on the
<code>Context</code>:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-comment">/**</span>
<span class="line">     * Returns a [PartialResult] where state can be stored for later</span>
<span class="line">     * analysis. This is a more general mechanism for reporting</span>
<span class="line">     * provisional issues when you need to collect a lot of data and do</span>
<span class="line">     * some post processing before figuring out what to report and you</span>
<span class="line">     * can't enumerate out specific [Incident] occurrences up front.</span>
<span class="line">     *</span>
<span class="line">     * Note that in this case, the lint infrastructure will not</span>
<span class="line">     * automatically look up the error location (since there isn't one</span>
<span class="line">     * yet) to see if the issue has been suppressed (via annotations,</span>
<span class="line">     * lint.xml and other mechanisms), so you should do this</span>
<span class="line">     * yourself, via the various [LintDriver.isSuppressed] methods.</span>
<span class="line">     */</span></span>
<span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPartialResults</span><span class="hljs-params">(issue: <span class="hljs-type">Issue</span>)</span></span>: PartialResult { ... }</span></code></pre><p>

Then you put whatever data you want, such as the resource usage model
encoded as a string.

</p><p>

</p><div class="admonition ">Note that you don't have to worry about clashes in key names; each
   issue (and therefore detector) is given its own map.</div>

<p></p><p>

And then your detector should also override the following method, where
you can walk through the map contents, compute incidents and report
them:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-comment">/**</span>
<span class="line">     * Callback to detectors that add partial results (by adding entries</span>
<span class="line">     * to the map returned by [LintClient.getPartialResults]). This is</span>
<span class="line">     * where the data should be analyzed and merged and results reported</span>
<span class="line">     * (via [Context.report]) to lint.</span>
<span class="line">     */</span></span>
<span class="line">    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkPartialResults</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, partialResults: <span class="hljs-type">PartialResult</span>)</span></span> { ... }</span></code></pre>
<a class="target" name="optimizations">&nbsp;</a><a class="target" name="partialanalysis/optimizations">&nbsp;</a><a class="target" name="toc7.9">&nbsp;</a><h2>Optimizations</h2>
<p>


Most lint checks run on the fly in the IDE editor as well. In some
cases, if all the map computations are expensive, you can check whether
partial analysis is in effect, and if not, just directly access (for
example) the main project.

</p><p>

Do this by calling <code>isGlobalAnalysis()</code>:

</p><pre class="listing tilde"><code><span class="line">   <span class="hljs-keyword">if</span> (context.isGlobalAnalysis()) {</span>
<span class="line">       <span class="hljs-comment">// shortcut</span></span>
<span class="line">   } <span class="hljs-keyword">else</span> {</span>
<span class="line">       <span class="hljs-comment">// partial analysis code path</span></span>
<span class="line">   }</span></code></pre><p>



</p>
<a class="target" name="frequentlyaskedquestions">&nbsp;</a><a class="target" name="frequentlyaskedquestions">&nbsp;</a><a class="target" name="toc8">&nbsp;</a><h1>Frequently Asked Questions</h1>
<p>


This chapter contains a random collection of questions people
have asked in the past.

</p>
<a class="target" name="mydetectorcallbacksaren'tinvoked">&nbsp;</a><a class="target" name="frequentlyaskedquestions//mydetectorcallbacksaren'tinvoked">&nbsp;</a><a class="target" name="toc8.0.1">&nbsp;</a><h3>My detector callbacks aren't invoked</h3>
<p>


If you've for example implemented the Detector callback for visiting
method calls, <code>visitMethodCall</code>, notice how the third parameter is a
<code>PsiMethod</code>, and that it is not nullable:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitMethodCall</span><span class="hljs-params">(</span>
<span class="line">        context: <span class="hljs-type">JavaContext</span>,</span>
<span class="line">        node: <span class="hljs-type">UCallExpression</span>,</span>
<span class="line">        method: <span class="hljs-type">PsiMethod</span></span>
<span class="line">    )</span></span> {</span></code></pre><p>

This passes in the method that has been called. When lint is visiting
the AST, it will resolve calls, and if the called method cannot be
resolved, the callback won't be called.

</p><p>

This happens when the classpath that lint has been configured with does
not contain everything needed. When lint is running from Gradle, this
shouldn't happen; the build system should have a complete classpath and
pass it to Lint (or the build wouldn't have succeeded in the first
place).

</p><p>

This usually comes up in unit tests for lint, where you've added a test
case which is referencing some API for some library, but the library
itself isn't part of the test. The solution for this is to create stubs
for the part of the API you care about. This is discussed in more
detail in the <a href="#lintcheckunittesting">unit testing</a> chapter.

</p>
<a class="target" name="mylintcheckworksfromtheunittestbutnotintheide">&nbsp;</a><a class="target" name="frequentlyaskedquestions//mylintcheckworksfromtheunittestbutnotintheide">&nbsp;</a><a class="target" name="toc8.0.2">&nbsp;</a><h3>My lint check works from the unit test but not in the IDE</h3>
<p>


There are several things to check if you have a lint check which
works correctly from your unit test but not in the IDE.

</p><p>

</p><ol start="1">
<li class="number">First check that the lint jar is packaged correctly; use <code>jar tvf
   lint.jar</code> to look at the jar file to make sure it contains the
   service loader registration of your issue registry, and <code>javap
   -classpath lint.jar com.example.YourIssueRegistry</code> to inspect your
   issue registry.

<p></p><p>

</p></li>
<li class="number">If that's correct, the next thing to check is that lint is actually
   loading your issue registry. First look in the IDE log (from the
   Help menu) to make sure there aren't log messages from lint
   explaining why it can't load the registry, for example because it
   does not specify a valid applicable API range.

<p></p><p>

</p></li>
<li class="number">If there's no relevant warning in the log, try setting the
   <code>$ANDROID_LINT_JARS</code> environment variable to point directly to your
   lint jar file and restart Studio to make sure that that works.

<p></p><p>

</p></li>
<li class="number">Next, try running <strong class="asterisk">Analyze | Inspect Code...</strong>. This runs lint on
   the whole project. If that works, then the issue is that your lint
   check isn't eligible to run “on the fly”; the reason for this is
   that your implementation scope registers more than one scope, which
   says that your lint check can only run if lint gets to look at both
   types of files, and in the editor, only the current file is analyzed
   by lint. However, you can still make the check work on the fly by
   specifying additional analysis scopes; see the API guide for more
   information about this.</li></ol>

<p></p>
<a class="target" name="visitannotationusageisn'tcalledforannotations">&nbsp;</a><a class="target" name="frequentlyaskedquestions//visitannotationusageisn'tcalledforannotations">&nbsp;</a><a class="target" name="toc8.0.3">&nbsp;</a><h3><code>visitAnnotationUsage</code> isn't called for annotations</h3>
<p>


If you want to just visit any annotation declarations (e.g. <code>@Foo</code> on
method <code>foo</code>), don't use the <code>applicableAnnotations</code> and
<code>visitAnnotationUsage</code> machinery. The purpose of that facility is to
look at <em class="asterisk">elements</em> that are being combined with annotated elements,
such as a method call to a method whose return value has been
annotated, or an argument to a method a method parameter that has been
annotated, or assigning an assigned value to an annotated variable, etc.

</p><p>

If you just want to look at annotations, use <code>getApplicableUastTypes</code>
with <code>UAnnotation::class.java</code>, and a <code>UElementHandler</code> which overrides
<code>visitAnnotation</code>.

</p>
<a class="target" name="howdoicheckifauastorpsielementisforjavaorkotlin?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoicheckifauastorpsielementisforjavaorkotlin?">&nbsp;</a><a class="target" name="toc8.0.4">&nbsp;</a><h3>How do I check if a UAST or PSI element is for Java or Kotlin?</h3>
<p>


To check whether an element is in Java or Kotlin, call one
of the package level methods in the detector API (and from
Java, you can access them as utility methods on the “Lint”
class) :

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">package</span> com.android.tools.lint.detector.api</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">/** Returns true if the given element is written in Java. */</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isJava</span><span class="hljs-params">(element: <span class="hljs-type">PsiElement</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span> }</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">/** Returns true if the given language is Kotlin. */</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isKotlin</span><span class="hljs-params">(language: <span class="hljs-type">Language</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span> }</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">/** Returns true if the given language is Java. */</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isJava</span><span class="hljs-params">(language: <span class="hljs-type">Language</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span> }</span></code></pre><p>

If you have a <code>UElement</code> and need a <code>PsiElement</code> for the above method,
see the next question.

</p>
<a class="target" name="whatifineedapsielementandihaveauelement?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//whatifineedapsielementandihaveauelement?">&nbsp;</a><a class="target" name="toc8.0.5">&nbsp;</a><h3>What if I need a <code>PsiElement</code> and I have a <code>UElement</code> ?</h3>
<p>


If you have a <code>UElement</code>, you can get the underlying source PSI element
by calling <code>element.sourcePsi</code>.

</p>
<a class="target" name="howdoigettheumethodforapsimethod?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoigettheumethodforapsimethod?">&nbsp;</a><a class="target" name="toc8.0.6">&nbsp;</a><h3>How do I get the <code>UMethod</code> for a <code>PsiMethod</code> ?</h3>
<p>


Call <code>psiMethod.toUElementOfType&lt;umethod&gt;()</code>. Note that this may return
null if UAST cannot find valid Java or Kotlin source code for the
method.

</p><p>

For <code>PsiField</code> and <code>PsiClass</code> instances use the equivalent
<code>toUElementOfType</code> type arguments.

</p>
<a class="target" name="howdogetajavaevaluator?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdogetajavaevaluator?">&nbsp;</a><a class="target" name="toc8.0.7">&nbsp;</a><h3>How do get a <code>JavaEvaluator</code> ?</h3>
<p>


The <code>Context</code> passed into most of the <code>Detector</code> callback methods
relevant to Kotlin and Java analysis is of type <code>JavaContext</code>, and it
has a public <code>evaluator</code> property which provides a <code>JavaEvaluator</code> you
can use in your analysis.

</p><p>

If you need one outside of that scenario (this is not common) you can
construct one directly by instantiating a <code>DefaultJavaEvaluator</code>; the
constructor parameters are nullable, and are only needed for a couple
of operations on the evaluator.

</p>
<a class="target" name="howdoicheckwhetheranelementisinternal?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoicheckwhetheranelementisinternal?">&nbsp;</a><a class="target" name="toc8.0.8">&nbsp;</a><h3>How do I check whether an element is internal?</h3>
<p>


First get a <code>JavaEvaluator</code> as explained above, then call
this evaluator method:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInternal</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></span></code></pre><p>

(Note that a <code>PsiModifierListOwner</code> is an interface which includes
<code>PsiMethod</code>, <code>PsiClass</code>, <code>PsiField</code>, <code>PsiMember</code>, <code>PsiVariable</code>, etc.)

</p>
<a class="target" name="iselementinline,sealed,operator,infix,suspend,data?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//iselementinline,sealed,operator,infix,suspend,data?">&nbsp;</a><a class="target" name="toc8.0.9">&nbsp;</a><h3>Is element inline, sealed, operator, infix, suspend, data?</h3>
<p>


Get the <code>JavaEvaluator</code> as explained above, and then call one of these
evaluator method:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isData</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></span>
<span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInline</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></span>
<span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isLateInit</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></span>
<span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isSealed</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></span>
<span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></span>
<span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInfix</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></span>
<span class="line"><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isSuspend</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></span></code></pre>
<a class="target" name="howdoilookupaclassifihaveitsfullyqualifiedname?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoilookupaclassifihaveitsfullyqualifiedname?">&nbsp;</a><a class="target" name="toc8.0.10">&nbsp;</a><h3>How do I look up a class if I have its fully qualified name?</h3>
<p>


Get the <code>JavaEvaluator</code> as explained above, then call
<code>evaluator.findClass(qualifiedName: String)</code>. Note that the result is
nullable.

</p>
<a class="target" name="howdoilookupaclassifihaveapsitype?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoilookupaclassifihaveapsitype?">&nbsp;</a><a class="target" name="toc8.0.11">&nbsp;</a><h3>How do I look up a class if I have a PsiType?</h3>
<p>


Get the <code>JavaEvaluator</code> as explained above, then call
<code>evaluator.getTypeClass</code>. To go from a class to its type,
use <code>getClassType</code>.

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getClassType</span><span class="hljs-params">(psiClass: <span class="hljs-type">PsiClass</span>?)</span></span>: PsiClassType?</span>
<span class="line">    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTypeClass</span><span class="hljs-params">(psiType: <span class="hljs-type">PsiType</span>?)</span></span>: PsiClass?</span></code></pre>
<a class="target" name="howdoilookuphierarhcyannotationsforanelement?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoilookuphierarhcyannotationsforanelement?">&nbsp;</a><a class="target" name="toc8.0.12">&nbsp;</a><h3>How do I look up hierarhcy annotations for an element?</h3>
<p>


You can directly look up annotations via the modified list
of PsiElement or the annotations for a <code>UAnnotated</code> element,
but if you want to search the inheritance hierarchy for
annotations (e.g. if a method is overriding another, get
any annotations specified on super implementations), use
one of these two evaluator methods:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAllAnnotations</span><span class="hljs-params">(</span>
<span class="line">        owner: <span class="hljs-type">UAnnotated</span>,</span>
<span class="line">        inHierarchy: <span class="hljs-type">Boolean</span></span>
<span class="line">    )</span></span>: List&lt;uannotation&gt;</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAllAnnotations</span><span class="hljs-params">(</span>
<span class="line">        owner: <span class="hljs-type">PsiModifierListOwner</span>,</span>
<span class="line">        inHierarchy: <span class="hljs-type">Boolean</span></span>
<span class="line">    )</span></span>: Array&lt;psiannotation&gt;</span></code></pre>
<a class="target" name="howdoilookupifaclassisasubclassofanother?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoilookupifaclassisasubclassofanother?">&nbsp;</a><a class="target" name="toc8.0.13">&nbsp;</a><h3>How do I look up if a class is a subclass of another?</h3>
<p>


To see if a method is a direct member of a particular
named class, use the following method in <code>JavaEvaluator</code>:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isMemberInClass</span><span class="hljs-params">(member: <span class="hljs-type">PsiMember</span>?, className: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> { }</span></code></pre><p>

To see if a method is a member in any <em class="asterisk">subclass</em> of a named class, use

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isMemberInSubClassOf</span><span class="hljs-params">(</span>
<span class="line">        member: <span class="hljs-type">PsiMember</span>,</span>
<span class="line">        className: <span class="hljs-type">String</span>,</span>
<span class="line">        strict: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span></span>
<span class="line">    )</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span> }</span>
<span class="line"></span></code></pre><p>

Here, use <code>strict = true</code> if you don't want to include members in the
named class itself as a match.

</p><p>

To see if a class extends another or implements an interface, use one
of these methods. Again, <code>strict</code> controls whether we include the super
class or super interface itself as a match.

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">extendsClass</span><span class="hljs-params">(</span>
<span class="line">        cls: <span class="hljs-type">PsiClass</span>?,</span>
<span class="line">        className: <span class="hljs-type">String</span>,</span>
<span class="line">        strict: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span></span>
<span class="line">    )</span></span>: <span class="hljs-built_in">Boolean</span></span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">implementsInterface</span><span class="hljs-params">(</span>
<span class="line">        cls: <span class="hljs-type">PsiClass</span>,</span>
<span class="line">        interfaceName: <span class="hljs-type">String</span>,</span>
<span class="line">        strict: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span></span>
<span class="line">    )</span></span>: <span class="hljs-built_in">Boolean</span></span></code></pre>
<a class="target" name="howdoiknowwhichparameteracallargumentcorrespondsto?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoiknowwhichparameteracallargumentcorrespondsto?">&nbsp;</a><a class="target" name="toc8.0.14">&nbsp;</a><h3>How do I know which parameter a call argument corresponds to?</h3>
<p>


In Java, matching up the arguments in a call with the parameters in the
called method is easy: the first argument corresponds to the first
parameter, the second argument corresponds to the second parameter and
so on. If there are more arguments than parameters, the last arguments
are all vararg arguments to the last parameter.

</p><p>

In Kotlin, it's much more complicated. With named parameters, but
arguments can appear in any order, and with default parameters, only
some of them may be specified. And if it's an extension method, the
first argument passed to a <code>PsiMethod</code> is actually the instance itself.

</p><p>

Lint has a utility method to help with this on the <code>JavaEvaluator</code>:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">computeArgumentMapping</span><span class="hljs-params">(</span>
<span class="line">        call: <span class="hljs-type">UCallExpression</span>,</span>
<span class="line">        method: <span class="hljs-type">PsiMethod</span></span>
<span class="line">    )</span></span>: Map&lt;uexpression, psiparameter=<span class="hljs-string">""</span>&gt; { <span class="hljs-comment">/* ... */</span></span></code></pre><p>

This returns a map from UAST expressions (each argument to a UAST call
is a <code>UExpression</code>, and these are the <code>valueArguments</code> property on the
<code>UCallExpression</code>) to each corresponding <code>PsiParameter</code> on the
<code>PsiMethod</code> that the method calls.

</p>
<a class="target" name="howcanmylintcheckstargettwodifferentversionsoflint?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howcanmylintcheckstargettwodifferentversionsoflint?">&nbsp;</a><a class="target" name="toc8.0.15">&nbsp;</a><h3>How can my lint checks target two different versions of lint?</h3>
<p>


If you need to ship different versions of your lint checks to target
different versions of lint (because perhaps you need to work both with
an older version of lint, and a newer version that has a different
API), the way to do this (as of Lint 7.0) is to use the <code>maxApi</code>
property on the <code>IssueRegistry</code>. In the service loader registration
(<code>META-INF/services</code>), register <em class="asterisk">two</em> issue registries; one for each
implementation, and mark the older one with the right <code>minApi</code> to
<code>maxApi</code> range, and the newer one with <code>minApi</code> following the previous
registry's <code>maxApi</code>. (Both <code>minApi</code> and <code>maxApi</code> are inclusive). When
lint loads the issue registries it will ignore registries with a range
outside of the current API level.

</p>
<a class="target" name="canimakemylintcheck%E2%80%9Cnotsuppressible?%E2%80%9D">&nbsp;</a><a class="target" name="frequentlyaskedquestions//canimakemylintcheck%E2%80%9Cnotsuppressible?%E2%80%9D">&nbsp;</a><a class="target" name="toc8.0.16">&nbsp;</a><h3>Can I make my lint check “not suppressible?”</h3>
<p>


In some (hopefully rare) cases, you may want your lint checks to not be
suppressible using the normal mechanisms — suppress annotations,
comments, lint.xml files, baselines, and so on. The usecase for this is
typically strict company guidelines around compliance or security and
you want to remove the easy possibility of just silencing the check.

</p><p>

This is possible as part of the issue registration. After creating your
<code>Issue</code>, set the <code>suppressNames</code> property to an <strong class="asterisk">empty</strong> collection.

</p>
<a class="target" name="howdoicheckoutthecurrentlintsourcecode?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoicheckoutthecurrentlintsourcecode?">&nbsp;</a><a class="target" name="toc8.0.17">&nbsp;</a><h3>How do I check out the current lint source code?</h3>
<pre class="listing backtick"><code><span class="line"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> --branch=mirror-goog-studio-master-dev --single-branch \</span>
<span class="line">   https://android.googlesource.com/platform/tools/base</span></span>
<span class="line">Cloning into 'base'...</span>
<span class="line">remote: Total 648820 (delta 325442), reused 635137 (delta 325442)</span>
<span class="line">Receiving objects: 100% (648820/648820), 1.26 GiB | 15.52 MiB/s, done.</span>
<span class="line">Resolving deltas: 100% (325442/325442), done.</span>
<span class="line">Updating files: 100% (14416/14416), done.</span>
<span class="line"><span class="hljs-meta"></span>
<span class="line">$</span><span class="bash"> du -sh base</span></span>
<span class="line">1.8G    base</span>
<span class="line"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> base/lint</span></span>
<span class="line"><span class="hljs-meta">$</span><span class="bash"> ls</span></span>
<span class="line">.editorconfig           BUILD                   build.gradle            libs/</span>
<span class="line">.gitignore              MODULE_LICENSE_APACHE2  cli/</span>
<span class="line"><span class="hljs-meta">$</span><span class="bash"> ls libs/</span></span>
<span class="line">intellij-core/   kotlin-compiler/ lint-api/        lint-checks/     lint-gradle/     lint-model/      lint-tests/      uast/</span></code></pre>
<a class="target" name="wheredoifindexamplesoflintchecks?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//wheredoifindexamplesoflintchecks?">&nbsp;</a><a class="target" name="toc8.0.18">&nbsp;</a><h3>Where do I find examples of lint checks?</h3>
<p>


The built-in lint checks are a good source. Check out the source code
as shown above and look in
<code>lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/</code> or
browse sources online:
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-master-dev:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/"></a><a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-master-dev:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/" class="url">https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-master-dev:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/</a>

</p><p>



</p>
<a class="target" name="appendix:recentchanges">&nbsp;</a><a class="target" name="appendix:recentchanges">&nbsp;</a><a class="target" name="toc9">&nbsp;</a><h1>Appendix: Recent Changes</h1>
<p>

           
<strong class="asterisk">Recent Changes</strong>

</p><p>

This chapter lists recent changes to lint that affect lint check
authors: new features, API and behavior changes, and so on. For
information about user visible changes to lint, see the User
Guide.

</p><p>

<strong class="asterisk">7.0</strong>

</p><p>

</p><ul>
<li class="asterisk">The API level has bumped to 10.

<p></p><p>

</p></li>
<li class="asterisk">Partial analysis. Lint's architecture has changed to support better
  scalability across large projects, where module results can be
  cached, etc. See the api-guide's dedicated chapter for more details.
  It is enabled by default starting in AGP 7.0.0-alpha13, but you can
  disable it by adding

<p></p><p>

      <code>android.enableParallelLint=false</code>

</p><p>

  to your <code>gradle.properties</code> file. If you want to debug your lint check
  you may want to also set

</p><p>

      <code>android.experimental.runLintInProcess=true</code>

</p><p>

</p></li>
<li class="asterisk">Issue registration now takes an optional <code>Vendor</code> property, where you
  can specify information about which company or team provided this
  lint check, which library it's associated with, contact information,
  and so on. This will make it easier for users to figure out where to
  send feedback or requests for 3rd party lint checks.

<p></p><p>

</p></li>
<li class="asterisk">Bytecode verification: Instead of warning about 3rd party lint checks
  being obsolete because they were not compiled against the latest Lint
  API, lint now run its own bytecode verification against the lint jar
  and will silently accept older (and newer!) lint checks if they do
  not reference APIs that are not available.

<p></p><p>

</p></li>
<li class="asterisk">Android Lint checks can now always access the resource repository for
  random access to resources, instead of having to gather them in batch
  mode. (Previously this was only available when lint checks were
  running in the IDE.)

<p></p><p>

</p></li>
<li class="asterisk">The lint unit testing library now provides a <code>TestMode</code> concept. You
  can define setup and teardown methods, and lint will run unit tests
  repeatedly for each test mode. There are a number of built-in test
  modes already enabled; for example, all lint tests will run both in
  global analysis mode and in partial analysis mode, and the results
  compared to ensure they are the same.

<p></p><p>

</p></li>
<li class="asterisk">Lint unit tests now include source contents for secondary locations
  too. If the test fails, lint will retry without secondary source
  locations and not report an error; this preserves backwards
  compatibility.

<p></p><p>

</p></li>
<li class="asterisk">There's a new <code>Incident</code> class which is used to hold information to
  be reported to the user. Previously, there were a number of
  overloaded methods to report issues, taking locations, error
  messages, quick fixes, and so on. Each time we added another one we'd
  have to add another overload. Now, you instead just report incidents.
  This is critical to the new partial analysis architecture but is also
  required if you for example want to override severities per incident
  as described above.

<p></p><p>

</p></li>
<li class="asterisk">Lint checks can now vary the severity on a per incident basis by
  calling overrideSeverity on the incidents. This means that there is
  no longer a need to create separate issues for flavors of the same
  underlying problem with slightly different expectations around
  warnings or errors.

<p></p><p>

</p></li>
<li class="asterisk">There are additional modifier lookup methods for Kotlin modifiers
  on <code>JavaEvaluator</code>, like <code>isReified()</code>, <code>isCompanion()</code>,
  <code>isTailRec()</code>, and so on.

<p></p><p>

</p></li>
<li class="asterisk">API documentation is now available.

<p></p><p>

</p></li>
<li class="asterisk">UAST for Kotlin is now based on Kotlin 1.5.

<p></p><p>

</p></li>
<li class="asterisk">Certain Kotlin PSI elements have new implementations known as <em class="underscore">ultra
  light classes</em>. Ultra light classes improve performance by answering
  PSI queries “directly from source” rather than delegating to the
  Kotlin compiler backend. You may see ultra light classes when
  accessing the <code>UElement.javaPsi</code> property of a Kotlin UAST element.
  They can also appear when resolving references. For example,
  resolving a Kotlin field reference to its declaration may result in
  an instance of <code>KtUltraLightFieldForSourceDeclaration</code>. As a
  reminder, Kotlin light classes represent the “Java view” of an
  underlying Kotlin PSI element. To access the underlying Kotlin PSI
  element you should use <code>UElement.sourcePsi</code> (preferred) or otherwise
  the extension property <code>PsiElement.unwrapped</code> (declared in
  <code>org.jetbrains.kotlin.asJava</code>).

<p></p><p>

</p></li>
<li class="asterisk">There is a new bug where calling <code>getNameIdentifier()</code> on Kotlin
  fields may return <code>null</code>
  (<a href="https://youtrack.jetbrains.com/issue/KT-45629">KT-45629</a>).
  As a workaround you can use <code>JavaContext.findNameElement()</code> instead.

<p></p><p>

</p></li>
<li class="asterisk">Kotlin references to Java methods now trigger both the
  <code>visitMethodCall()</code> callback <em class="underscore">and</em> the <code>visitReference()</code> callback.
  Previously only <code>visitMethodCall()</code> was triggered.

<p></p><p>

</p></li>
<li class="asterisk">Quickfixes can now create and delete new files; see
  <code>LintFix#newFile</code> and <code>LintFix#deleteFile</code>..

<p></p><p>

</p></li>
<li class="asterisk">For quickfixes, the <code>independent</code> property had inverted logic;
  this has now been reversed to follow the meaning of the name.</li></ul>

<p></p>
<a class="target" name="appendix:environmentvariablesandsystemproperties">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties">&nbsp;</a><a class="target" name="toc10">&nbsp;</a><h1>Appendix: Environment Variables and System Properties</h1>
<p>


This chapter lists the various environment variables and system
properties that Lint will look at. None of these are really intended to
be used or guaranteed to be supported in the future, but documenting
what they are seems useful.

</p>
<a class="target" name="environmentvariables">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/environmentvariables">&nbsp;</a><a class="target" name="toc10.1">&nbsp;</a><h2>Environment Variables</h2>

<a class="target" name="detectorconfigurationvariables">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/environmentvariables/detectorconfigurationvariables">&nbsp;</a><a class="target" name="toc10.1.1">&nbsp;</a><h3>Detector Configuration Variables</h3>
<p>


</p><dl><dt><code>ANDROID_LINT_INCLUDE_LDPI</code></dt><dd><p>  Lint's icon checks normally ignore the <code>ldpi</code> density since it's not
  commonly used any more, but you can turn this back on with this
  environment variable set to <code>true</code>.

</p></dd><dt><code>ANDROID_LINT_MAX_VIEW_COUNT</code></dt><dd><p>  Lint's <code>TooManyViews</code> check makes sure that a single layout does not
  have more than 80 views. You can set this environment variable to a
  different number to change the limit.

</p></dd><dt><code>ANDROID_LINT_MAX_DEPTH</code></dt><dd><p>  Lint's <code>TooManyViews</code> check makes sure that a single layout does not
  have a deeper layout hierarchy than 10 levels.You can set this
  environment variable to a different number to change the limit.

</p></dd><dt><code>ANDROID_LINT_NULLNESS_IGNORE_DEPRECATED</code></dt><dd><p>  Lint's <code>UnknownNullness</code> which flags any API element which is not
  explicitly annotated with nullness annotations, normally skips
  deprecated elements. Set this environment variable to true to include
  these as well.

</p><p>

  Corresponding system property: <code>lint.nullness.ignore-deprecated</code>

</p></dd></dl><p></p>
<a class="target" name="lintconfigurationvariables">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/environmentvariables/lintconfigurationvariables">&nbsp;</a><a class="target" name="toc10.1.2">&nbsp;</a><h3>Lint Configuration Variables</h3>
<p>


</p><dl><dt><code>ANDROID_SDK_ROOT</code></dt><dd><p>  Locates the Android SDK root

</p></dd><dt><code>ANDROID_HOME</code></dt><dd><p>  Locates the Android SDK root, if <code>$ANDROID_SDK_ROOT</code> has not been set

</p></dd><dt><code>JAVA_HOME</code></dt><dd><p>  Locates the JDK when lint is analyzing JDK (not Android) projects

</p></dd><dt><code>LINT_XML_ROOT</code></dt><dd><p>  Normally the search for <code>lint.xml</code> files proceeds upwards in the
  directory hierarchy. In the Gradle integration, the search will stop
  at the root Gradle project, but in other build systems, it can
  continue up to the root directory. This environment variable sets a
  path where the search should stop.

</p></dd><dt><code>ANDROID_LINT_JARS</code></dt><dd><p>  A path of jar files (using the path separator — semicolon on
  Windows, colon elsewhere) for lint to load extra lint checks from

</p></dd><dt><code>ANDROID_SDK_CACHE_DIR</code></dt><dd><p>  Sets the directory where lint should read and write its cache files.
  Lint has a number of databases that it caches between invocations,
  such as its binary representation of the SDK API database, used to
  look up API levels quickly. In the Gradle integration of lint, this
  cache directory is set to the root <code>build/</code> directory, but elsewhere
  the cache directory is located in a <code>lint</code> subfolder of the normal
  Android tooling cache directory, such as <code>~/.android</code>.

</p></dd><dt><code>LINT_OVERRIDE_CONFIGURATION</code></dt><dd><p>  Path to a lint XML file which should override any local <code>lint.xml</code>
  files closer to reported issues. This provides a way to globally
  change configuration.

</p><p>

  Corresponding system property: <code>lint.configuration.override</code>

</p></dd><dt><code>LINT_DO_NOT_REUSE_UAST_ENV</code></dt><dd><p>  Set to <code>true</code> to enable a workaround (if affected) for
  <a href="https://issuetracker.google.com/159733104">bug 159733104</a>
  until 7.0 is released.

</p><p>

  Corresponding system property: <code>lint.do.not.reuse.uast.env</code>

</p></dd><dt><code>LINT_API_DATABASE</code></dt><dd><p>  Point lint to an alternative API database XML file instead of the
  normally used <code>$SDK/platforms/android-?/data/api-versions.xml</code> file.

</p></dd></dl><p></p>
<a class="target" name="lintdevelopmentvariables">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/environmentvariables/lintdevelopmentvariables">&nbsp;</a><a class="target" name="toc10.1.3">&nbsp;</a><h3>Lint Development Variables</h3>
<p>


</p><dl><dt><code>LINT_PRINT_STACKTRACE</code></dt><dd><p>  If set to true, lint will print the full stack traces of any internal
  exceptions encountered during analysis. This is useful for authors of
  lint checks, or for power users who can reproduce a bug and want to
  report it with more details.

</p><p>

  Corresponding system property: <code>lint.print-stacktrace</code>

</p></dd><dt><code>LINT_TEST_KOTLINC</code></dt><dd><p>  When writing a lint check unit test, when creating a <code>compiled</code> or
  <code>bytecode</code> test file, lint can generate the .class file binary
  content automatically if it is pointed to the <code>kotlinc</code> compiler.

</p></dd><dt><code>LINT_TEST_JAVAC</code></dt><dd><p>  When writing a lint check unit test, when creating a <code>compiled</code> or
  <code>bytecode</code> test file, lint can generate the .class file binary
  content automatically if it is pointed to the <code>javac</code> compiler.

</p></dd><dt><code>INCLUDE_EXPENSIVE_LINT_TESTS</code></dt><dd><p>  When working on lint itself, set this environment variable to <code>true</code>
  some really, really expensive tests that we don't want run on the CI
  server or by the rest of the development team.

</p></dd></dl><p></p>
<a class="target" name="systemproperties">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/systemproperties">&nbsp;</a><a class="target" name="toc10.2">&nbsp;</a><h2>System Properties</h2>
<p>




</p><div class="admonition tip">To set system properties when running lint via Gradle, try for
   example <code>./gradlew lintDebug -Dlint.baselines.continue=true</code></div>

<p></p><p>

</p><dl><dt><code>lint.baselines.continue</code></dt><dd><p>  When you configure a new baseline, lint normally fails the build
  after creating the baseline. You can set this system property to true
  to force lint to continue.

</p></dd><dt><code>lint.autofix</code></dt><dd><p>  Turns on auto-fixing (applying safe quickfixes) by default. This is a
  shortcut for invoking the <code>lintFix</code> targets or running the <code>lint</code>
  command with <code>--apply-suggestions</code>.

</p></dd><dt><code>lint.html.prefs</code></dt><dd><p>  This property allows you to customize lint's HTML reports. It
  consists of a comma separated list of property assignments, e.g.
  <code>./gradlew :app:lintDebug -Dlint.html.prefs=theme=darcula,window=5</code>

</p></dd></dl><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Property </th><th style="text-align:left"> Explanation and Values </th><th style="text-align:left"> Default </th></tr>
<tr><td style="text-align:left"> <code>theme</code> </td><td style="text-align:left"> <code>light</code>, <code>darcula</code>, <code>solarized</code> </td><td style="text-align:left"> <code>light</code> </td></tr>
<tr><td style="text-align:left"> <code>window</code> </td><td style="text-align:left"> Number of lines around problem </td><td style="text-align:left"> 3 </td></tr>
<tr><td style="text-align:left"> <code>maxIncidents</code> </td><td style="text-align:left"> Maximum incidents shown per issue type </td><td style="text-align:left"> 50 </td></tr>
<tr><td style="text-align:left"> <code>splitLimit</code> </td><td style="text-align:left"> Issue count before “More...” button </td><td style="text-align:left"> 8 </td></tr>
<tr><td style="text-align:left"> <code>maxPerIssue</code> </td><td style="text-align:left"> Name of split limit prior to 7.0 </td><td style="text-align:left"> 8 </td></tr>
<tr><td style="text-align:left"> <code>underlineErrors</code> </td><td style="text-align:left"> If true, wavy underlines, else highlight </td><td style="text-align:left"> <code>true</code> </td></tr>
</tbody></table></div>

<p></p><p>

</p><dl><table><tbody><tr valign="top"><td><dt><code>lint.unused-resources.exclude-tests</code></dt></td><td><dd><p>  Whether the unused resource check should exclude test sources as
  referenced resources.

</p></dd></td></tr><tr valign="top"><td><dt><code>lint.configuration.override</code></dt></td><td><dd><p>  Alias for <code>$LINT_OVERRIDE_CONFIGURATION</code>

</p></dd></td></tr><tr valign="top"><td><dt><code>lint.print-stacktrace</code></dt></td><td><dd><p>  Alias for <code>$LINT_PRINT_STACKTRACE</code>

</p></dd></td></tr><tr valign="top"><td><dt><code>lint.do.not.reuse.uast.env</code></dt></td><td><dd><p>  Alias for <code>$LINT_DO_NOT_REUSE_UAST_ENV</code>

</p></dd></td></tr><tr valign="top"><td><dt><code>android.lint.log-jar-problems</code></dt></td><td><dd><p>  Controls whether lint will complain about custom check lint jar
  loading problems. By default, true.

</p></dd></td></tr></tbody></table></dl><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility=&ldquo;visible&rdquo;)</script>
<p></p></span><div id="mdContextMenu" style="visibility:hidden"></div><div class="markdeepFooter"><i>formatted by <a href="https://casual-effects.com/markdeep" style="color:#999">Markdeep&nbsp;1.13&nbsp;&nbsp;</a></i><div style="display:inline-block;font-size:13px;font-family:'Times New Roman',serif;vertical-align:middle;transform:translate(-3px,-1px)rotate(135deg);">✒</div></div></body></html>