<html><head><meta charset="utf-8" lang="kotlin">

</head><body style="visibility: visible;" id="md"><meta charset="UTF-8"><meta http-equiv="content-type" content="text/html;charset=UTF-8"><meta name="viewport" content="width=600, initial-scale=1"><style>body{max-width:680px;margin:auto;padding:20px;text-align:justify;line-height:140%;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-smoothing:antialiased;color:#222;font-family:Palatino,Georgia,"Times New Roman",serif}</style><style>@media print{*{-webkit-print-color-adjust:exact;text-shadow:none !important}}body{counter-reset: h1 paragraph line item list-item}@page{margin:0;size:auto}#mdContextMenu{position:absolute;background:#383838;cursor:default;border:1px solid #999;color:#fff;padding:4px 0px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,"Helvetica Neue",sans-serif;font-size:85%;font-weight:600;border-radius:4px;box-shadow:0px 3px 10px rgba(0,0,0,35%)}#mdContextMenu div{padding:0px 20px}#mdContextMenu div:hover{background:#1659d1}.md code,.md pre{font-family:Menlo,Consolas,monospace;font-size:85%;text-align:left;line-height:140%}.md .mediumToc code,.md longToc code,.md .shortToc code,.md h1 code,.md h2 code,.md h3 code,.md h4 code,.md h5 code,.md h6 code{font-size:unset}.md div.title{font-size:26px;font-weight:800;line-height:120%;text-align:center}.md div.afterTitles{height:10px}.md div.subtitle{text-align:center}.md iframe.textinsert, .md object.textinsert,.md iframe:not(.markdeep){display:block;margin-top:10px;margin-bottom:10px;width:100%;height:75vh;border:1px solid #000;border-radius:4px;background:#f5f5f4}.md .image{display:inline-block}.md img{max-width:100%;page-break-inside:avoid}.md li{text-align:left;text-indent:0}.md pre.listing {width:100%;tab-size:4;-moz-tab-size:4;-o-tab-size:4;counter-reset:line;overflow-x:auto;resize:horizontal}.md pre.listing .linenumbers span.line:before{width:30px;margin-left:-28px;font-size:80%;text-align:right;counter-increment:line;content:counter(line);display:inline-block;padding-right:13px;margin-right:8px;color:#ccc}.md div.tilde{margin:20px 0 -10px;text-align:center}.md .imagecaption,.md .tablecaption,.md .listingcaption{display:inline-block;margin:7px 5px 12px;text-align:justify;font-style:italic}.md img.pixel{image-rendering:-moz-crisp-edges;image-rendering:pixelated}.md blockquote.fancyquote{margin:25px 0 25px;text-align:left;line-height:160%}.md blockquote.fancyquote::before{content:"“";color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-right:6px;vertical-align:-0.3em}.md span.fancyquote{font-size:118%;color:#777;font-style:italic}.md span.fancyquote::after{content:"”";font-style:normal;color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-left:6px;vertical-align:-0.3em}.md blockquote.fancyquote .author{width:100%;margin-top:10px;display:inline-block;text-align:right}.md small{font-size:60%}.md big{font-size:150%}.md div.title,contents,.md .tocHeader,.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .shortTOC,.md .mediumTOC,.nonumberh1,.nonumberh2,.nonumberh3,.nonumberh4,.nonumberh5,.nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;margin:13.4px 0 13.4px;padding:15px 0 3px;border-top:none;clear:both}.md .tocTop {display:none}.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .nonumberh1,.md .nonumberh2,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{page-break-after:avoid;break-after:avoid}.md svg.diagram{display:block;font-family:Menlo,Consolas,monospace;font-size:85%;text-align:center;stroke-linecap:round;stroke-width:2px;page-break-inside:avoid;stroke:#000;fill:#000}.md svg.diagram .opendot{fill:#fff}.md svg.diagram .shadeddot{fill:#CCC}.md svg.diagram .dotteddot{stroke:#000;stroke-dasharray:4;fill:none}.md svg.diagram text{stroke:none}@media print{@page{margin:1in 5mm;transform: scale(150%)}}@media print{.md .pagebreak{page-break-after:always;visibility:hidden}}.md a{font-family:Georgia,Palatino,'Times New Roman'}.md h1,.md .tocHeader,.md .nonumberh1{border-bottom:3px solid;font-size:20px;font-weight:bold;}.md h1,.md .nonumberh1{counter-reset:h2 h3 h4 h5 h6}.md h2,.md .nonumberh2{counter-reset:h3 h4 h5 h6;border-bottom:2px solid #999;color:#555;font-weight:bold;font-size:18px;}.md h3,.md h4,.md h5,.md h6,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;color:#555;font-size:16px;}.md h3{counter-reset:h4 h5 h6}.md h4{counter-reset:h5 h6}.md h5{counter-reset:h6}.md div.table{margin:16px 0 16px 0}.md table{border-collapse:collapse;line-height:140%;page-break-inside:avoid}.md table.table{margin:auto}.md table.calendar{width:100%;margin:auto;font-size:11px;font-family:Verdana,Helvetica,Arial,sans-serif}.md table.calendar th{font-size:16px}.md .today{background:#ECF8FA}.md .calendar .parenthesized{color:#999;font-style:italic}.md table.table th{color:#FFF;background-color:#AAA;border:1px solid #888;padding:8px 15px 8px 15px}.md table.table td{padding:5px 15px 5px 15px;border:1px solid #888}.md table.table tr:nth-child(even){background:#EEE}.md pre.tilde{border-top: 1px solid #CCC;border-bottom: 1px solid #CCC;padding: 5px 0 5px 20px;margin:0 0 0 0;background:#FCFCFC;page-break-inside:avoid}.md a.target{width:0px;height:0px;visibility:hidden;font-size:0px;display:inline-block}.md a:link, .md a:visited{color:#38A;text-decoration:none}.md a:link:hover{text-decoration:underline}.md dt{font-weight:700}.md dl>dd{margin-top:-8px; margin-bottom:8px}.md dl>table{margin:35px 0 30px}.md code{page-break-inside:avoid;} @media print{.md .listing code{white-space:pre-wrap}}.md .endnote{font-size:13px;line-height:15px;padding-left:10px;text-indent:-10px}.md .bib{padding-left:80px;text-indent:-80px;text-align:left}.markdeepFooter{font-size:9px;text-align:right;padding-top:80px;color:#999}.md .mediumTOC{float:right;font-size:12px;line-height:15px;border-left:1px solid #CCC;padding-left:15px;margin:15px 0px 15px 25px}.md .mediumTOC .level1{font-weight:600}.md .longTOC .level1{font-weight:600;display:block;padding-top:12px;margin:0 0 -20px}.md .shortTOC{text-align:center;font-weight:bold;margin-top:15px;font-size:14px}.md .admonition{position:relative;margin:1em 0;padding:.4rem 1rem;border-radius:.2rem;border-left:2.5rem solid rgba(68,138,255,.4);background-color:rgba(68,138,255,.15);}.md .admonition-title{font-weight:bold;border-bottom:solid 1px rgba(68,138,255,.4);padding-bottom:4px;margin-bottom:4px;margin-left: -1rem;padding-left:1rem;margin-right:-1rem;border-color:rgba(68,138,255,.4)}.md .admonition.tip{border-left:2.5rem solid rgba(50,255,90,.4);background-color:rgba(50,255,90,.15)}.md .admonition.tip::before{content:"\24d8";font-weight:bold;font-size:150%;position:relative;top:3px;color:rgba(26,128,46,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.tip>.admonition-title{border-color:rgba(50,255,90,.4)}.md .admonition.warn,.md .admonition.warning{border-left:2.5rem solid rgba(255,145,0,.4);background-color:rgba(255,145,0,.15)}.md .admonition.warn::before,.md .admonition.warning::before{content:"\26A0";font-weight:bold;font-size:150%;position:relative;top:2px;color:rgba(128,73,0,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.warn>.admonition-title,.md .admonition.warning>.admonition-title{border-color:rgba(255,145,0,.4)}.md .admonition.error{border-left: 2.5rem solid rgba(255,23,68,.4);background-color:rgba(255,23,68,.15)}.md .admonition.error>.admonition-title{border-color:rgba(255,23,68,.4)}.md .admonition.error::before{content: "\2612";font-family:"Arial";font-size:200%;position:relative;color:rgba(128,12,34,.8);top:-2px;left:-3rem;display:block;width:0;height:0}.md .admonition p:last-child{margin-bottom:0}.md li.checked,.md li.unchecked{list-style:none;overflow:visible;text-indent:-1.2em}.md li.checked:before,.md li.unchecked:before{content:"\2611";display:block;float:left;width:1em;font-size:120%}.md li.unchecked:before{content:"\2610"}</style><style>.md h1::before {
content:counter(h1) " ";
counter-increment: h1;margin-right:10px}

.md h2::before {
content:counter(h1) "."counter(h2) " ";
counter-increment: h2;margin-right:10px}

.md h3::before {
content:counter(h1) "."counter(h2) "."counter(h3) " ";
counter-increment: h3;margin-right:10px}

.md h4::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) " ";
counter-increment: h4;margin-right:10px}

.md h5::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) " ";
counter-increment: h5;margin-right:10px}

.md h6::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) "."counter(h6) " ";
counter-increment: h6;margin-right:10px}

</style><style>.hljs{display:block;overflow-x:auto;padding:0.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword{color:#02E}.hljs-literal,.nginx .hljs-title{color:#aa0d91}.method,.hljs-list .hljs-title,.hljs-tag .hljs-title,.setting .hljs-value,.hljs-winutils,.tex .hljs-command,.http .hljs-title,.hljs-request,.hljs-status,.hljs-name{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.hljs-tag .hljs-value,.hljs-cdata,.hljs-filter .hljs-argument,.hljs-attr_selector,.apache .hljs-cbracket,.hljs-date,.hljs-regexp{color:#080}.hljs-sub .hljs-identifier,.hljs-pi,.hljs-tag,.hljs-tag .hljs-keyword,.hljs-decorator,.ini .hljs-title,.hljs-shebang,.hljs-prompt,.hljs-hexcolor,.hljs-rule .hljs-value,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-number,.css .hljs-function,.hljs-function .hljs-title,.coffeescript .hljs-attribute{color:#A0C}.hljs-function .hljs-title{font-weight:bold;color:#000}.hljs-class .hljs-title,.smalltalk .hljs-class,.hljs-type,.hljs-typename,.hljs-tag .hljs-attribute,.hljs-doctype,.hljs-class .hljs-id,.hljs-built_in,.setting,.hljs-params,.clojure .hljs-attribute{color:#5c2699}.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-rule .hljs-property,.hljs-pseudo,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#ff7700;font-weight:bold}.hljs-rule .hljs-keyword{color:#c5af75}.hljs-annotation,.apache .hljs-sqbracket,.nginx .hljs-built_in{color:#9b859d}.hljs-preprocessor,.hljs-preprocessor *,.hljs-pragma{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:#808080;font-weight:bold}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:bold}.method .hljs-id{color:#000}</style><style>div.title { padding-top: 40px; } div.afterTitles { height: 15px; }</style><meta charset="utf-8" lang="kotlin">

<script type="text/x-mathjax-config">MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });</script><span style="display:none">$$\newcommand{\n}{\hat{n}}\newcommand{\thetai}{\theta_\mathrm{i}}\newcommand{\thetao}{\theta_\mathrm{o}}\newcommand{\d}[1]{\mathrm{d}#1}\newcommand{\w}{\hat{\omega}}\newcommand{\wi}{\w_\mathrm{i}}\newcommand{\wo}{\w_\mathrm{o}}\newcommand{\wh}{\w_\mathrm{h}}\newcommand{\Li}{L_\mathrm{i}}\newcommand{\Lo}{L_\mathrm{o}}\newcommand{\Le}{L_\mathrm{e}}\newcommand{\Lr}{L_\mathrm{r}}\newcommand{\Lt}{L_\mathrm{t}}\newcommand{\O}{\mathrm{O}}\newcommand{\degrees}{{^{\large\circ}}}\newcommand{\T}{\mathsf{T}}\newcommand{\mathset}[1]{\mathbb{#1}}\newcommand{\Real}{\mathset{R}}\newcommand{\Integer}{\mathset{Z}}\newcommand{\Boolean}{\mathset{B}}\newcommand{\Complex}{\mathset{C}}\newcommand{\un}[1]{\,\mathrm{#1}}$$
</span>
<span class="md"><p><title>Android Lint API Guide</title></p><div class="title"> Android Lint API Guide </div>

<div class="afterTitles"></div>

<p></p><p>

This chapter inlines all the API documentation into a single
long book, suitable for printing or reading on a tablet.

</p>
<div class="longTOC"><div class="tocHeader">Contents</div><p><a href="#" class="tocTop">(Top)</a><br>
<a href="#terminology" class="level1"><span class="tocNumber">1&nbsp; </span>Terminology</a><br>
<a href="#writingalintcheck:basics" class="level1"><span class="tocNumber">2&nbsp; </span>Writing a Lint Check: Basics</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/preliminaries" class="level2"><span class="tocNumber">2.1&nbsp; </span>Preliminaries</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/preliminaries/%E2%80%9Clint?%E2%80%9D" class="level3"><span class="tocNumber">2.1.1&nbsp; </span>“Lint?”</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/preliminaries/apistability" class="level3"><span class="tocNumber">2.1.2&nbsp; </span>API Stability</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/preliminaries/kotlin" class="level3"><span class="tocNumber">2.1.3&nbsp; </span>Kotlin</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/concepts" class="level2"><span class="tocNumber">2.2&nbsp; </span>Concepts</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/clientapiversusdetectorapi" class="level2"><span class="tocNumber">2.3&nbsp; </span>Client API versus Detector API</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/creatinganissue" class="level2"><span class="tocNumber">2.4&nbsp; </span>Creating an Issue</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/textformat" class="level2"><span class="tocNumber">2.5&nbsp; </span>TextFormat</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/issueimplementation" class="level2"><span class="tocNumber">2.6&nbsp; </span>Issue Implementation</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/scopes" class="level2"><span class="tocNumber">2.7&nbsp; </span>Scopes</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/registeringtheissue" class="level2"><span class="tocNumber">2.8&nbsp; </span>Registering the Issue</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/implementingadetector:scanners" class="level2"><span class="tocNumber">2.9&nbsp; </span>Implementing a Detector: Scanners</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/detectorlifecycle" class="level2"><span class="tocNumber">2.10&nbsp; </span>Detector Lifecycle</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/scannerorder" class="level2"><span class="tocNumber">2.11&nbsp; </span>Scanner Order</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/implementingadetector:services" class="level2"><span class="tocNumber">2.12&nbsp; </span>Implementing a Detector: Services</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/scannerexample" class="level2"><span class="tocNumber">2.13&nbsp; </span>Scanner Example</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode" class="level2"><span class="tocNumber">2.14&nbsp; </span>Analyzing Kotlin and Java Code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/uast" class="level3"><span class="tocNumber">2.14.1&nbsp; </span>UAST</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/uastexample" class="level3"><span class="tocNumber">2.14.2&nbsp; </span>UAST Example</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/lookingupuast" class="level3"><span class="tocNumber">2.14.3&nbsp; </span>Looking up UAST</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/resolving" class="level3"><span class="tocNumber">2.14.4&nbsp; </span>Resolving</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/implicitcalls" class="level3"><span class="tocNumber">2.14.5&nbsp; </span>Implicit Calls</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#writingalintcheck:basics/analyzingkotlinandjavacode/psi" class="level3"><span class="tocNumber">2.14.6&nbsp; </span>PSI</a><br>
&nbsp;&nbsp;<a href="#writingalintcheck:basics/testing" class="level2"><span class="tocNumber">2.15&nbsp; </span>Testing</a><br>
<a href="#example:samplelintcheckgithubproject" class="level1"><span class="tocNumber">3&nbsp; </span>Example: Sample Lint Check GitHub Project</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/projectlayout" class="level2"><span class="tocNumber">3.1&nbsp; </span>Project Layout</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/:checks" class="level2"><span class="tocNumber">3.2&nbsp; </span>:checks</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/lintversion?" class="level2"><span class="tocNumber">3.3&nbsp; </span>lintVersion?</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/:libraryand:app" class="level2"><span class="tocNumber">3.4&nbsp; </span>:library and :app</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/lintcheckprojectlayout" class="level2"><span class="tocNumber">3.5&nbsp; </span>Lint Check Project Layout</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/serviceregistration" class="level2"><span class="tocNumber">3.6&nbsp; </span>Service Registration</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/issueregistry" class="level2"><span class="tocNumber">3.7&nbsp; </span>IssueRegistry</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/detector" class="level2"><span class="tocNumber">3.8&nbsp; </span>Detector</a><br>
&nbsp;&nbsp;<a href="#example:samplelintcheckgithubproject/detectortest" class="level2"><span class="tocNumber">3.9&nbsp; </span>Detector Test</a><br>
<a href="#publishingalintcheck" class="level1"><span class="tocNumber">4&nbsp; </span>Publishing a Lint Check</a><br>
&nbsp;&nbsp;<a href="#publishingalintcheck/android" class="level2"><span class="tocNumber">4.1&nbsp; </span>Android</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publishingalintcheck/android/aarsupport" class="level3"><span class="tocNumber">4.1.1&nbsp; </span>AAR Support</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publishingalintcheck/android/lintpublishconfiguration" class="level3"><span class="tocNumber">4.1.2&nbsp; </span>lintPublish Configuration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publishingalintcheck/android/localchecks" class="level3"><span class="tocNumber">4.1.3&nbsp; </span>Local Checks</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#publishingalintcheck/android/unpublishing" class="level3"><span class="tocNumber">4.1.4&nbsp; </span>Unpublishing</a><br>
<a href="#lintcheckunittesting" class="level1"><span class="tocNumber">5&nbsp; </span>Lint Check Unit Testing</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/creatingaunittest" class="level2"><span class="tocNumber">5.1&nbsp; </span>Creating a Unit Test</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/computingtheexpectedoutput" class="level2"><span class="tocNumber">5.2&nbsp; </span>Computing the Expected Output</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/testfiles" class="level2"><span class="tocNumber">5.3&nbsp; </span>Test Files</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/trimmingindents?" class="level2"><span class="tocNumber">5.4&nbsp; </span>Trimming indents?</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/dollarsinrawstrings" class="level2"><span class="tocNumber">5.5&nbsp; </span>Dollars in Raw Strings</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/quickfixes" class="level2"><span class="tocNumber">5.6&nbsp; </span>Quickfixes</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/librarydependenciesandstubs" class="level2"><span class="tocNumber">5.7&nbsp; </span>Library Dependencies and Stubs</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/binaryandcompiledsourcefiles" class="level2"><span class="tocNumber">5.8&nbsp; </span>Binary and Compiled Source Files</a><br>
&nbsp;&nbsp;<a href="#lintcheckunittesting/mydetectorisn'tinvokedfromatest!" class="level2"><span class="tocNumber">5.9&nbsp; </span>My Detector Isn't Invoked From a Test!</a><br>
<a href="#testmodes" class="level1"><span class="tocNumber">6&nbsp; </span>Test Modes</a><br>
&nbsp;&nbsp;<a href="#testmodes/howtodebug" class="level2"><span class="tocNumber">6.1&nbsp; </span>How to debug</a><br>
&nbsp;&nbsp;<a href="#testmodes/handlingintentionalfailures" class="level2"><span class="tocNumber">6.2&nbsp; </span>Handling Intentional Failures</a><br>
&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes" class="level2"><span class="tocNumber">6.3&nbsp; </span>Source-Modifying Test Modes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/fullyqualifiednames" class="level3"><span class="tocNumber">6.3.1&nbsp; </span>Fully Qualified Names</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/importaliasing" class="level3"><span class="tocNumber">6.3.2&nbsp; </span>Import Aliasing</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/typealiasing" class="level3"><span class="tocNumber">6.3.3&nbsp; </span>Type Aliasing</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/parenthesismode" class="level3"><span class="tocNumber">6.3.4&nbsp; </span>Parenthesis Mode</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/argumentreordering" class="level3"><span class="tocNumber">6.3.5&nbsp; </span>Argument Reordering</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/bodyremoval" class="level3"><span class="tocNumber">6.3.6&nbsp; </span>Body Removal</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/iftowhenreplacement" class="level3"><span class="tocNumber">6.3.7&nbsp; </span>If to When Replacement</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/whitespacemode" class="level3"><span class="tocNumber">6.3.8&nbsp; </span>Whitespace Mode</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#testmodes/source-modifyingtestmodes/cdatamode" class="level3"><span class="tocNumber">6.3.9&nbsp; </span>CDATA Mode</a><br>
<a href="#addingquickfixes" class="level1"><span class="tocNumber">7&nbsp; </span>Adding Quick Fixes</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/introduction" class="level2"><span class="tocNumber">7.1&nbsp; </span>Introduction</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/thelintfixbuilderclass" class="level2"><span class="tocNumber">7.2&nbsp; </span>The LintFix builder class</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/creatingalintfix" class="level2"><span class="tocNumber">7.3&nbsp; </span>Creating a LintFix</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/availablefixes" class="level2"><span class="tocNumber">7.4&nbsp; </span>Available Fixes</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/combiningfixes" class="level2"><span class="tocNumber">7.5&nbsp; </span>Combining Fixes</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/refactoringjavaandkotlincode" class="level2"><span class="tocNumber">7.6&nbsp; </span>Refactoring Java and Kotlin code</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/regularexpressionsandbackreferences" class="level2"><span class="tocNumber">7.7&nbsp; </span>Regular Expressions and Back References</a><br>
&nbsp;&nbsp;<a href="#addingquickfixes/emittingquickfixxmltoapplyonci" class="level2"><span class="tocNumber">7.8&nbsp; </span>Emitting quick fix XML to apply on CI</a><br>
<a href="#partialanalysis" class="level1"><span class="tocNumber">8&nbsp; </span>Partial Analysis</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/about" class="level2"><span class="tocNumber">8.1&nbsp; </span>About</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/theproblem" class="level2"><span class="tocNumber">8.2&nbsp; </span>The Problem</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/overview" class="level2"><span class="tocNumber">8.3&nbsp; </span>Overview</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?" class="level2"><span class="tocNumber">8.4&nbsp; </span>Does My Detector Need Work?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?/catchingmistakes:blockingaccesstomainproject" class="level3"><span class="tocNumber">8.4.1&nbsp; </span>Catching Mistakes: Blocking Access to Main Project</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?/catchingmistakes:simulatedappmodule" class="level3"><span class="tocNumber">8.4.2&nbsp; </span>Catching Mistakes: Simulated App Module</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?/catchingmistakes:diffingresults" class="level3"><span class="tocNumber">8.4.3&nbsp; </span>Catching Mistakes: Diffing Results</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#partialanalysis/doesmydetectorneedwork?/catchingmistakes:remainingissues" class="level3"><span class="tocNumber">8.4.4&nbsp; </span>Catching Mistakes: Remaining Issues</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/incidents" class="level2"><span class="tocNumber">8.5&nbsp; </span>Incidents</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/constraints" class="level2"><span class="tocNumber">8.6&nbsp; </span>Constraints</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/incidentlintmaps" class="level2"><span class="tocNumber">8.7&nbsp; </span>Incident LintMaps</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/modulelintmaps" class="level2"><span class="tocNumber">8.8&nbsp; </span>Module LintMaps</a><br>
&nbsp;&nbsp;<a href="#partialanalysis/optimizations" class="level2"><span class="tocNumber">8.9&nbsp; </span>Optimizations</a><br>
<a href="#dataflowanalyzer" class="level1"><span class="tocNumber">9&nbsp; </span>Data Flow Analyzer</a><br>
&nbsp;&nbsp;<a href="#dataflowanalyzer/usage" class="level2"><span class="tocNumber">9.1&nbsp; </span>Usage</a><br>
&nbsp;&nbsp;<a href="#dataflowanalyzer/self-referencingcalls" class="level2"><span class="tocNumber">9.2&nbsp; </span>Self-referencing Calls</a><br>
&nbsp;&nbsp;<a href="#dataflowanalyzer/kotlinscopingfunctions" class="level2"><span class="tocNumber">9.3&nbsp; </span>Kotlin Scoping Functions</a><br>
&nbsp;&nbsp;<a href="#dataflowanalyzer/limitations" class="level2"><span class="tocNumber">9.4&nbsp; </span>Limitations</a><br>
&nbsp;&nbsp;<a href="#dataflowanalyzer/escapingvalues" class="level2"><span class="tocNumber">9.5&nbsp; </span>Escaping Values</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dataflowanalyzer/escapingvalues/returns" class="level3"><span class="tocNumber">9.5.1&nbsp; </span>Returns</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dataflowanalyzer/escapingvalues/parameters" class="level3"><span class="tocNumber">9.5.2&nbsp; </span>Parameters</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dataflowanalyzer/escapingvalues/fields" class="level3"><span class="tocNumber">9.5.3&nbsp; </span>Fields</a><br>
&nbsp;&nbsp;<a href="#dataflowanalyzer/nonlocalanalysis" class="level2"><span class="tocNumber">9.6&nbsp; </span>Non Local Analysis</a><br>
&nbsp;&nbsp;<a href="#dataflowanalyzer/examples" class="level2"><span class="tocNumber">9.7&nbsp; </span>Examples</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dataflowanalyzer/examples/simpleexample" class="level3"><span class="tocNumber">9.7.1&nbsp; </span>Simple Example</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#dataflowanalyzer/examples/complexexample" class="level3"><span class="tocNumber">9.7.2&nbsp; </span>Complex Example</a><br>
<a href="#annotations" class="level1"><span class="tocNumber">10&nbsp; </span>Annotations</a><br>
&nbsp;&nbsp;<a href="#annotations/basics" class="level2"><span class="tocNumber">10.1&nbsp; </span>Basics</a><br>
&nbsp;&nbsp;<a href="#annotations/annotationusagetypesandisapplicableannotationusage" class="level2"><span class="tocNumber">10.2&nbsp; </span>Annotation Usage Types and isApplicableAnnotationUsage</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#annotations/annotationusagetypesandisapplicableannotationusage/methodoverride" class="level3"><span class="tocNumber">10.2.1&nbsp; </span>Method Override</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#annotations/annotationusagetypesandisapplicableannotationusage/methodreturn" class="level3"><span class="tocNumber">10.2.2&nbsp; </span>Method Return</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#annotations/annotationusagetypesandisapplicableannotationusage/handlingusagetypes" class="level3"><span class="tocNumber">10.2.3&nbsp; </span>Handling Usage Types</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#annotations/annotationusagetypesandisapplicableannotationusage/usagetypesfilteredbydefault" class="level3"><span class="tocNumber">10.2.4&nbsp; </span>Usage Types Filtered By Default</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#annotations/annotationusagetypesandisapplicableannotationusage/scopes" class="level3"><span class="tocNumber">10.2.5&nbsp; </span>Scopes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#annotations/annotationusagetypesandisapplicableannotationusage/inheritedannotations" class="level3"><span class="tocNumber">10.2.6&nbsp; </span>Inherited Annotations</a><br>
<a href="#options" class="level1"><span class="tocNumber">11&nbsp; </span>Options</a><br>
&nbsp;&nbsp;<a href="#options/usage" class="level2"><span class="tocNumber">11.1&nbsp; </span>Usage</a><br>
&nbsp;&nbsp;<a href="#options/creatingoptions" class="level2"><span class="tocNumber">11.2&nbsp; </span>Creating Options</a><br>
&nbsp;&nbsp;<a href="#options/readingoptions" class="level2"><span class="tocNumber">11.3&nbsp; </span>Reading Options</a><br>
&nbsp;&nbsp;<a href="#options/specificconfigurations" class="level2"><span class="tocNumber">11.4&nbsp; </span>Specific Configurations</a><br>
&nbsp;&nbsp;<a href="#options/files" class="level2"><span class="tocNumber">11.5&nbsp; </span>Files</a><br>
&nbsp;&nbsp;<a href="#options/constraints" class="level2"><span class="tocNumber">11.6&nbsp; </span>Constraints</a><br>
&nbsp;&nbsp;<a href="#options/testingoptions" class="level2"><span class="tocNumber">11.7&nbsp; </span>Testing Options</a><br>
&nbsp;&nbsp;<a href="#options/supportinglint4.2,7.0and7.1" class="level2"><span class="tocNumber">11.8&nbsp; </span>Supporting Lint 4.2, 7.0 and 7.1</a><br>
<a href="#errormessageconventions" class="level1"><span class="tocNumber">12&nbsp; </span>Error Message Conventions</a><br>
&nbsp;&nbsp;<a href="#errormessageconventions/length" class="level2"><span class="tocNumber">12.1&nbsp; </span>Length</a><br>
&nbsp;&nbsp;<a href="#errormessageconventions/formatting" class="level2"><span class="tocNumber">12.2&nbsp; </span>Formatting</a><br>
&nbsp;&nbsp;<a href="#errormessageconventions/punctuation" class="level2"><span class="tocNumber">12.3&nbsp; </span>Punctuation</a><br>
&nbsp;&nbsp;<a href="#errormessageconventions/includedetails" class="level2"><span class="tocNumber">12.4&nbsp; </span>Include Details</a><br>
&nbsp;&nbsp;<a href="#errormessageconventions/referenceandroidbynumber" class="level2"><span class="tocNumber">12.5&nbsp; </span>Reference Android By Number</a><br>
&nbsp;&nbsp;<a href="#errormessageconventions/keepmessagesstable" class="level2"><span class="tocNumber">12.6&nbsp; </span>Keep Messages Stable</a><br>
&nbsp;&nbsp;<a href="#errormessageconventions/examples" class="level2"><span class="tocNumber">12.7&nbsp; </span>Examples</a><br>
<a href="#frequentlyaskedquestions" class="level1"><span class="tocNumber">13&nbsp; </span>Frequently Asked Questions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//mydetectorcallbacksaren'tinvoked" class="level3"><span class="tocNumber">13.0.1&nbsp; </span>My detector callbacks aren't invoked</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//mylintcheckworksfromtheunittestbutnotintheide" class="level3"><span class="tocNumber">13.0.2&nbsp; </span>My lint check works from the unit test but not in the IDE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//visitannotationusageisn'tcalledforannotations" class="level3"><span class="tocNumber">13.0.3&nbsp; </span><code>visitAnnotationUsage</code> isn't called for annotations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoicheckifauastorpsielementisforjavaorkotlin?" class="level3"><span class="tocNumber">13.0.4&nbsp; </span>How do I check if a UAST or PSI element is for Java or Kotlin?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//whatifineedapsielementandihaveauelement?" class="level3"><span class="tocNumber">13.0.5&nbsp; </span>What if I need a <code>PsiElement</code> and I have a <code>UElement</code> ?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoigettheumethodforapsimethod?" class="level3"><span class="tocNumber">13.0.6&nbsp; </span>How do I get the <code>UMethod</code> for a <code>PsiMethod</code> ?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdogetajavaevaluator?" class="level3"><span class="tocNumber">13.0.7&nbsp; </span>How do get a <code>JavaEvaluator</code> ?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoicheckwhetheranelementisinternal?" class="level3"><span class="tocNumber">13.0.8&nbsp; </span>How do I check whether an element is internal?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//iselementinline,sealed,operator,infix,suspend,data?" class="level3"><span class="tocNumber">13.0.9&nbsp; </span>Is element inline, sealed, operator, infix, suspend, data?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoilookupaclassifihaveitsfullyqualifiedname?" class="level3"><span class="tocNumber">13.0.10&nbsp; </span>How do I look up a class if I have its fully qualified name?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoilookupaclassifihaveapsitype?" class="level3"><span class="tocNumber">13.0.11&nbsp; </span>How do I look up a class if I have a PsiType?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoilookuphierarhcyannotationsforanelement?" class="level3"><span class="tocNumber">13.0.12&nbsp; </span>How do I look up hierarhcy annotations for an element?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoilookupifaclassisasubclassofanother?" class="level3"><span class="tocNumber">13.0.13&nbsp; </span>How do I look up if a class is a subclass of another?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoiknowwhichparameteracallargumentcorrespondsto?" class="level3"><span class="tocNumber">13.0.14&nbsp; </span>How do I know which parameter a call argument corresponds to?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howcanmylintcheckstargettwodifferentversionsoflint?" class="level3"><span class="tocNumber">13.0.15&nbsp; </span>How can my lint checks target two different versions of lint?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//canimakemylintcheck%E2%80%9Cnotsuppressible?%E2%80%9D" class="level3"><span class="tocNumber">13.0.16&nbsp; </span>Can I make my lint check “not suppressible?”</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//whyareoverloadedoperatorsnothandled?" class="level3"><span class="tocNumber">13.0.17&nbsp; </span>Why are overloaded operators not handled?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//howdoicheckoutthecurrentlintsourcecode?" class="level3"><span class="tocNumber">13.0.18&nbsp; </span>How do I check out the current lint source code?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#frequentlyaskedquestions//wheredoifindexamplesoflintchecks?" class="level3"><span class="tocNumber">13.0.19&nbsp; </span>Where do I find examples of lint checks?</a><br>
<a href="#appendix:recentchanges" class="level1"><span class="tocNumber">14&nbsp; </span>Appendix: Recent Changes</a><br>
<a href="#appendix:environmentvariablesandsystemproperties" class="level1"><span class="tocNumber">15&nbsp; </span>Appendix: Environment Variables and System Properties</a><br>
&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/environmentvariables" class="level2"><span class="tocNumber">15.1&nbsp; </span>Environment Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/environmentvariables/detectorconfigurationvariables" class="level3"><span class="tocNumber">15.1.1&nbsp; </span>Detector Configuration Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/environmentvariables/lintconfigurationvariables" class="level3"><span class="tocNumber">15.1.2&nbsp; </span>Lint Configuration Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/environmentvariables/lintdevelopmentvariables" class="level3"><span class="tocNumber">15.1.3&nbsp; </span>Lint Development Variables</a><br>
&nbsp;&nbsp;<a href="#appendix:environmentvariablesandsystemproperties/systemproperties" class="level2"><span class="tocNumber">15.2&nbsp; </span>System Properties</a><br>
</p></div><a class="target" name="terminology">&nbsp;</a><a class="target" name="terminology">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>Terminology</h1>
<p>


You don't need to read this up front and understand everything, but
this is hopefully a handy reference to return to.

</p><p>

In alphabetical order:

</p><p>

</p><dl><dt>Configuration</dt><dd><p>  A configuration provides extra information or parameters to lint on a
  per project, or even per directory basis. For example, the <code>lint.xml</code>
  files can change the severity for issues, or list incidents to ignore
  (matched for example by a regular expression), or even provide values
  for options read by a specific detector.

</p></dd><dt>Context</dt><dd><p>  An object passed into detectors in many APIs, providing data about
  (for example) which file is being analyzed (and in which project),
  and for specific types of analysis additional information; for
  example, an XmlContext points to the DOM document, a JavaContext
  includes the AST, and so on.

</p></dd><dt>Detector</dt><dd><p>  The implementation of the lint check which registers Issues, analyzes
  the code, and reports Incidents.

</p></dd><dt>Implementation</dt><dd><p>  An <code>Implementation</code> tells lint how a given issue is actually
  analyzed, such as which detector class to instantiate, as well as
  which scopes the detector applies to.

</p></dd><dt>Incident</dt><dd><p>  A specific occurrence of the issue at a specific location.
  An example of an incident is:
  </p><pre class="listing backtick"><code><span class="line"></span>    Warning: In file IoUtils.kt, line 140, the field download folder
<span class="line"></span>    is "/sdcard/downloads"; do not hardcode the path to `/sdcard`.</code></pre></dd><dt>Issue</dt><dd><p>  A type or class of problem that your lint check identifies. An issue
  has an associated severity (error, warning or info), a priority, a
  category, an explanation, and so on.

</p><p>

  An example of an issue is “Don't hardcode paths to /sdcard”.

</p></dd><dt>IssueRegistry</dt><dd><p>  An <code>IssueRegistry</code> provides a list of issues to lint. When you write
  one or more lint checks, you'll register these in an <code>IssueRegistry</code>
  and point to it using the <code>META-INF</code> service loader mechanism.

</p></dd><dt>LintClient</dt><dd><p>  The <code>LintClient</code> represents the specific tool the detector is running
  in. For example, when running in the IDE there is a LintClient which
  (when incidents are reported) will show highlights in the editor,
  whereas when lint is running as part of the Gradle plugin, incidents
  are instead accumulated into HTML (and XML and text) reports, and
  the build interrupted on error.

</p></dd><dt>Location</dt><dd><p>  A “location” refers to a place where an incident is reported.
  Typically this refers to a text range within a source file, but a
  location can also point to a binary file such as a <code>png</code> file.
  Locations can also be linked together, along with descriptions.
  Therefore, if you for example are reporting a duplicate declaration,
  you can include <strong class="asterisk">both</strong> Locations, and in the IDE, both locations
  (if they're in the same file) will be highlighted. A location linked
  from another is called a “secondary” location, but the chaining can
  be as long as you want (and lint's unit testing infrastructure will
  make sure there are no cycles.)

</p></dd><dt>Partial Analysis</dt><dd><p>  A “map reduce” architecture in lint which makes it possible to
  analyze individual modules in isolation and then later filter and
  customize the partial results based on conditions outside of these
  modules. This is explained in greater detail in the
  <a href="#partialanalysis">partial analysis</a> chapter.

</p></dd><dt>Platform</dt><dd><p>  The <code>Platform</code> abstraction allows lint issues to indicate where they
  apply (such as “Android”, or “Server”, and so on). This means that an
  Android-specific check won't trigger warnings on non-Android code.

</p></dd><dt>Scanner</dt><dd><p>  A <code>Scanner</code> is a particular interface a detector can implement to
  indicate that it supports a specific set of callbacks. For example,
  the <code>XmlScanner</code> interface is where the methods for visiting XML
  elements and attributes are defined, and the <code>ClassScanner</code> is where
  the ASM bytecode handling methods are defined, and so on.

</p></dd><dt>Scope</dt><dd><p>  <code>Scope</code> is an enum which lists various types of files that a detector
  may want to analyze.

</p><p>

  For example, there is a scope for XML files, there is a scope for
  Java and Kotlin files, there is a scope for .class files, and so on.

</p><p>

  Typically lint cares about which <strong class="asterisk">set</strong> of scopes apply,
  so most of the APIs take an <code>EnumSet&lt; Scope&gt;</code>, but we'll often
  refer to this as just “the scope” instead of the “scope set”.

</p></dd><dt>Severity</dt><dd><p>  For an issue, whether the incident should be an error, or just a
  warning, or neither (just an FYI highlight). There is also a special
  type of error severity, “fatal”, discussed later.

</p></dd><dt>TextFormat</dt><dd><p>  An enum describing various text formats lint understands. Lint checks
  will typically only operate with the “raw” format, which is
  markdown-like (e.g. you can surround words with an asterisk to make
  it italics or two to make it bold, and so on).

</p></dd><dt>Vendor</dt><dd><p>  A <code>Vendor</code> is a simple data class which provides information about
  the provenance of a lint check: who wrote it, where to file issues,
  and so on.

</p></dd></dl><p></p>
<a class="target" name="writingalintcheck:basics">&nbsp;</a><a class="target" name="writingalintcheck:basics">&nbsp;</a><a class="target" name="toc2">&nbsp;</a><h1>Writing a Lint Check: Basics</h1>

<a class="target" name="preliminaries">&nbsp;</a><a class="target" name="writingalintcheck:basics/preliminaries">&nbsp;</a><a class="target" name="toc2.1">&nbsp;</a><h2>Preliminaries</h2>
<p>


(If you already know a lot of the basics but you're here because you've
run into a problem and you're consulting the docs, take a look at the
<a href="#frequentlyaskedquestions">frequently asked questions</a> chapter.)

</p>
<a class="target" name="%E2%80%9Clint?%E2%80%9D">&nbsp;</a><a class="target" name="writingalintcheck:basics/preliminaries/%E2%80%9Clint?%E2%80%9D">&nbsp;</a><a class="target" name="toc2.1.1">&nbsp;</a><h3>“Lint?”</h3>
<p>


The <code>lint</code> tool shipped with the C compiler and provided additional
static analysis of C code beyond what the compiler checked.

</p><p>

Android Lint was named in honor of this tool, and with the Android
prefix to make it really clear that this is a static analysis tool
intended for analysis of Android code, provided by the Android Open
Source Project — and to disambiguate it from the many other tools with
“lint“ in their names.

</p><p>

However, since then, Android Lint has broadened its support and is no
longer intended only for Android code. In fact, within Google, it is
used to analyze all Java and Kotlin code. One of the reasons for this
is that it can easily analyze both Java and Kotlin code without having
to implement the checks twice. Additional features are described in the
<a href="api-guide/../features.html.md">features</a> chapter.

</p><p>

We're planning to rename lint to reflect this new role, so we are
looking for good name suggestions.

</p>
<a class="target" name="apistability">&nbsp;</a><a class="target" name="writingalintcheck:basics/preliminaries/apistability">&nbsp;</a><a class="target" name="toc2.1.2">&nbsp;</a><h3>API Stability</h3>
<p>


Lint's APIs are not stable, and a large part of Lint's API surface is
not under our control (such as UAST and PSI). Therefore, custom lint
checks may need to be updated periodically to keep working.

</p><p>

However, ”some APIs are more stable than others“. In particular, the
detector API (described below) is much less likely to change than the
client API (which is not intended for lint check authors but for tools
integrating lint to run within, such as IDEs and build systems).

</p><p>

However, this doesn't mean the detector API won't change. A large part
of the API surface is external to lint; it's the AST libraries (PSI and
UAST) for Java and Kotlin from JetBrains; it's the bytecode library
(asm.ow2.io), it's the XML DOM library (org.w3c.dom), and so on. Lint
intentionally stays up to date with these, so any API or behavior
changes in these can affect your lint checks.

</p><p>

Lint's own APIs may also change. The current API has grown organically
over the last 10 years (the first version of lint was released in 2011)
and there are a number of things we'd clean up and do differently if
starting over. Not to mention rename and clean up inconsistencies.

</p><p>

However, lint has been pretty widely adopted, so at this point creating
a nicer API would probably cause more harm than good, so we're limiting
recent changes to just the necessary ones. An example of this is the
new <a href="#partialanalysis">partial analysis</a> architecture in 7.0
which is there to allow much better CI and incremental analysis
performance.

</p>
<a class="target" name="kotlin">&nbsp;</a><a class="target" name="writingalintcheck:basics/preliminaries/kotlin">&nbsp;</a><a class="target" name="toc2.1.3">&nbsp;</a><h3>Kotlin</h3>
<p>


We recommend that you implement your checks in Kotlin. Part of
the reason for that is that the lint API uses a number of Kotlin
features:

</p><p>

</p><ul>
<li class="asterisk"><strong class="asterisk">Named and default parameters</strong>: Rather than using builders, some
  construction methods, like <code>Issue.create()</code> have a lot of parameters
  with default parameters. The API is cleaner to use if you just
  specify what you need and rely on defaults for everything else.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk">Compatibility</strong>: We may add additional parameters over time. It
  isn't practical to add @JvmOverloads on everything.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk">Package-level functions</strong>: Lint's API includes a number of package
  level utility functions (in previous versions of the API these are all
  thrown together in a <code>LintUtils</code> class).

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk">Deprecations</strong>: Kotlin has support for simple API migrations. For
  example, in the below example, the new <code>@Deprecated</code> annotation on
  lines 1 through 7 will be added in an upcoming release, to ease
  migration to a new API. IntelliJ can automatically quickfix these
  deprecation replacements.</li></ul>

<p></p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-meta">@Deprecated(
<span class="line"></span>    <span class="hljs-meta-string">"Use the new report(Incident) method instead, which is more future proof"</span>,
<span class="line"></span>    ReplaceWith(
<span class="line"></span>        <span class="hljs-meta-string">"report(Incident(issue, message, location, null, quickfixData))"</span>,
<span class="line"></span>        <span class="hljs-meta-string">"com.android.tools.lint.detector.api.Incident"</span>
<span class="line"></span>    )</span>
<span class="line"></span>)
<span class="line"></span><span class="hljs-meta">@JvmOverloads</span>
<span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">report</span><span class="hljs-params">(
<span class="line"></span>    issue: <span class="hljs-type">Issue</span>,
<span class="line"></span>    location: <span class="hljs-type">Location</span>,
<span class="line"></span>    message: <span class="hljs-type">String</span>,
<span class="line"></span>    quickfixData: <span class="hljs-type">LintFix</span>? = <span class="hljs-literal">null</span>
<span class="line"></span>)</span></span> {
<span class="line"></span>    <span class="hljs-comment">// ...</span>
<span class="line"></span>}</div></code></pre><p>

As of 7.0, there is more Kotlin code in lint than remaining Java
code:
</p><div class="table">
<table class="table"><tbody><tr><th style="text-align:left"> Language </th><th style="text-align:right"> files </th><th style="text-align:right"> blank </th><th style="text-align:right"> comment </th><th style="text-align:right"> code </th></tr>
<tr><td style="text-align:left"> Kotlin </td><td style="text-align:right"> 420 </td><td style="text-align:right"> 14243 </td><td style="text-align:right"> 23239 </td><td style="text-align:right"> 130250 </td></tr>
<tr><td style="text-align:left"> Java </td><td style="text-align:right"> 289 </td><td style="text-align:right"> 8683 </td><td style="text-align:right"> 15205 </td><td style="text-align:right"> 101549 </td></tr>
</tbody></table><center><div class="tablecaption"><code>$ cloc lint/</code></div></center></div>

<p></p><p>

And that's for all of lint, including many old lint detectors which
haven't been touched in years. In the Lint API library,
<code>lint/libs/lint-api</code>, the code is 78% Kotlin and 22% Java.

</p>
<a class="target" name="concepts">&nbsp;</a><a class="target" name="writingalintcheck:basics/concepts">&nbsp;</a><a class="target" name="toc2.2">&nbsp;</a><h2>Concepts</h2>
<p>


Lint will search your source code for problems. There are many types of
problems, and each one is called an <code>Issue</code>, which has associated
metadata like a unique id, a category, an explanation, and so on.

</p><p>

Each instance that it finds is called an ”incident“.

</p><p>

The actual responsibility of searching for and reporting incidents is
handled by detectors — subclasses of <code>Detector</code>. Your lint check will
extend <code>Detector</code>, and when it has found a problem, it will ”report“
the incident to lint.

</p><p>

A <code>Detector</code> can analyze more than one <code>Issue</code>. For example, the
built-in <code>StringFormatDetector</code> analyzes formatting strings passed to
<code>String.format()</code> calls, and in the process of doing that discovers
multiple unrelated issues — invalid formatting strings, formatting
strings which should probably use the plurals API instead, mismatched
types, and so on. The detector could simply have a single issue called
“StringFormatProblems” and report everything as a StringFormatProblem,
but that's not a good idea. Each of these individual types of String
format problems should have their own explanation, their own category,
their own severity, and most importantly should be individually
configurable by the user such that they can disable or promote one of
these issues separately from the others.

</p><p>

A <code>Detector</code> can indicate which sets of files it cares about. These are
called “scopes”, and the way this works is that when you register your
<code>Issue</code>, you tell that issue which <code>Detector</code> class is responsible for
analyzing it, as well as which scopes the detector cares about.

</p><p>

If for example a lint check wants to analyze Kotlin files, it can
include the <code>Scope.JAVA_FILE</code> scope, and now that detector will be
included when lint processes Java or Kotin files.

</p><p>

</p><div class="admonition tip">The name <code>Scope.JAVA_FILE</code> may make it sound like there should also
   be a <code>Scope.KOTLIN_FILE</code>. However, <code>JAVA_FILE</code> here really refers to
   both Java and Kotlin files since the analysis and APIs are identical
   for both (using “UAST”, a universal abstract syntax tree). However,
   at this point we don't want to rename it since it would break a lot
   of existing checks. We might introduce an alias and deprecate this
   one in the future.</div>

<p></p><p>

When detectors implement various callbacks, they can analyze the
code, and if they find a problematic pattern, they can “report”
the incident. This means computing an error message, as well as
a “location”. A “location” for an incident is really an error
range — a file, and a starting offset and an ending offset. Locations
can also be linked together, so for example for a “duplicate
declaration” error, you can and should include both locations.

</p><p>

Many detector methods will pass in a <code>Context</code>, or a more specific
subclass of <code>Context</code> such as <code>JavaContext</code> or <code>XmlContext</code>. This
allows lint to provide access to the detectors information they may
need, without passing in a lot of parameters (and allowing lint to add
additional data over time without breaking signatures).

</p><p>

The <code>Context</code> classes also provide many convenience APIs. For example,
for <code>XmlContext</code> there are methods for creating locations for XML tags,
XML attributes, just the name part of an XML attribute and just the
value part of an XML attribute. For a <code>JavaContext</code> there are also
methods for creating locations, such as for a method call, including
whether to include the receiver and/or the argument list.

</p><p>

When you report an <code>Incident</code> you can also provide a <code>LintFix</code>; this is
a quickfix which the IDE can use to offer actions to take on the
warning. In some cases, you can offer a complete and correct fix (such
as removing an unused element). In other cases the fix may be less
clear; for example, the <code>AccessibilityDetector</code> asks you to set a
description for images; the quickfix will set the content attribute,
but will leave the text value as TODO and will select the string such
that the user can just type to replace it.

</p><p>

</p><div class="admonition tip">When reporting incidents, make sure that the error messages are not
   generic; try to be explicit and include specifics for the current
   scenario. For example, instead of just “Duplicate declaration”, use
   “<code>$name</code> has already been declared”. This isn't just for cosmetics;
   it also makes lint's <a href="#baselines">baseline
   mechanism</a> work better since it
   currently matches by id + file + message, not by line numbers which
   typically drift over time.</div>

<p></p>
<a class="target" name="clientapiversusdetectorapi">&nbsp;</a><a class="target" name="writingalintcheck:basics/clientapiversusdetectorapi">&nbsp;</a><a class="target" name="toc2.3">&nbsp;</a><h2>Client API versus Detector API</h2>
<p>


Lint's API has two halves:

</p><p>

</p><ul>
<li class="minus">The <strong class="asterisk">Client API</strong>: “Integrate (and run) lint from within a tool”.
  For example, both the IDE and the build system uses this API to embed
  and invoke lint to analyze the code in the project or editor.

<p></p><p>

</p></li>
<li class="minus">The <strong class="asterisk">Detector API</strong>: “Implement a new lint check”. This is the API
  which lets checkers analyze code and report problems that they find.</li></ul>

<p></p><p>

The class in the Client API which represents lint running in a tool is
called <code>LintClient</code>. This class is responsible for, among other things:

</p><p>

</p><ul>
<li class="asterisk">Reporting incidents found by detectors. For example, in the IDE, it
  will place error markers into the source editor, and in a build
  system, it may write warnings to the console or generate a report or
  even fail the build.

<p></p><p>

</p></li>
<li class="asterisk">Handling I/O. Detectors should never read files from disk directly.
  This allows lint checks to work smoothly in for example the IDE. When
  lint runs on the fly, and a lint check asks for the source file
  contents (or other supporting files), the <code>LintClient</code> in the IDE
  will implement the <code>readFile</code> method to first look in the open source
  editors and if the requested file is being edited, it will return the
  current (often unsaved!) contents.

<p></p><p>

</p></li>
<li class="asterisk">Handling network traffic. Lint checks should never open
  URLConnections themselves. By going through the lint API to request
  data for a URL, not only can the LintClient for example use any
  configured IDE proxy settings which is done in the IntelliJ
  integration of lint, but even the lint check's own unit tests can
  easily be tested because the special unit test implementation of a
  <code>LintClient</code> provides a simple way to provide exact responses for
  specific URLs:</li></ul>

<p></p><pre class="listing tilde"><code><span class="line"></span>lint()
<span class="line"></span>  .files(...)
<span class="line"></span>  // Set up exactly the expected maven.google.com network output to
<span class="line"></span>  // ensure stable version suggestions in the tests
<span class="line"></span>  .networkData("https://maven.google.com/master-index.xml", ""
<span class="line"></span>       + "<span class="hljs-comment">&lt;!--?xml version='1.0' encoding='UTF-8'?--&gt;</span>\n"
<span class="line"></span>       + "<span class="hljs-tag">&lt;<span class="hljs-name">metadata</span>&gt;</span>\n"
<span class="line"></span>       + "  <span class="hljs-tag">&lt;<span class="hljs-name">com.android.tools.build</span>&gt;</span>"
<span class="line"></span>       + "<span class="hljs-tag">&lt;/<span class="hljs-name">com.android.tools.build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">metadata</span>&gt;</span>")
<span class="line"></span>  .networkData("https://maven.google.com/com/android/tools/build/group-index.xml", ""
<span class="line"></span>       + "<span class="hljs-comment">&lt;!--?xml version='1.0' encoding='UTF-8'?--&gt;</span>\n"
<span class="line"></span>       + "<span class="hljs-tag">&lt;<span class="hljs-name">com.android.tools.build</span>&gt;</span>\n"
<span class="line"></span>       + "  <span class="hljs-tag">&lt;<span class="hljs-name">gradle</span> <span class="hljs-attr">versions</span>=<span class="hljs-string">"\"</span><span class="hljs-attr">2.3.3</span>,<span class="hljs-attr">3.0.0-alpha1</span>\"/"&gt;</span>\n"
<span class="line"></span>       + "<span class="hljs-tag">&lt;/<span class="hljs-name">gradle</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com.android.tools.build</span>&gt;</span>")
<span class="line"></span>.run()
<span class="line"></span>.expect(...)</code></pre><p>

And much, much, more. <strong class="asterisk">However, most of the implementation of
<code>LintClient</code> is intended for integration of lint itself, and as a check
author you don't need to worry about it.</strong> It's the detector API that
matters, and is also less likely to change than the client API.

</p><p>

</p><div class="admonition tip">The division between the two halves is not perfect; some classes
   do not fit neatly in between the two or historically were put in
   the wrong place, so this is a high level design to be aware of but
   which is not absolute.</div>

<p></p><p>

Also,

</p><p>

</p><div class="admonition warning">Because of the division between two separate packages, which in
   retrospect was a mistake, a number of APIs that are only intended
   for internal lint usage have been made <code>public</code> such that lint's
   code in one package can access it from the other. There's normally a
   comment explaining that this is for internal use only, but be aware
   that just because something is <code>public</code> or not <code>final</code> it's a good
   idea to call or override it.</div>

<p></p>
<a class="target" name="creatinganissue">&nbsp;</a><a class="target" name="writingalintcheck:basics/creatinganissue">&nbsp;</a><a class="target" name="toc2.4">&nbsp;</a><h2>Creating an Issue</h2>
<p>


For information on how to set up the project and to actually publish
your lint checks, see the <a href="#example:samplelintcheckgithubproject">sample</a> and
<a href="#publishingalintcheck">publishing</a> chapters.

</p><p>

<code>Issue</code> is a final class, so unlike <code>Detector</code>, you don't subclass
it, you instantiate it via <code>Issue.create</code>.

</p><p>

By convention, issues are registered inside the companion object of the
corresponding detector, but that is not required.

</p><p>

Here's an example:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SdCardDetector</span> : <span class="hljs-type">Detector</span></span>(), SourceCodeScanner {
<span class="line"></span>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Issues {
<span class="line"></span>        <span class="hljs-meta">@JvmField</span>
<span class="line"></span>        <span class="hljs-keyword">val</span> ISSUE = Issue.create(
<span class="line"></span>            id = <span class="hljs-string">"SdCardPath"</span>,
<span class="line"></span>            briefDescription = <span class="hljs-string">"Hardcoded reference to `/sdcard`"</span>,
<span class="line"></span>            explanation = <span class="hljs-string">"""
<span class="line"></span>                Your code should not reference the `/sdcard` path directly; \
<span class="line"></span>                instead use `Environment.getExternalStorageDirectory().getPath()`.
<span class="line"></span>
<span class="line"></span>                Similarly, do not reference the `/data/data/` path directly; it \
<span class="line"></span>                can vary in multi-user scenarios. Instead, use \
<span class="line"></span>                `Context.getFilesDir().getPath()`.
<span class="line"></span>                """</span>,
<span class="line"></span>            moreInfo = <span class="hljs-string">"https://developer.android.com/training/data-storage#filesExternal"</span>,
<span class="line"></span>            category = Category.CORRECTNESS,
<span class="line"></span>            severity = Severity.WARNING,
<span class="line"></span>            androidSpecific = <span class="hljs-literal">true</span>,
<span class="line"></span>            implementation = Implementation(
<span class="line"></span>                SdCardDetector::<span class="hljs-keyword">class</span>.java,
<span class="line"></span>                Scope.JAVA_FILE_SCOPE
<span class="line"></span>            )
<span class="line"></span>        )
<span class="line"></span>    }
<span class="line"></span>    ...</div></code></pre><p>

There are a number of things to note here.

</p><p>

On line 4, we have the <code>Issue.create()</code> call. We store the issue into a
property such that we can reference this issue both from the
<code>IssueRegistry</code>, where we provide the <code>Issue</code> to lint, and also in the
<code>Detector</code> code where we report incidents of the issue.

</p><p>

Note that <code>Issue.create</code> is a method with a lot of parameters (and we
will probably add more parameters in the future). Therefore, it's a
good practice to explicitly include the argument names (and therefore
to implement your code in Kotlin).

</p><p>

The <code>Issue</code> provides metadata about a type of problem.

</p><p>

The <strong class="asterisk"><code>id</code></strong> is a short, unique identifier for this issue. By
convention it is a combination of words, capitalized camel case (though
you can also add your own package prefix as in Java packages). Note
that the id is “user visible”; it is included in text output when lint
runs in the build system, such as this:

</p><pre class="listing backtick"><code><span class="line"></span>src/main/kotlin/test/pkg/MyTest.kt:4: Warning: Do not hardcode "/sdcard/";
<span class="line"></span>      use Environment.getExternalStorageDirectory().getPath() instead [SdCardPath]
<span class="line"></span>    val s: String = "/sdcard/mydir"
<span class="line"></span>                     -------------
<span class="line"></span>0 errors, 1 warnings</code></pre><p>

(Notice the <code>[SdCardPath]</code> suffix at the end of the error message.)

</p><p>

The reason the id is made known to the user is that the ID is how
they'll configure and/or suppress issues. For example, to suppress the
warning in the current method, use

</p><pre class="listing backtick"><code><span class="line"></span><span class="hljs-meta">@Suppress(<span class="hljs-params"><span class="hljs-string">"SdCardPath"</span></span>)</span></code></pre><p>

(or in Java, @SuppressWarnings). Note that there is an IDE quickfix to
suppress an incident which will automatically add these annotations, so
you don't need to know the ID in order to be able to suppress an
incident, but the ID will be visible in the annotation that it
generates, so it should be reasonably specific.

</p><p>

Also, since the namespace is global, try to avoid picking generic names
that could clash with others, or seem to cover a larger set of issues
than intended. For example, “InvalidDeclaration” would be a poor id
since that can cover a lot of potential problems with declarations
across a number of languages and technologies.

</p><p>

Next, we have the <strong class="asterisk"><code>briefDescription</code></strong>. You can think of this as a
“category report header“; this is a static description for all
incidents of this type, so it cannot include any specifics. This string
is used for example as a header in HTML reports for all incidents of
this type, and in the IDE, if you open the Inspections UI, the various
issues are listed there using the brief descriptions.

</p><p>

The <strong class="asterisk"><code>explanation</code></strong> is a multi line, ideally multi-paragraph
explanation of what the problem is. In some cases, the problem is self
evident, as in the case of ”Unused declaration“, but in many cases, the
issue is more subtle and might require additional explanation,
particularly for what the developer should <strong class="asterisk">do</strong> to address the
problem. The explanation is included both in HTML reports and in the
IDE inspection results window.

</p><p>

Note that even though we're using a raw string, and even though the
string is indented to be flush with the rest of the issue registration
for better readability, we don't need to call <code>trimIndent()</code> on
the raw string. Lint does that automatically.

</p><p>

However, we do need to add line continuations — those are the trailing
\'s at the end of the lines.

</p><p>

Note also that we have a Markdown-like simple syntax, described in the
“TextFormat” section below. You can use asterisks for italics or double
asterisks for bold, you can use apostrophes for code font, and so on.
In terminal output this doesn't make a difference, but the IDE,
explanations, incident error messages, etc, are all formatted using
these styles.

</p><p>

The <strong class="asterisk"><code>category</code></strong> isn't super important; the main use is that category
names can be treated as id's when it comes to issue configuration; for
example, a user can turn off all internationalization issues, or run
lint against only the security related issues. The category is also
used for locating related issues in HTML reports. If none of the
built-in categories are appropriate you can also create your own.

</p><p>

The <strong class="asterisk"><code>severity</code></strong> property is very important. An issue can be either a
warning or an error. These are treated differently in the IDE (where
errors are red underlines and warnings are yellow highlights), and in
the build system (where errors can optionally break the build and
warnings do not). There are some other severities too; ”fatal“ is like
error except these checks are designated important enough (and have
very few false positives) such that we run them during release builds,
even if the user hasn't explicitly run a lint target. There's also
“informational” severity, which is only used in one or two places, and
finally the “ignore” severity. This is never the severity you register
for an issue, but it's part of the severities a developer can configure
for a particular issue, thereby turning off that particular check.

</p><p>

You can also specify a <strong class="asterisk"><code>moreInfo</code></strong> URL which will be included in the
issue explanation as a “More Info” link to open to read more details
about this issue or underlying problem.

</p>
<a class="target" name="textformat">&nbsp;</a><a class="target" name="writingalintcheck:basics/textformat">&nbsp;</a><a class="target" name="toc2.5">&nbsp;</a><h2>TextFormat</h2>
<p>


All error messages and issue metadata strings in lint are interpreted
using simple Markdown-like syntax:
</p><div class="table">
<table class="table"><tbody><tr><th style="text-align:left"> Raw text format </th><th style="text-align:left"> Renders To </th></tr>
<tr><td style="text-align:left"> This is a `code symbol` </td><td style="text-align:left"> This is a <code>code symbol</code> </td></tr>
<tr><td style="text-align:left"> This is <code>*italics*</code> </td><td style="text-align:left"> This is <em class="asterisk">italics</em> </td></tr>
<tr><td style="text-align:left"> This is <code>**bold**</code> </td><td style="text-align:left"> This is <strong class="asterisk">bold</strong> </td></tr>
<tr><td style="text-align:left"> <a href="http://," class="url">http://,</a> <a href="https:// " class="url">https:// </a></td><td style="text-align:left"> <a href="http://"></a><a href="http://</a" class="url">http://, </a><a href="https://"></a><a href="https://</a" class="url">https:// </a></td></tr>
<tr><td style="text-align:left"> <code>\*not italics*</code> </td><td style="text-align:left"> <code>\*not italics*</code> </td></tr>
<tr><td style="text-align:left"> ```language\n text\n``` </td><td style="text-align:left"> (preformatted text block) </td></tr>
</tbody></table><center><div class="tablecaption">Supported markup in lint's markdown-like raw text format</div></center></div>

<p></p><p>

This is useful when error messages and issue explanations are shown in
HTML reports generated by Lint, or in the IDE, where for example the
error message tooltips will use formatting.

</p><p>

In the API, there is a <code>TextFormat</code> enum which encapsulates the
different text formats, and the above syntax is referred to as
<code>TextFormat.RAW</code>; it can be converted to <code>.TEXT</code> or <code>.HTML</code> for
example, which lint does when writing text reports to the console or
HTML reports to files respectively. As a lint check author you don't
need to know this (though you can for example with the unit testing
support decide which format you want to compare against in your
expected output), but the main point here is that your issue's brief
description, issue explanation, incident report messages etc, should
use the above “raw” syntax. Especially the first conversion; error
messages often refer to class names and method names, and these should
be surrounded by apostrophes.

</p><p>

See the <a href="#errormessageconventions">error message</a> chapter for more information
on how to craft error messages.

</p>
<a class="target" name="issueimplementation">&nbsp;</a><a class="target" name="writingalintcheck:basics/issueimplementation">&nbsp;</a><a class="target" name="toc2.6">&nbsp;</a><h2>Issue Implementation</h2>
<p>


The last issue registration property is the <strong class="asterisk"><code>implementation</code></strong>. This
is where we glue our metadata to our specific implementation of an
analyzer which can find instances of this issue.

</p><p>

Normally, the <code>Implementation</code> provides two things:

</p><p>

</p><ul>
<li class="asterisk">The <code>.class</code> for our <code>Detector</code> which should be instantiated. In the
  code sample above it was <code>SdCardDetector</code>.

<p></p><p>

</p></li>
<li class="asterisk">The <code>Scope</code> that this issue's detector applies to. In the above
  example it was <code>Scope.JAVA_FILE</code>, which means it will apply to Java
  and Kotlin files.</li></ul>

<p></p>
<a class="target" name="scopes">&nbsp;</a><a class="target" name="writingalintcheck:basics/scopes">&nbsp;</a><a class="target" name="toc2.7">&nbsp;</a><h2>Scopes</h2>
<p>


The <code>Implementation</code> actually takes a <strong class="asterisk">set</strong> of scopes; we still refer
to this as a “scope”. Some lint checks want to analyze multiple types
of files. For example, the <code>StringFormatDetector</code> will analyze both the
resource files declaring the formatting strings across various locales,
as well as the Java and Kotlin files containing <code>String.format</code> calls
referencing the formatting strings.

</p><p>

There are a number of pre-defined sets of scopes in the <code>Scope</code>
class. <code>Scope.JAVA_FILE_SCOPE</code> is the most common, which is a
singleton set containing exactly <code>Scope.JAVA_FILE</code>, but you
can always create your own, such as for example
</p><pre class="listing backtick"><code><span class="line"></span>    <span class="hljs-selector-tag">EnumSet</span><span class="hljs-selector-class">.of</span>(Scope.CLASS_FILE, Scope.JAVA_LIBRARIES)</code></pre><p>

When a lint issue requires multiple scopes, that means lint will
<strong class="asterisk">only</strong> run this detector if <strong class="asterisk">all</strong> the scopes are available in the
running tool. When lint runs a full batch run (such as a Gradle lint
target or a full “Inspect Code“ in the IDE), all scopes are available.

</p><p>

However, when lint runs on the fly in the editor, it only has access to
the current file; it won't re-analyze <em class="asterisk">all</em> files in the project for
every few keystrokes. So in this case, the scope in the lint driver
only includes the current source file's type, and only lint checks
which specify a scope that is a subset would run.

</p><p>

This is a common mistake for new lint check authors: the lint check
works just fine as a unit test, but they don't see working in the IDE
because the issue implementation requests multiple scopes, and <strong class="asterisk">all</strong>
have to be available.

</p><p>

Often, a lint check looks at multiple source file types to work
correctly in all cases, but it can still identify <em class="asterisk">some</em> problems given
individual source files. In this case, the <code>Implementation</code> constructor
(which takes a vararg of scope sets) can be handed additional sets of
scopes, called ”analysis scopes“. If the current lint client's scope
matches or is a subset of any of the analysis scopes, then the check
will run after all.

</p>
<a class="target" name="registeringtheissue">&nbsp;</a><a class="target" name="writingalintcheck:basics/registeringtheissue">&nbsp;</a><a class="target" name="toc2.8">&nbsp;</a><h2>Registering the Issue</h2>
<p>


Once you've created your issue, you need to provide it from
an <code>IssueRegistry</code>.

</p><p>

Here's an example <code>IssueRegistry</code>:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">package</span> com.example.lint.checks
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.client.api.IssueRegistry
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.client.api.Vendor
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.CURRENT_API
<span class="line"></span>
<span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleIssueRegistry</span> : <span class="hljs-type">IssueRegistry</span></span>() {
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> issues = listOf(SdCardDetector.ISSUE)
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> api: <span class="hljs-built_in">Int</span>
<span class="line"></span>        <span class="hljs-keyword">get</span>() = CURRENT_API
<span class="line"></span>
<span class="line"></span>    <span class="hljs-comment">// works with Studio 4.1 or later; see</span>
<span class="line"></span>    <span class="hljs-comment">// com.android.tools.lint.detector.api.Api / ApiKt</span>
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> minApi: <span class="hljs-built_in">Int</span>
<span class="line"></span>        <span class="hljs-keyword">get</span>() = <span class="hljs-number">8</span>
<span class="line"></span>
<span class="line"></span>    <span class="hljs-comment">// Requires lint API 30.0+; if you're still building for something</span>
<span class="line"></span>    <span class="hljs-comment">// older, just remove this property.</span>
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> vendor: Vendor = Vendor(
<span class="line"></span>        vendorName = <span class="hljs-string">"Android Open Source Project"</span>,
<span class="line"></span>        feedbackUrl = <span class="hljs-string">"https://com.example.lint.blah.blah"</span>,
<span class="line"></span>        contact = <span class="hljs-string">"author@com.example.lint"</span>
<span class="line"></span>    )
<span class="line"></span>}</div></code></pre><p>

On line 8, we're returning our issue. It's a list, so an
<code>IssueRegistry</code> can provide multiple issues.

</p><p>

The <strong class="asterisk"><code>api</code></strong> property should be written exactly like the way it
appears above in your own issue registry as well; this will record
which version of the lint API this issue registry was compiled against
(because this references a static final constant which will be copied
into the jar file instead of looked up dynamically when the jar is
loaded).

</p><p>

The <strong class="asterisk"><code>minApi</code></strong> property records the oldest lint API level this check
has been tested with.

</p><p>

Both of these are used at issue loading time to make sure lint checks
are compatible, but in recent versions of lint (7.0) lint will more
aggressively try to load older detectors even if they have been
compiled against older APIs since there's a high likelihood that they
will work (it checks all the lint APIs in the bytecode and uses
reflection to verify that they're still there).

</p><p>

The <strong class="asterisk"><code>vendor</code></strong> property is new as of 7.0, and gives lint authors a
way to indicate where the lint check came from. When users use lint,
they're running hundreds and hundreds of checks, and sometimes it's not
clear who to contact with requests or bug reports. When a vendor has
been specified, lint will include this information in error output and
reports.

</p><p>

The last step towards making the lint check available is to make
the <code>IssueRegistry</code> known via the service loader mechanism.

</p><p>

Create a file named exactly
</p><pre class="listing backtick"><code><span class="line"></span><span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">main</span>/<span class="hljs-selector-tag">resources</span>/<span class="hljs-selector-tag">META-INF</span>/<span class="hljs-selector-tag">services</span>/<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.lint</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.IssueRegistry</span></code></pre><p>

with the following contents (but where you substitute in your own
fully qualified class name for your issue registry):

</p><pre class="listing backtick"><code><span class="line"></span><span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.lint</span><span class="hljs-selector-class">.checks</span><span class="hljs-selector-class">.SampleIssueRegistry</span></code></pre><p>

If you're not building your lint check using Gradle, you may not want
the <code>src/main/resources</code> prefix; the point is that your packaging of
the jar file should contain <code>META-INF/services/</code> at the root of the jar
file.

</p>
<a class="target" name="implementingadetector:scanners">&nbsp;</a><a class="target" name="writingalintcheck:basics/implementingadetector:scanners">&nbsp;</a><a class="target" name="toc2.9">&nbsp;</a><h2>Implementing a Detector: Scanners</h2>
<p>


We've finally come to the main task with writing a lint check:
implementing the <strong class="asterisk"><code>Detector</code></strong>.

</p><p>

Here's a trivial one:
</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDetector</span> : <span class="hljs-type">Detector</span></span>() {
<span class="line"></span>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> {
<span class="line"></span>       context.report(ISSUE, Location.create(context.file),
<span class="line"></span>           <span class="hljs-string">"I complain a lot"</span>)
<span class="line"></span>   }
<span class="line"></span>}</div></code></pre><p>

This will just complain in every single file. Obviously, no real lint
detector does this; we want to do some analysis and <strong class="asterisk">conditionally</strong> report
incidents. For information about how to phrase error messages, see the <a href="#errormessageconventions">error
message</a> chapter.

</p><p>

In order to make it simpler to perform analysis, Lint has dedicated
support for analyzing various file types. The way this works is that
you register interest, and then various callbacks will be invoked.

</p><p>

For example:

</p><p>

</p><ul>
<li class="asterisk">When implementing <strong class="asterisk"><code>XmlScanner</code></strong>, in an XML element you can be
  called back
<ul>
  <li class="minus">when any of a set of given tags are declared  (<code>visitElement</code>)
</li>
  <li class="minus">when any of a set of named attributes are declared
      (<code>visitAttribute</code>)
</li>
  <li class="minus">and you can perform your own document traversal via <code>visitDocument</code>

<p></p><p>

</p></li></ul>
</li><li class="asterisk">When implementing <strong class="asterisk"><code>SourceCodeScanner</code></strong>, in Kotlin and Java files
  you can be called back
<ul>
  <li class="minus">When a method of a given name is invoked (<code>getApplicableMethodNames</code>
      and <code>visitMethodCall</code>)
</li>
  <li class="minus">When a class of the given type is instantiated
      (<code>getApplicableConstructorTypes</code> and <code>visitConstructor</code>)
</li>
  <li class="minus">When a new class is declared which extends (possibly indirectly)
      a given class or interface (<code>applicableSuperClasses</code> and
      <code>visitClass</code>)
</li>
  <li class="minus">When annotated elements are referenced or combined
      (<code>applicableAnnotations</code> and <code>visitAnnotationUsage</code>)
</li>
  <li class="minus">When any AST nodes of given types appear (<code>getApplicableUastTypes</code>
      and <code>createUastHandler</code>)

<p></p><p>

</p></li></ul>
</li><li class="asterisk">When implementing a <strong class="asterisk"><code>ClassScanner</code></strong>, in <code>.class</code> and <code>.jar</code> files
  you can be called back
<ul>
  <li class="minus">when a method is invoked for a particular owner
      (<code>getApplicableCallOwners</code> and <code>checkCall</code>
</li>
  <li class="minus">when a given bytecode instruction occurs
      (<code>getApplicableAsmNodeTypes</code> and <code>checkInstruction</code>)
</li>
  <li class="minus">like with XmlScanner's <code>visitDocument</code>, you can perform your own
      ASM bytecode iteration via <code>checkClass</code>.

<p></p><p>

</p></li></ul>
</li><li class="asterisk">There are various other scanners too, for example <code>GradleScanner</code>
  which lets you visit <code>build.gradle</code> and <code>build.gradle.kts</code> DSL
  closures, <code>BinaryFileScanner</code> which visits resource files such as
  webp and png files, and <code>OtherFileScanner</code> which lets you visit
  unknown files.</li></ul>

<p></p><p>

</p><div class="admonition note">Note that <code>Detector</code> already implements empty stub methods for all
   of these interfaces, so if you for example implement
   <code>SourceFileScanner</code> in your detector, you don't need to go and add
   empty implementations for all the methods you aren't using.</div>

<p></p><p>

</p><div class="admonition tip">None of Lint's APIs require you to call <code>super</code> when you override
   methods; methods meant to be overridden are always empty so the
   super-call is superfluous.</div>

<p></p>
<a class="target" name="detectorlifecycle">&nbsp;</a><a class="target" name="writingalintcheck:basics/detectorlifecycle">&nbsp;</a><a class="target" name="toc2.10">&nbsp;</a><h2>Detector Lifecycle</h2>
<p>


Detector registration is done by detector class, not by detector
instance. Lint will instantiate detectors on your behalf. It will
instantiate the detector once per analysis, so you can stash state on
the detector in fields and accumulate information for analysis at the
end.

</p><p>

There are some callbacks both before each individual file is analyzed
(<code>beforeCheckFile</code> and <code>afterCheckFile</code>), as well as before and after
analysis of all the modules (<code>beforeCheckRootProject</code> and
<code>afterCheckRootProject</code>).

</p><p>

This is for example how the ”unused resources“ check works: we store
all the resource declarations and resource references we find in the
project as we process each file, and then in the
<code>afterCheckRootProject</code> method we analyze the resource graph and
compute any resource declarations that are not reachable in the
reference graph, and then we report each of these as unused.

</p>
<a class="target" name="scannerorder">&nbsp;</a><a class="target" name="writingalintcheck:basics/scannerorder">&nbsp;</a><a class="target" name="toc2.11">&nbsp;</a><h2>Scanner Order</h2>
<p>


Some lint checks involve multiple scanners. This is pretty common in
Android, where we want to cross check consistency between data in
resource files with the code usages. For example, the <code>String.format</code>
check makes sure that the arguments passed to <code>String.format</code> match the
formatting strings specified in all the translation XML files.

</p><p>

Lint defines an exact order in which it processes scanners, and within
scanners, data. This makes it possible to write some detectors more
easily because you know that you'll encounter one type of data before
the other; you don't have to handle the opposite order. For example, in
our <code>String.format</code> example, we know that we'll always see the
formatting strings before we see the code with <code>String.format</code> calls,
so we can stash the formatting strings in a map, and when we process
the formatting calls in code, we can immediately issue reports; we
don't have to worry about encountering a formatting call for a
formatting string we haven't processed yet.

</p><p>

Here's lint's defined order:

</p><p>

</p><ol start="1">
<li class="number">Android Manifest
</li>
<li class="number">Android resources XML files (alphabetical by folder type, so for
   example layouts are processed before value files like translations)
</li>
<li class="number">Kotlin and Java files
</li>
<li class="number">Bytecode (local <code>.class</code> files and library <code>.jar</code> files)
</li>
<li class="number">Gradle files
</li>
<li class="number">Other files
</li>
<li class="number">ProGuard files
</li>
<li class="number">Property Files</li></ol>

<p></p><p>

Similarly, lint will always process libraries before the modules
that depend on them.

</p><p>

</p><div class="admonition tip">If you need to access something from later in the iteration order,
   and it's not practical to store all the current data and instead
   handle it when the later data is encountered, note that lint has
   support for ”multi-pass analysis“: it can run multiple times over
   the data. The way you invoke this is via
   <code>context.driver.requestRepeat(this, …)</code>. This is actually how the
   unused resource analysis works. Note however that this repeat is
   only valid within the current module; you can't re-run the analysis
   through the whole dependency graph.</div>

<p></p>
<a class="target" name="implementingadetector:services">&nbsp;</a><a class="target" name="writingalintcheck:basics/implementingadetector:services">&nbsp;</a><a class="target" name="toc2.12">&nbsp;</a><h2>Implementing a Detector: Services</h2>
<p>


In addition to the scanners, lint provides a number of services
to make implementation simpler. These include

</p><p>

</p><ul>
<li class="asterisk"><strong class="asterisk"><code>ConstantEvaluator</code></strong>: Performs evaluation of AST expressions, so
  for example if we have the statements <code>x = 5; y = 2 * x</code>, the
  constant evaluator can tell you that y is 10. This constant evaluator
  can also be more permissive than a compiler's strict constant
  evaluator; e.g. it can return concatenated strings where not all
  parts are known, or it can use non-final initial values of fields.
  This can help you find <em class="asterisk">possible</em> bugs instead of <em class="asterisk">certain</em> bugs.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk"><code>TypeEvaluator</code></strong>: Attempts to provide the concrete type of an
  expression. For example, for the Java statements <code>Object s = new
  StringBuilder(); Object o = s</code>, the type evaluator can tell you that
  the type of <code>o</code> at this point is really <code>StringBuilder</code>.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk"><code>JavaEvaluator</code></strong>: Despite the unfortunate older name, this service
  applies to both Kotlin and Java, and can for example provide
  information about inheritance hierarchies, class lookup from fully
  qualified names, etc.

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk"><code>DataFlowAnalyzer</code></strong>: Data flow analysis within a method.

<p></p><p>

</p></li>
<li class="asterisk">For Android analysis, there are several other important services,
  like the <code>ResourceRepository</code> and the <code>ResourceEvaluator</code>.

<p></p><p>

</p></li>
<li class="asterisk">Finally, there are a number of utility methods; for example there is
  an <code>editDistance</code> method used to find likely typos used by a number
  of checks.</li></ul>

<p></p>
<a class="target" name="scannerexample">&nbsp;</a><a class="target" name="writingalintcheck:basics/scannerexample">&nbsp;</a><a class="target" name="toc2.13">&nbsp;</a><h2>Scanner Example</h2>
<p>


Let's create a <code>Detector</code> using one of the above scanners,
<code>XmlScanner</code>, which will look at all the XML files in the project and
if it encounters a <code>&lt;bitmap&gt;</code> tag it will report that <code>&lt;vector&gt;</code> should
be used instead:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Detector
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Detector.XmlScanner
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Location
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.XmlContext
<span class="line"></span><span class="hljs-keyword">import</span> org.w3c.dom.Element
<span class="line"></span>
<span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDetector</span> : <span class="hljs-type">Detector</span></span>(), XmlScanner {
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableElements</span><span class="hljs-params">()</span></span> = listOf(<span class="hljs-string">"bitmap"</span>)
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitElement</span><span class="hljs-params">(context: <span class="hljs-type">XmlContext</span>, element: <span class="hljs-type">Element</span>)</span></span> {
<span class="line"></span>        <span class="hljs-keyword">val</span> incident = Incident(context, ISSUE)
<span class="line"></span>            .message( <span class="hljs-string">"Use `&lt;vector&gt;` instead of `&lt;bitmap&gt;`"</span>)
<span class="line"></span>            .at(element)
<span class="line"></span>        context.report(incident)
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

The above is using the new <code>Incident</code> API from Lint 7.0 and on; in
older versions you can use the following API, which still works in 7.0:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDetector</span> : <span class="hljs-type">Detector</span></span>(), XmlScanner {
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableElements</span><span class="hljs-params">()</span></span> = listOf(<span class="hljs-string">"bitmap"</span>)
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitElement</span><span class="hljs-params">(context: <span class="hljs-type">XmlContext</span>, element: <span class="hljs-type">Element</span>)</span></span> {
<span class="line"></span>        context.report(ISSUE, context.getLocation(element),
<span class="line"></span>            <span class="hljs-string">"Use `&lt;vector&gt;` instead of `&lt;bitmap&gt;`"</span>)
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

The second, older form, may seem simpler, but the new API allows a lot
more metadata to be attached to the report, such as an override
severity. You don't have to convert to the builder syntax to do this;
you could also have written the second form as

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span>context.report(Incident(ISSUE, context.getLocation(element),
<span class="line"></span>    <span class="hljs-string">"Use `&lt;vector&gt;` instead of `&lt;bitmap&gt;`"</span>))</div></code></pre>
<a class="target" name="analyzingkotlinandjavacode">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode">&nbsp;</a><a class="target" name="toc2.14">&nbsp;</a><h2>Analyzing Kotlin and Java Code</h2>

<a class="target" name="uast">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/uast">&nbsp;</a><a class="target" name="toc2.14.1">&nbsp;</a><h3>UAST</h3>
<p>


To analyze Kotlin and Java code, lint offers an abstract syntax tree,
or ”AST“, for the code.

</p><p>

This AST is called ”UAST“, for ”Universal Abstract Syntax Tree“, which
represents multiple languages in the same way, hiding the language
specific details like whether there is a semicolon at the end of the
statements or whether the way an annotation class is declared is as
<code>@interface</code> or <code>annotation class</code>, and so on.

</p><p>

This makes it possible to write a single analyzer which works
(”universally“) across all languages supported by UAST. And this is
very useful; most lint checks are doing something API or data-flow
specific, not something language specific. If however you do need to
implement something very language specific, see the next section,
“PSI”.

</p><p>

In UAST, each element is called a <strong class="asterisk"><code>UElement</code></strong>, and there are a
number of subclasses — <code>UFile</code> for the compilation unit, <code>UClass</code> for
a class, <code>UMethod</code> for a method, <code>UExpression</code> for an expression,
<code>UIfExpression</code> for an <code>if</code>-expression, and so on.

</p><p>

Here's a visualization of an AST in UAST for two equivalent programs
written in Kotlin and Java. These programs both result in the same
AST, shown on the right: a <code>UFile</code> compilation unit, containing
a <code>UClass</code> named <code>MyTest</code>, containing <code>UField</code> named s which has
an initializer setting the initial value to <code>hello</code>.

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="352" width="568" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 8,32 L 8,112 " style="fill:none;"></path>
<path d="M 8,160 L 8,256 " style="fill:none;"></path>
<path d="M 208,160 L 208,256 " style="fill:none;"></path>
<path d="M 232,32 L 232,112 " style="fill:none;"></path>
<path d="M 344,64 L 344,96 " style="fill:none;"></path>
<path d="M 344,128 L 344,160 " style="fill:none;"></path>
<path d="M 8,32 L 232,32 " style="fill:none;"></path>
<path d="M 320,32 L 368,32 " style="fill:none;"></path>
<path d="M 320,64 L 368,64 " style="fill:none;"></path>
<path d="M 296,96 L 392,96 " style="fill:none;"></path>
<path d="M 8,112 L 232,112 " style="fill:none;"></path>
<path d="M 296,128 L 392,128 " style="fill:none;"></path>
<path d="M 8,160 L 208,160 " style="fill:none;"></path>
<path d="M 320,160 L 376,160 " style="fill:none;"></path>
<path d="M 320,192 L 376,192 " style="fill:none;"></path>
<path d="M 8,256 L 208,256 " style="fill:none;"></path>
<path d="M 192,272 L 280,272 " style="fill:none;"></path>
<path d="M 352,272 L 536,272 " style="fill:none;"></path>
<path d="M 192,304 L 280,304 " style="fill:none;"></path>
<path d="M 352,304 L 536,304 " style="fill:none;"></path>
<path d="M 376,192 L 416,272 " style="fill:none;"></path>
<path d="M 280,272 L 320,192 " style="fill:none;"></path>
<path d="M 320,32 C 303.2,32 304,48 304,48 " style="fill:none;"></path>
<path d="M 368,32 C 384.8,32 384,48 384,48 " style="fill:none;"></path>
<path d="M 320,64 C 303.2,64 304,48 304,48 " style="fill:none;"></path>
<path d="M 368,64 C 384.8,64 384,48 384,48 " style="fill:none;"></path>
<path d="M 296,96 C 279.2,96 280,112 280,112 " style="fill:none;"></path>
<path d="M 392,96 C 408.8,96 408,112 408,112 " style="fill:none;"></path>
<path d="M 296,128 C 279.2,128 280,112 280,112 " style="fill:none;"></path>
<path d="M 392,128 C 408.8,128 408,112 408,112 " style="fill:none;"></path>
<path d="M 320,160 C 303.2,160 304,176 304,176 " style="fill:none;"></path>
<path d="M 376,160 C 392.8,160 392,176 392,176 " style="fill:none;"></path>
<path d="M 320,192 C 303.2,192 304,176 304,176 " style="fill:none;"></path>
<path d="M 376,192 C 392.8,192 392,176 392,176 " style="fill:none;"></path>
<path d="M 192,272 C 175.2,272 176,288 176,288 " style="fill:none;"></path>
<path d="M 280,272 C 296.8,272 296,288 296,288 " style="fill:none;"></path>
<path d="M 352,272 C 335.2,272 336,288 336,288 " style="fill:none;"></path>
<path d="M 536,272 C 552.8,272 552,288 552,288 " style="fill:none;"></path>
<path d="M 192,304 C 175.2,304 176,288 176,288 " style="fill:none;"></path>
<path d="M 280,304 C 296.8,304 296,288 296,288 " style="fill:none;"></path>
<path d="M 352,304 C 335.2,304 336,288 336,288 " style="fill:none;"></path>
<path d="M 536,304 C 552.8,304 552,288 552,288 " style="fill:none;"></path>
<g transform="translate(0,0)"><text text-anchor="middle" x="8" y="20">M</text><text text-anchor="middle" x="16" y="20">y</text><text text-anchor="middle" x="24" y="20">T</text><text text-anchor="middle" x="32" y="20">e</text><text text-anchor="middle" x="40" y="20">s</text><text text-anchor="middle" x="48" y="20">t</text><text text-anchor="middle" x="56" y="20">.</text><text text-anchor="middle" x="64" y="20">k</text><text text-anchor="middle" x="72" y="20">t</text><text text-anchor="middle" x="80" y="20">:</text><text text-anchor="middle" x="328" y="20">U</text><text text-anchor="middle" x="336" y="20">A</text><text text-anchor="middle" x="344" y="20">S</text><text text-anchor="middle" x="352" y="20">T</text><text text-anchor="middle" x="360" y="20">:</text><text text-anchor="middle" x="24" y="52">p</text><text text-anchor="middle" x="32" y="52">a</text><text text-anchor="middle" x="40" y="52">c</text><text text-anchor="middle" x="48" y="52">k</text><text text-anchor="middle" x="56" y="52">a</text><text text-anchor="middle" x="64" y="52">g</text><text text-anchor="middle" x="72" y="52">e</text><text text-anchor="middle" x="88" y="52">t</text><text text-anchor="middle" x="96" y="52">e</text><text text-anchor="middle" x="104" y="52">s</text><text text-anchor="middle" x="112" y="52">t</text><text text-anchor="middle" x="120" y="52">.</text><text text-anchor="middle" x="128" y="52">p</text><text text-anchor="middle" x="136" y="52">k</text><text text-anchor="middle" x="144" y="52">g</text><text text-anchor="middle" x="328" y="52">U</text><text text-anchor="middle" x="336" y="52">F</text><text text-anchor="middle" x="344" y="52">i</text><text text-anchor="middle" x="352" y="52">l</text><text text-anchor="middle" x="360" y="52">e</text><text text-anchor="middle" x="24" y="68">c</text><text text-anchor="middle" x="32" y="68">l</text><text text-anchor="middle" x="40" y="68">a</text><text text-anchor="middle" x="48" y="68">s</text><text text-anchor="middle" x="56" y="68">s</text><text text-anchor="middle" x="72" y="68">M</text><text text-anchor="middle" x="80" y="68">y</text><text text-anchor="middle" x="88" y="68">T</text><text text-anchor="middle" x="96" y="68">e</text><text text-anchor="middle" x="104" y="68">s</text><text text-anchor="middle" x="112" y="68">t</text><text text-anchor="middle" x="128" y="68">{</text><text text-anchor="middle" x="40" y="84">p</text><text text-anchor="middle" x="48" y="84">r</text><text text-anchor="middle" x="56" y="84">i</text><text text-anchor="middle" x="64" y="84">v</text><text text-anchor="middle" x="72" y="84">a</text><text text-anchor="middle" x="80" y="84">t</text><text text-anchor="middle" x="88" y="84">e</text><text text-anchor="middle" x="104" y="84">v</text><text text-anchor="middle" x="112" y="84">a</text><text text-anchor="middle" x="120" y="84">l</text><text text-anchor="middle" x="136" y="84">s</text><text text-anchor="middle" x="152" y="84">=</text><text text-anchor="middle" x="168" y="84">“</text><text text-anchor="middle" x="176" y="84">h</text><text text-anchor="middle" x="184" y="84">e</text><text text-anchor="middle" x="192" y="84">l</text><text text-anchor="middle" x="200" y="84">l</text><text text-anchor="middle" x="208" y="84">o</text><text text-anchor="middle" x="216" y="84">”</text><text text-anchor="middle" x="24" y="100">}</text><text text-anchor="middle" x="296" y="116">U</text><text text-anchor="middle" x="304" y="116">C</text><text text-anchor="middle" x="312" y="116">l</text><text text-anchor="middle" x="320" y="116">a</text><text text-anchor="middle" x="328" y="116">s</text><text text-anchor="middle" x="336" y="116">s</text><text text-anchor="middle" x="352" y="116">M</text><text text-anchor="middle" x="360" y="116">y</text><text text-anchor="middle" x="368" y="116">T</text><text text-anchor="middle" x="376" y="116">e</text><text text-anchor="middle" x="384" y="116">s</text><text text-anchor="middle" x="392" y="116">t</text><text text-anchor="middle" x="8" y="148">M</text><text text-anchor="middle" x="16" y="148">y</text><text text-anchor="middle" x="24" y="148">T</text><text text-anchor="middle" x="32" y="148">e</text><text text-anchor="middle" x="40" y="148">s</text><text text-anchor="middle" x="48" y="148">t</text><text text-anchor="middle" x="56" y="148">.</text><text text-anchor="middle" x="64" y="148">j</text><text text-anchor="middle" x="72" y="148">a</text><text text-anchor="middle" x="80" y="148">v</text><text text-anchor="middle" x="88" y="148">a</text><text text-anchor="middle" x="96" y="148">:</text><text text-anchor="middle" x="24" y="180">p</text><text text-anchor="middle" x="32" y="180">a</text><text text-anchor="middle" x="40" y="180">c</text><text text-anchor="middle" x="48" y="180">k</text><text text-anchor="middle" x="56" y="180">a</text><text text-anchor="middle" x="64" y="180">g</text><text text-anchor="middle" x="72" y="180">e</text><text text-anchor="middle" x="88" y="180">t</text><text text-anchor="middle" x="96" y="180">e</text><text text-anchor="middle" x="104" y="180">s</text><text text-anchor="middle" x="112" y="180">t</text><text text-anchor="middle" x="120" y="180">.</text><text text-anchor="middle" x="128" y="180">p</text><text text-anchor="middle" x="136" y="180">k</text><text text-anchor="middle" x="144" y="180">g</text><text text-anchor="middle" x="152" y="180">;</text><text text-anchor="middle" x="320" y="180">U</text><text text-anchor="middle" x="328" y="180">F</text><text text-anchor="middle" x="336" y="180">i</text><text text-anchor="middle" x="344" y="180">e</text><text text-anchor="middle" x="352" y="180">l</text><text text-anchor="middle" x="360" y="180">d</text><text text-anchor="middle" x="376" y="180">s</text><text text-anchor="middle" x="24" y="196">p</text><text text-anchor="middle" x="32" y="196">u</text><text text-anchor="middle" x="40" y="196">b</text><text text-anchor="middle" x="48" y="196">l</text><text text-anchor="middle" x="56" y="196">i</text><text text-anchor="middle" x="64" y="196">c</text><text text-anchor="middle" x="80" y="196">c</text><text text-anchor="middle" x="88" y="196">l</text><text text-anchor="middle" x="96" y="196">a</text><text text-anchor="middle" x="104" y="196">s</text><text text-anchor="middle" x="112" y="196">s</text><text text-anchor="middle" x="128" y="196">M</text><text text-anchor="middle" x="136" y="196">y</text><text text-anchor="middle" x="144" y="196">T</text><text text-anchor="middle" x="152" y="196">e</text><text text-anchor="middle" x="160" y="196">s</text><text text-anchor="middle" x="168" y="196">t</text><text text-anchor="middle" x="184" y="196">{</text><text text-anchor="middle" x="48" y="212">p</text><text text-anchor="middle" x="56" y="212">r</text><text text-anchor="middle" x="64" y="212">i</text><text text-anchor="middle" x="72" y="212">v</text><text text-anchor="middle" x="80" y="212">a</text><text text-anchor="middle" x="88" y="212">t</text><text text-anchor="middle" x="96" y="212">e</text><text text-anchor="middle" x="112" y="212">S</text><text text-anchor="middle" x="120" y="212">t</text><text text-anchor="middle" x="128" y="212">r</text><text text-anchor="middle" x="136" y="212">i</text><text text-anchor="middle" x="144" y="212">n</text><text text-anchor="middle" x="152" y="212">g</text><text text-anchor="middle" x="168" y="212">s</text><text text-anchor="middle" x="184" y="212">=</text><text text-anchor="middle" x="80" y="228">“</text><text text-anchor="middle" x="88" y="228">h</text><text text-anchor="middle" x="96" y="228">e</text><text text-anchor="middle" x="104" y="228">l</text><text text-anchor="middle" x="112" y="228">l</text><text text-anchor="middle" x="120" y="228">o</text><text text-anchor="middle" x="128" y="228">”</text><text text-anchor="middle" x="136" y="228">;</text><text text-anchor="middle" x="24" y="244">}</text><text text-anchor="middle" x="184" y="292">U</text><text text-anchor="middle" x="192" y="292">I</text><text text-anchor="middle" x="200" y="292">d</text><text text-anchor="middle" x="208" y="292">e</text><text text-anchor="middle" x="216" y="292">n</text><text text-anchor="middle" x="224" y="292">t</text><text text-anchor="middle" x="232" y="292">i</text><text text-anchor="middle" x="240" y="292">f</text><text text-anchor="middle" x="248" y="292">i</text><text text-anchor="middle" x="256" y="292">e</text><text text-anchor="middle" x="264" y="292">r</text><text text-anchor="middle" x="280" y="292">s</text><text text-anchor="middle" x="352" y="292">U</text><text text-anchor="middle" x="360" y="292">L</text><text text-anchor="middle" x="368" y="292">i</text><text text-anchor="middle" x="376" y="292">t</text><text text-anchor="middle" x="384" y="292">e</text><text text-anchor="middle" x="392" y="292">r</text><text text-anchor="middle" x="400" y="292">a</text><text text-anchor="middle" x="408" y="292">l</text><text text-anchor="middle" x="416" y="292">E</text><text text-anchor="middle" x="424" y="292">x</text><text text-anchor="middle" x="432" y="292">p</text><text text-anchor="middle" x="440" y="292">r</text><text text-anchor="middle" x="448" y="292">e</text><text text-anchor="middle" x="456" y="292">s</text><text text-anchor="middle" x="464" y="292">s</text><text text-anchor="middle" x="472" y="292">i</text><text text-anchor="middle" x="480" y="292">o</text><text text-anchor="middle" x="488" y="292">n</text><text text-anchor="middle" x="504" y="292">h</text><text text-anchor="middle" x="512" y="292">e</text><text text-anchor="middle" x="520" y="292">l</text><text text-anchor="middle" x="528" y="292">l</text><text text-anchor="middle" x="536" y="292">o</text></g></g></svg>

</p><p>

</p><div class="admonition tip">The name “UAST” is a bit misleading; it is not some sort of superset
   of all possible syntax trees; instead, think of this as the “Java
   view” of all code. So, for example, there isn’t a <code>UProperty</code> node
   which represents Kotlin properties. Instead, the AST will look the
   same as if the property had been implemented in Java: it will
   contain a private field and a public getter and a public setter
   (unless of course the Kotlin property specifies a private setter).
   If you’ve written code in Kotlin and have tried to access that
   Kotlin code from a Java file you will see the same thing — the
   “Java view” of Kotlin. The next section, “PSI“, will discuss how to
   do more language specific analysis.</div>

<p></p>
<a class="target" name="uastexample">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/uastexample">&nbsp;</a><a class="target" name="toc2.14.2">&nbsp;</a><h3>UAST Example</h3>
<p>


Here's an example (from the built-in <code>AlarmDetector</code> for Android) which
shows all of the above in practice; this is a lint check which makes
sure that if anyone calls <code>AlarmManager.setRepeating</code>, the second
argument is at least 5,000 and the third argument is at least 60,000.

</p><p>

Line 1 says we want to have line 3 called whenever lint comes across a
method to <code>setRepeating</code>.

</p><p>

On lines 8-4 we make sure we're talking about the correct method on the
correct class with the correct signature. This uses the <code>JavaEvaluator</code>
to check that the called method is a member of the named class. This is
necessary because the callback would also be invoked if lint came
across a method call like <code>Unrelated.setRepeating</code>; the
<code>visitMethodCall</code> callback only matches by name, not receiver.

</p><p>

On line 36 we use the <code>ConstantEvaluator</code> to compute the value of each
argument passed in. This will let this lint check not only handle cases
where you're specifying a specific value directly in the argument list,
but also for example referencing a constant from elsewhere.

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableMethodNames</span><span class="hljs-params">()</span></span>: List&lt;string&gt; = listOf(<span class="hljs-string">"setRepeating"</span>)
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitMethodCall</span><span class="hljs-params">(
<span class="line"></span>    context: <span class="hljs-type">JavaContext</span>,
<span class="line"></span>    node: <span class="hljs-type">UCallExpression</span>,
<span class="line"></span>    method: <span class="hljs-type">PsiMethod</span>
<span class="line"></span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> evaluator = context.evaluator
<span class="line"></span>    <span class="hljs-keyword">if</span> (evaluator.isMemberInClass(method, <span class="hljs-string">"android.app.AlarmManager"</span>) &amp;&amp;
<span class="line"></span>        evaluator.getParameterCount(method) == <span class="hljs-number">4</span>
<span class="line"></span>    ) {
<span class="line"></span>        ensureAtLeast(context, node, <span class="hljs-number">1</span>, <span class="hljs-number">5000L</span>)
<span class="line"></span>        ensureAtLeast(context, node, <span class="hljs-number">2</span>, <span class="hljs-number">60000L</span>)
<span class="line"></span>    }
<span class="line"></span>}
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ensureAtLeast</span><span class="hljs-params">(
<span class="line"></span>    context: <span class="hljs-type">JavaContext</span>,
<span class="line"></span>    node: <span class="hljs-type">UCallExpression</span>,
<span class="line"></span>    parameter: <span class="hljs-type">Int</span>,
<span class="line"></span>    min: <span class="hljs-type">Long</span>
<span class="line"></span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> argument = node.valueArguments[parameter]
<span class="line"></span>    <span class="hljs-keyword">val</span> value = getLongValue(context, argument)
<span class="line"></span>    <span class="hljs-keyword">if</span> (value &lt; min) {
<span class="line"></span>        <span class="hljs-keyword">val</span> message = <span class="hljs-string">"Value will be forced up to <span class="hljs-variable">$min</span> as of Android 5.1; "</span> +
<span class="line"></span>            <span class="hljs-string">"don't rely on this to be exact"</span>
<span class="line"></span>        context.report(ISSUE, argument, context.getLocation(argument), message)
<span class="line"></span>    }
<span class="line"></span>}
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLongValue</span><span class="hljs-params">(
<span class="line"></span>    context: <span class="hljs-type">JavaContext</span>,
<span class="line"></span>    argument: <span class="hljs-type">UExpression</span>
<span class="line"></span>)</span></span>: <span class="hljs-built_in">Long</span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> value = ConstantEvaluator.evaluate(context, argument)
<span class="line"></span>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">is</span> Number) {
<span class="line"></span>        <span class="hljs-keyword">return</span> value.toLong()
<span class="line"></span>    }
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">return</span> java.lang.<span class="hljs-built_in">Long</span>.MAX_VALUE
<span class="line"></span>}</div></code></pre>
<a class="target" name="lookingupuast">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/lookingupuast">&nbsp;</a><a class="target" name="toc2.14.3">&nbsp;</a><h3>Looking up UAST</h3>
<p>


To write your detector's analysis, you need to know what the AST for
your code of interest looks like. Instead of trying to figure it out by
examining the elements under a debugger, a simple way to find out is to
”pretty print“ it, using the <code>UElement</code> extension method
<strong class="asterisk"><code>asRecursiveLogString</code></strong>.

</p><p>

For example, given the following unit test:

</p><pre class="listing tilde"><code><span class="line"></span>lint().files(
<span class="line"></span>       kotlin(<span class="hljs-string">""</span>
<span class="line"></span>               <span class="hljs-operator">+</span> <span class="hljs-string">"package test.pkg<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>               <span class="hljs-operator">+</span> <span class="hljs-string">"<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>               <span class="hljs-operator">+</span> <span class="hljs-string">"class MyTest {<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>               <span class="hljs-operator">+</span> <span class="hljs-string">"    val s: String = <span class="hljs-subst">\"</span>hello<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span>
<span class="line"></span>               <span class="hljs-operator">+</span> <span class="hljs-string">"}<span class="hljs-subst">\n</span>"</span>), <span class="hljs-operator">...</span></code></pre><p>

If you evaluate <code>context.uastFile?.asRecursiveLogString()</code> from
one of the callbacks, it will print this:

</p><pre class="listing backtick"><code><span class="line"></span>UFile (package = test.pkg)
<span class="line"></span>    UClass (name = MyTest)
<span class="line"></span>        UField (name = s)
<span class="line"></span>            UAnnotation (fqName = org.jetbrains.annotations.NotNull)
<span class="line"></span>            ULiteralExpression (value = "hello")
<span class="line"></span>        UAnnotationMethod (name = getS)
<span class="line"></span>        UAnnotationMethod (name = MyTest)</code></pre><p>

(This also illustrates the earlier point about UAST representing the
Java view of the code; here the read-only public Kotlin property ”s“ is
represented by both a private field <code>s</code> and a public getter method,
<code>getS()</code>.)

</p>
<a class="target" name="resolving">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/resolving">&nbsp;</a><a class="target" name="toc2.14.4">&nbsp;</a><h3>Resolving</h3>
<p>


When you have a method call, or a field reference, you may want to take
a look at the called method or field. This is called ”resolving“, and
UAST supports it directly; on a <code>UCallExpression</code> for example, call
<code>.resolve()</code>, which returns a <code>PsiMethod</code>, which is like a <code>UMethod</code>,
but may not represent a method we have source for (which for example
would be the case if you resolve a reference to the JDK or to a library
we do not have sources for). You can call <code>.toUElement()</code> on the
PSI element to try to convert it to UAST if source is available.

</p><p>

</p><div class="admonition warning">Resolving only works if lint has a correct classpath such that the
   referenced method, field or class are actually present. If it is
   not, resolve will return null, and various lint callbacks will not
   be invoked. This is a common source of questions for lint checks
   ”not working“; it frequently comes up in lint unit tests where a
   test file will reference some API that isn't actually included in
   the class path. The recommended approach for this is to declare
   local stubs. See the <a href="#lintcheckunittesting">unit testing</a> chapter
   for more details about this.</div>

<p></p>
<a class="target" name="implicitcalls">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/implicitcalls">&nbsp;</a><a class="target" name="toc2.14.5">&nbsp;</a><h3>Implicit Calls</h3>
<p>


Kotlin supports operator overloading for a number of built-in
operators. For example, if you have the following code,

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(n1: <span class="hljs-type">BigDecimal</span>, n2: <span class="hljs-type">BigDecimal</span>)</span></span> {
<span class="line"></span>    <span class="hljs-comment">// Here, this is really an infix call to BigDecimal#compareTo</span>
<span class="line"></span>    <span class="hljs-keyword">if</span> (n1 &lt; n2) {
<span class="line"></span>        ...
<span class="line"></span>    }
<span class="line"></span>}</code></pre><p>

the <code>&lt;</code> here is actually a function call (which you can verify by
invoking Go To Declaration over the symbol in the IDE). This is not
something that is built specially for the <code>BigDecimal</code> class; this
works on any of your Java classes as well, and Kotlin if you put the
<code>operator</code> modifier as part of the function declaration.

</p><p>

However, note that in the abstract syntax tree, this is <strong class="asterisk">not</strong>
represented as a <code>UCallExpression</code>; here we'll have a
<code>UBinaryExpression</code> with left operand <code>n1</code>, right operand <code>n2</code> and
operator <code>UastBinaryOperator.LESS</code>. This means that if your lint check
is specifically looking at <code>compareTo</code> calls, you can't just visit
every <code>UCallExpression</code>; you <em class="asterisk">also</em> have to visit every
<code>UBinaryExpression</code>, and check whether it's invoking a <code>compareTo</code>
method.

</p><p>

This is not just specific to binary operators; it also applies to unary
operators (such as <code>!</code>, <code>-</code>, <code>++</code>, and so on), as well as even array
accesses; an array access can map to a <code>get</code> call or a <code>set</code> call
depending on how it's used.

</p><p>

Lint has some special support to help handle these situations.

</p><p>

First, the built-in support for call callbacks (where you register an
interest in call names by returning names from the
<code>getApplicableMethodNames</code> and then responding in the <code>visitMethodCall</code>
callback) already handles this automatically. If you register for
example an interest in method calls to <code>compareTo</code>, it will invoke your
callback for the binary operator scenario shown above as well, passing
you a call which has the right value arguments, method name, and so on.

</p><p>

The way this works is that lint can create a ”wrapper“ class which
presents the underlying <code>UBinaryExpression</code> (or
<code>UArrayAccessExpression</code> and so on) as a <code>UCallExpression</code>. In the case
of a binary operator, the value parameter list will be the left and
right operands. This means that your code can just process this as if
the code had written as an explicit call instead of using the operator
syntax. You can also directly look for this wrapper class,
<code>UImplicitCallExpression</code>, which has an accessor method for looking up
the original or underlying element. And you can construct these
wrappers yourself, via <code>UBinaryExpression.asCall()</code>,
<code>UUnaryExpression.asCall()</code>, and <code>UArrayAccessExpression.asCall()</code>.

</p><p>

There is also a visitor you can use to visit call calls —
<code>UastCallVisitor</code>, which will visit all calls, including those from
array accesses and unary operators and binary operators.

</p><p>

This support is particularly useful for array accesses, since unlike
the operator expression, there is no <code>resolveOperator</code> method on
<code>UArrayExpression</code>. There is an open request for that in the UAST issue
tracker (KTIJ-18765), but for now, lint has a workaround to handle the
resolve on its own.

</p>
<a class="target" name="psi">&nbsp;</a><a class="target" name="writingalintcheck:basics/analyzingkotlinandjavacode/psi">&nbsp;</a><a class="target" name="toc2.14.6">&nbsp;</a><h3>PSI</h3>
<p>


PSI is short for ”Program Structure Interface“, and is IntelliJ's AST
abstraction used for all language modeling in the IDE.

</p><p>

Note that there is a <strong class="asterisk">different</strong> PSI representation for each
language. Java and Kotlin have completely different PSI classes
involved. This means that writing a lint check using PSI would involve
writing a lot of logic twice; once for Java, and once for Kotlin. (And
the Kotlin PSI is a bit trickier to work with.)

</p><p>

That's what UAST is for: there's a ”bridge“ from the Java PSI to UAST
and there's a bridge from the Kotlin PSI to UAST, and your lint check
just analyzes UAST.

</p><p>

However, there are a few scenarios where we have to use PSI.

</p><p>

The first, and most common one, is listed in the previous section on
resolving. UAST does not completely replace PSI; in fact, PSI leaks
through in part of the UAST API surface. For example,
<code>UMethod.resolve()</code> returns a <code>PsiMethod</code>. And more importantly,
<code>UMethod</code> <strong class="asterisk">extends</strong> <code>PsiMethod</code>.

</p><p>

</p><div class="admonition warning">For historical reasons, <code>PsiMethod</code> and other PSI classes contain
   some unfortunate APIs that only work for Java, such as asking for
   the method body. Because <code>UMethod</code> extends <code>PsiMethod</code>, you might be
   tempted to call <code>getBody()</code> on it, but this will return null from
   Kotlin. If your unit tests for your lint check only have test cases
   written in Java, you may not realize that your check is doing the
   wrong thing and won't work on Kotlin code. It should call <code>uastBody</code>
   on the <code>UMethod</code> instead. Lint's special detector for lint detectors
   looks for this and a few other scenarios (such as calling <code>parent</code>
   instead of <code>uastParent</code>), so be sure to configure it for your
   project.</div>

<p></p><p>

When you are dealing with ”signatures“ — looking at classes and
class inheritance, methods, parameters and so on — using PSI is
fine — and unavoidable since UAST does not represent bytecode
(though in the future it potentially could, via a decompiler)
or any other JVM languages than Kotlin and Java.

</p><p>

However, if you are looking at anything <em class="asterisk">inside</em> a method or class
or field initializer, you <strong class="asterisk">must</strong> use UAST.

</p><p>

The <strong class="asterisk">second</strong> scenario where you may need to use PSI is where you have
to do something language specific which is not represented in UAST. For
example, if you are trying to look up the names or default values of a
parameter, or whether a given class is a companion object, then you'll
need to dip into Kotlin PSI.

</p><p>

There is usually no need to look at Java PSI since UAST fully covers
it, unless you want to look at individual details like specific
whitespace between AST nodes, which is represented in PSI but not UAST.

</p><p>

</p><div class="admonition tip">You can find additional documentation from JetBrains for both
   <a href="https://plugins.jetbrains.com/docs/intellij/psi.html">PSI</a> and
   <a href="https://plugins.jetbrains.com/docs/intellij/uast.html">UAST</a>.
   Just note that their documentation is aimed at IDE plugin developers
   rather than lint developers.</div>

<p></p>
<a class="target" name="testing">&nbsp;</a><a class="target" name="writingalintcheck:basics/testing">&nbsp;</a><a class="target" name="toc2.15">&nbsp;</a><h2>Testing</h2>
<p>


Writing unit tests for the lint check is important, and this is covered
in detail in the dedicated <a href="#lintcheckunittesting">unit testing</a>
chapter.

</p><p>



</p>
<a class="target" name="example:samplelintcheckgithubproject">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject">&nbsp;</a><a class="target" name="toc3">&nbsp;</a><h1>Example: Sample Lint Check GitHub Project</h1>
<p>


The <a href="https://github.com/googlesamples/android-custom-lint-rules"></a><a href="https://github.com/googlesamples/android-custom-lint-rules" class="url">https://github.com/googlesamples/android-custom-lint-rules</a>
GitHub project provides a sample lint check which shows a working
skeleton.

</p><p>

This chapter walks through that sample project and explains
what and why.

</p>
<a class="target" name="projectlayout">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/projectlayout">&nbsp;</a><a class="target" name="toc3.1">&nbsp;</a><h2>Project Layout</h2>
<p>


Here's the project layout of the sample project:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="96" width="528" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 32,16 L 32,48 " style="fill:none;"></path>
<path d="M 72,16 L 72,48 " style="fill:none;"></path>
<path d="M 224,16 L 224,48 " style="fill:none;"></path>
<path d="M 296,16 L 296,48 " style="fill:none;"></path>
<path d="M 424,16 L 424,48 " style="fill:none;"></path>
<path d="M 488,16 L 488,48 " style="fill:none;"></path>
<path d="M 32,16 L 72,16 " style="fill:none;"></path>
<path d="M 224,16 L 296,16 " style="fill:none;"></path>
<path d="M 424,16 L 488,16 " style="fill:none;"></path>
<path d="M 72,32 L 216,32 " style="fill:none;"></path>
<path d="M 296,32 L 416,32 " style="fill:none;"></path>
<path d="M 32,48 L 72,48 " style="fill:none;"></path>
<path d="M 224,48 L 296,48 " style="fill:none;"></path>
<path d="M 424,48 L 488,48 " style="fill:none;"></path>
<polygon points="424,32 412,26.4 412,37.6 " style="stroke:none" transform="rotate(0,416,32 )"></polygon>
<polygon points="224,32 212,26.4 212,37.6 " style="stroke:none" transform="rotate(0,216,32 )"></polygon>
<g transform="translate(0,0)"><text text-anchor="middle" x="96" y="20">i</text><text text-anchor="middle" x="104" y="20">m</text><text text-anchor="middle" x="112" y="20">p</text><text text-anchor="middle" x="120" y="20">l</text><text text-anchor="middle" x="128" y="20">e</text><text text-anchor="middle" x="136" y="20">m</text><text text-anchor="middle" x="144" y="20">e</text><text text-anchor="middle" x="152" y="20">n</text><text text-anchor="middle" x="160" y="20">t</text><text text-anchor="middle" x="168" y="20">a</text><text text-anchor="middle" x="176" y="20">t</text><text text-anchor="middle" x="184" y="20">i</text><text text-anchor="middle" x="192" y="20">o</text><text text-anchor="middle" x="200" y="20">n</text><text text-anchor="middle" x="320" y="20">l</text><text text-anchor="middle" x="328" y="20">i</text><text text-anchor="middle" x="336" y="20">n</text><text text-anchor="middle" x="344" y="20">t</text><text text-anchor="middle" x="352" y="20">P</text><text text-anchor="middle" x="360" y="20">u</text><text text-anchor="middle" x="368" y="20">b</text><text text-anchor="middle" x="376" y="20">l</text><text text-anchor="middle" x="384" y="20">i</text><text text-anchor="middle" x="392" y="20">s</text><text text-anchor="middle" x="400" y="20">h</text><text text-anchor="middle" x="40" y="36">:</text><text text-anchor="middle" x="48" y="36">a</text><text text-anchor="middle" x="56" y="36">p</text><text text-anchor="middle" x="64" y="36">p</text><text text-anchor="middle" x="232" y="36">:</text><text text-anchor="middle" x="240" y="36">l</text><text text-anchor="middle" x="248" y="36">i</text><text text-anchor="middle" x="256" y="36">b</text><text text-anchor="middle" x="264" y="36">r</text><text text-anchor="middle" x="272" y="36">a</text><text text-anchor="middle" x="280" y="36">r</text><text text-anchor="middle" x="288" y="36">y</text><text text-anchor="middle" x="432" y="36">:</text><text text-anchor="middle" x="440" y="36">c</text><text text-anchor="middle" x="448" y="36">h</text><text text-anchor="middle" x="456" y="36">e</text><text text-anchor="middle" x="464" y="36">c</text><text text-anchor="middle" x="472" y="36">k</text><text text-anchor="middle" x="480" y="36">s</text></g></g></svg>

</p><p>

We have an application module, <code>app</code>, which depends (via an
<code>implementation</code> dependency) on a <code>library</code>, and the library itself has
a <code>lintPublish</code> dependency on the <code>checks</code> project.

</p>
<a class="target" name=":checks">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/:checks">&nbsp;</a><a class="target" name="toc3.2">&nbsp;</a><h2>:checks</h2>
<p>


The <code>checks</code> project is where the actual lint checks are implemented.
This project is a plain Kotlin or plain Java Gradle project:

</p><pre class="listing tilde"><code><span class="line"></span>apply plugin: <span class="hljs-string">'java-library'</span>
<span class="line"></span>apply plugin: <span class="hljs-string">'kotlin'</span></code></pre><p>



</p><div class="admonition tip">If you look at the sample project, you'll see a third plugin
   applied: <code>apply plugin: 'com.android.lint'</code>. This pulls in the
   standalone Lint Gradle plugin, which adds a lint target to this
   Kotlin project. This means that you can run <code>./gradlew lint</code> on the
   <code>:checks</code> project too. This is useful because lint ships with a
   dozen lint checks that look for mistakes in lint detectors! This
   includes warnings about using the wrong UAST methods, invalid id
   formats, words in messages which look like code which should
   probably be surrounded by apostrophes, etc.</div>

<p></p><p>

The Gradle file also declares the dependencies on lint APIs
that our detector needs:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span>dependencies {
<span class="line"></span>    compileOnly <span class="hljs-string">"com.android.tools.lint:lint-api:<span class="hljs-variable">$lintVersion</span>"</span>
<span class="line"></span>    compileOnly <span class="hljs-string">"com.android.tools.lint:lint-checks:<span class="hljs-variable">$lintVersion</span>"</span>
<span class="line"></span>    testImplementation <span class="hljs-string">"com.android.tools.lint:lint-tests:<span class="hljs-variable">$lintVersion</span>"</span>
<span class="line"></span>}</div></code></pre><p>

The second dependency is usually not necessary; you just need to depend
on the Lint API. However, the built-in checks define a lot of
additional infrastructure which it's sometimes convenient to depend on,
such as <code>ApiLookup</code> which lets you look up the required API level for a
given method, and so on. Don't add the dependency until you need it.

</p>
<a class="target" name="lintversion?">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/lintversion?">&nbsp;</a><a class="target" name="toc3.3">&nbsp;</a><h2>lintVersion?</h2>
<p>


What is the <code>lintVersion</code> variable defined above?

</p><p>

Here's the top level build.gradle
</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span>buildscript {
<span class="line"></span>    ext {
<span class="line"></span>        kotlinVersion = <span class="hljs-string">'1.4.32'</span>
<span class="line"></span>
<span class="line"></span>        <span class="hljs-comment">// Current lint target: Studio 4.2 / AGP 7</span>
<span class="line"></span>        <span class="hljs-comment">//gradlePluginVersion = '4.2.0-beta06'</span>
<span class="line"></span>        <span class="hljs-comment">//lintVersion = '27.2.0-beta06'</span>
<span class="line"></span>
<span class="line"></span>        <span class="hljs-comment">// Upcoming lint target: Arctic Fox / AGP 7</span>
<span class="line"></span>        gradlePluginVersion = <span class="hljs-string">'7.0.0-alpha10'</span>
<span class="line"></span>        lintVersion = <span class="hljs-string">'30.0.0-alpha10'</span>
<span class="line"></span>    }
<span class="line"></span>
<span class="line"></span>    repositories {
<span class="line"></span>        google()
<span class="line"></span>        mavenCentral()
<span class="line"></span>    }
<span class="line"></span>    dependencies {
<span class="line"></span>        classpath <span class="hljs-string">"com.android.tools.build:gradle:<span class="hljs-variable">$gradlePluginVersion</span>"</span>
<span class="line"></span>        classpath <span class="hljs-string">"org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="hljs-variable">$kotlinVersion</span>"</span>
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

The <code>$lintVersion</code> variable is defined on line 11. We don't technically
need to define the <code>$gradlePluginVersion</code> here or add it to the classpath on line 19, but that's done so that we can add the <code>lint</code>
plugin on the checks themselves, as well as for the other modules,
<code>:app</code> and <code>:library</code>, which do need it.

</p><p>

When you build lint checks, you're compiling against the Lint APIs
distributed on maven.google.com (which is referenced via <code>google()</code> in
Gradle files). These follow the Gradle plugin version numbers.

</p><p>

Therefore, you first pick which of lint's API you'd like to compile
against. You should use the latest available if possible.

</p><p>

Once you know the Gradle plugin version number, say 4.2.0-beta06, you
can compute the lint version number by simply adding <strong class="asterisk">23</strong> to the
major version of the gradle plugin, and leave everything the same:

</p><p>

<strong class="asterisk">lintVersion = gradlePluginVersion + 23.0.0</strong>

</p><p>

For example, 7 + 23 = 30, so AGP version <em class="asterisk">7.something</em> corresponds to
Lint version <em class="asterisk">30.something</em>. As another example; as of this writing the
current stable version of AGP is 4.1.2, so the corresponding version of
the Lint API is 27.1.2.

</p><p>

</p><div class="admonition tip">Why this arbitrary numbering — why can't lint just use the same
   numbers? This is historical; lint (and various other sibling
   libraries that lint depends on) was released earlier than the Gradle
   plugin; it was up to version 22 or so. When we then shipped the
   initial version of the Gradle plugin with Android Studio 1.0, we
   wanted to start the numbering over from “1” for this brand new
   artifact. However, some of the other libraries, like lint, couldn't
   just start over at 1, so we continued incrementing their versions in
   lockstep. Most users don't see this, but it's a wrinkle users of the
   Lint API have to be aware of.</div>

<p></p>
<a class="target" name=":libraryand:app">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/:libraryand:app">&nbsp;</a><a class="target" name="toc3.4">&nbsp;</a><h2>:library and :app</h2>
<p>


The <code>library</code> project depends on the lint check project, and will
package the lint checks as part of its payload. The <code>app</code> project
then depends on the <code>library</code>, and has some code which triggers
the lint check. This is there to demonstrate how lint checks can
be published and consumed, and this is described in detail in the
<a href="#publishingalintcheck">Publishing a Lint Check</a> chapter.

</p>
<a class="target" name="lintcheckprojectlayout">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/lintcheckprojectlayout">&nbsp;</a><a class="target" name="toc3.5">&nbsp;</a><h2>Lint Check Project Layout</h2>
<p>


The lint checks source project is very simple

</p><pre class="listing backtick"><code><span class="line"></span><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">build</span><span class="hljs-selector-class">.gradle</span>
<span class="line"></span><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">main</span>/<span class="hljs-selector-tag">resources</span>/<span class="hljs-selector-tag">META-INF</span>/<span class="hljs-selector-tag">services</span>/<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.lint</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.IssueRegistry</span>
<span class="line"></span><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">main</span>/<span class="hljs-selector-tag">java</span>/<span class="hljs-selector-tag">com</span>/<span class="hljs-selector-tag">example</span>/<span class="hljs-selector-tag">lint</span>/<span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">SampleIssueRegistry</span><span class="hljs-selector-class">.kt</span>
<span class="line"></span><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">main</span>/<span class="hljs-selector-tag">java</span>/<span class="hljs-selector-tag">com</span>/<span class="hljs-selector-tag">example</span>/<span class="hljs-selector-tag">lint</span>/<span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">SampleCodeDetector</span><span class="hljs-selector-class">.kt</span>
<span class="line"></span><span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">src</span>/<span class="hljs-selector-tag">test</span>/<span class="hljs-selector-tag">java</span>/<span class="hljs-selector-tag">com</span>/<span class="hljs-selector-tag">example</span>/<span class="hljs-selector-tag">lint</span>/<span class="hljs-selector-tag">checks</span>/<span class="hljs-selector-tag">SampleCodeDetectorTest</span><span class="hljs-selector-class">.kt</span></code></pre><p>

First is the build file, which we've discussed above.

</p>
<a class="target" name="serviceregistration">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/serviceregistration">&nbsp;</a><a class="target" name="toc3.6">&nbsp;</a><h2>Service Registration</h2>
<p>


Then there's the service registration file. Notice how this file is in
the source set <code>src/main/resources/</code>, which means that Gradle will
treat it as a resource and will package it into the output jar, in the
<code>META-INF/services</code> folder. This is using the service-provider loading facility in the JDK to register a service lint can look up. The
key is the fully qualified name for lint's <code>IssueRegistry</code> class.
And the <strong class="asterisk">contents</strong> of that file is a single line, the fully
qualified name of the issue registry:

</p><pre class="listing backtick"><code><span class="line"></span><span class="hljs-variable">$ </span>cat checks/src/main/resources/META-INF/services/com.android.tools.lint.client.api.IssueRegistry
<span class="line"></span>com.example.lint.checks.SampleIssueRegistry</code></pre><p>

(The service loader mechanism is understood by IntelliJ, so it will
correctly update the service file contents if the issue registry is
renamed etc.)

</p><p>

The service registration can contain more than one issue registry,
though there's usually no good reason for that, since a single issue
registry can provide multiple issues.

</p>
<a class="target" name="issueregistry">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/issueregistry">&nbsp;</a><a class="target" name="toc3.7">&nbsp;</a><h2>IssueRegistry</h2>
<p>


Next we have the <code>IssueRegistry</code> linked from the service registration.
Lint will instantiate this class and ask it to provide a list of
issues. These are then merged with lint's other issues when lint
performs its analysis.

</p><p>

In its simplest form we'd only need to have the following code
in that file:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-title">package</span> com.example.lint.checks
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.client.api.IssueRegistry
<span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">SampleIssueRegistry</span> : <span class="hljs-type">IssueRegistry</span>() {
<span class="line"></span>    override val issues = listOf(<span class="hljs-type">SampleCodeDetector</span>.<span class="hljs-type">ISSUE</span>)
<span class="line"></span>}</span></code></pre><p>

However, we're also providing some additional metadata about these lint
checks, such as the <code>Vendor</code>, which contains information about the
author and (optionally) contact address or bug tracker information,
displayed to users when an incident is found.

</p><p>

We also provide some information about which version of lint's API the
check was compiled against, and the lowest version of the lint API that
this lint check has been tested with. (Note that the API versions are
not identical to the versions of lint itself; the idea and hope is that
the API may evolve at a slower pace than updates to lint delivering new
functionality).

</p>
<a class="target" name="detector">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/detector">&nbsp;</a><a class="target" name="toc3.8">&nbsp;</a><h2>Detector</h2>
<p>


The <code>IssueRegistry</code> references the <code>SampleCodeDetector.ISSUE</code>,
so let's take a look at <code>SampleCodeDetector</code>:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleCodeDetector</span> : <span class="hljs-type">Detector</span></span>(), UastScanner {
<span class="line"></span>
<span class="line"></span>    <span class="hljs-comment">// ...</span>
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
<span class="line"></span>        <span class="hljs-comment">/**
<span class="line"></span>         * Issue describing the problem and pointing to the detector
<span class="line"></span>         * implementation.
<span class="line"></span>         */</span>
<span class="line"></span>        <span class="hljs-meta">@JvmField</span>
<span class="line"></span>        <span class="hljs-keyword">val</span> ISSUE: Issue = Issue.create(
<span class="line"></span>            <span class="hljs-comment">// ID: used in @SuppressLint warnings etc</span>
<span class="line"></span>            id = <span class="hljs-string">"SampleId"</span>,
<span class="line"></span>            <span class="hljs-comment">// Title -- shown in the IDE's preference dialog, as category headers in the</span>
<span class="line"></span>            <span class="hljs-comment">// Analysis results window, etc</span>
<span class="line"></span>            briefDescription = <span class="hljs-string">"Lint Mentions"</span>,
<span class="line"></span>            <span class="hljs-comment">// Full explanation of the issue; you can use some markdown markup such as</span>
<span class="line"></span>            <span class="hljs-comment">// `monospace`, *italic*, and **bold**.</span>
<span class="line"></span>            explanation = <span class="hljs-string">"""
<span class="line"></span>                    This check highlights string literals in code which mentions the word `lint`. \
<span class="line"></span>                    Blah blah blah.
<span class="line"></span>
<span class="line"></span>                    Another paragraph here.
<span class="line"></span>                    """</span>,
<span class="line"></span>            category = Category.CORRECTNESS,
<span class="line"></span>            priority = <span class="hljs-number">6</span>,
<span class="line"></span>            severity = Severity.WARNING,
<span class="line"></span>            implementation = Implementation(
<span class="line"></span>                SampleCodeDetector::<span class="hljs-keyword">class</span>.java,
<span class="line"></span>                Scope.JAVA_FILE_SCOPE
<span class="line"></span>            )
<span class="line"></span>        )
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

The <code>Issue</code> registration is pretty self-explanatory, and the details
about issue registration are covered in the <a href="#writingalintcheck:basics">basics</a>
chapter. The excessive comments here are there to explain the sample,
and there are usually no comments in issue registration code like this.

</p><p>

Note how on line 29, the <code>Issue</code> registration names the <code>Detector</code>
class responsible for analyzing this issue: <code>SampleCodeDetector</code>. In
the above I deleted the body of that class; here it is now without the
issue registration at the end:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">package</span> com.example.lint.checks
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.client.api.UElementHandler
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Category
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Detector
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Detector.UastScanner
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Implementation
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Issue
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.JavaContext
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Scope
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.detector.api.Severity
<span class="line"></span><span class="hljs-keyword">import</span> org.jetbrains.uast.UElement
<span class="line"></span><span class="hljs-keyword">import</span> org.jetbrains.uast.ULiteralExpression
<span class="line"></span><span class="hljs-keyword">import</span> org.jetbrains.uast.evaluateString
<span class="line"></span>
<span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleCodeDetector</span> : <span class="hljs-type">Detector</span></span>(), UastScanner {
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableUastTypes</span><span class="hljs-params">()</span></span>: List&lt;<span class="hljs-class"><span class="hljs-keyword">class</span>&lt;<span class="hljs-type">out uelement?=""</span>&gt;&gt; </span>{
<span class="line"></span>        <span class="hljs-keyword">return</span> listOf(ULiteralExpression::<span class="hljs-keyword">class</span>.java)
<span class="line"></span>    }
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createUastHandler</span><span class="hljs-params">(context: <span class="hljs-type">JavaContext</span>)</span></span>: UElementHandler {
<span class="line"></span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : UElementHandler() {
<span class="line"></span>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitLiteralExpression</span><span class="hljs-params">(node: <span class="hljs-type">ULiteralExpression</span>)</span></span> {
<span class="line"></span>                <span class="hljs-keyword">val</span> string = node.evaluateString() ?: <span class="hljs-keyword">return</span>
<span class="line"></span>                <span class="hljs-keyword">if</span> (string.contains(<span class="hljs-string">"lint"</span>) &amp;&amp; string.matches(Regex(<span class="hljs-string">".*\\blint\\b.*"</span>))) {
<span class="line"></span>                    context.report(
<span class="line"></span>                        ISSUE, node, context.getLocation(node),
<span class="line"></span>                        <span class="hljs-string">"This code mentions `lint`: **Congratulations**"</span>
<span class="line"></span>                    )
<span class="line"></span>                }
<span class="line"></span>            }
<span class="line"></span>        }
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

This lint check is very simple; for Kotlin and Java files, it visits
all the literal strings, and if the string contains the word “lint”,
then it issues a warning.

</p><p>

This is using a very general mechanism of AST analysis; specifying the
relevant node types (literal expressions, on line 18) and visiting them
on line 23. Lint has a large number of convenience APIs for doing
higher level things, such as “call this callback when somebody extends
this class”, or “when somebody calls a method named ”foo“, and so on.
Explore the <code>SourceCodeScanner</code> and other <code>Detector</code> interfaces to see
what's possible. We'll hopefully also add more dedicated documentation
for this.

</p>
<a class="target" name="detectortest">&nbsp;</a><a class="target" name="example:samplelintcheckgithubproject/detectortest">&nbsp;</a><a class="target" name="toc3.9">&nbsp;</a><h2>Detector Test</h2>
<p>


Last but not least, let's not forget the unit test:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">package</span> com.example.lint.checks
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.checks.infrastructure.TestFiles.java
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.checks.infrastructure.TestLintTask.lint
<span class="line"></span><span class="hljs-keyword">import</span> org.junit.Test
<span class="line"></span>
<span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleCodeDetectorTest</span> </span>{
<span class="line"></span>    <span class="hljs-meta">@Test</span>
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testBasic</span><span class="hljs-params">()</span></span> {
<span class="line"></span>        lint().files(
<span class="line"></span>            java(
<span class="line"></span>                <span class="hljs-string">"""
<span class="line"></span>                package test.pkg;
<span class="line"></span>                public class TestClass1 {
<span class="line"></span>                    // In a comment, mentioning "lint" has no effect
<span class="line"></span>                    private static String s1 = "Ignore non-word usages: linting";
<span class="line"></span>                    private static String s2 = "Let's say it: lint";
<span class="line"></span>                }
<span class="line"></span>                """</span>
<span class="line"></span>            ).indented()
<span class="line"></span>        )
<span class="line"></span>        .issues(SampleCodeDetector.ISSUE)
<span class="line"></span>        .run()
<span class="line"></span>        .<span class="hljs-keyword">expect</span>(
<span class="line"></span>            <span class="hljs-string">"""
<span class="line"></span>            src/test/pkg/TestClass1.java:5: Warning: This code mentions lint: Congratulations [SampleId]
<span class="line"></span>                private static String s2 = "Let's say it: lint";
<span class="line"></span>                                           ∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼
<span class="line"></span>            0 errors, 1 warnings
<span class="line"></span>            """</span>
<span class="line"></span>        )
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

As you can see, writing a lint unit test is very simple, because
lint ships with a dedicated testing library; this is what the

</p><pre class="listing backtick"><code><span class="line"></span>    testImplementation <span class="hljs-string">"com.android.tools.lint:lint-tests:<span class="hljs-variable">$lintVersion</span>"</span></code></pre><p>

dependency in build.gradle pulled in.

</p><p>

Unit testing lint checks is covered in depth in the
<a href="#lintcheckunittesting">unit </a><a href="#testing">testing</a> chapter, so we'll cut the
explanation of the above test short here.

</p><p>



</p>
<a class="target" name="publishingalintcheck">&nbsp;</a><a class="target" name="publishingalintcheck">&nbsp;</a><a class="target" name="toc4">&nbsp;</a><h1>Publishing a Lint Check</h1>
<p>


Lint will look for jar files with a service registry key for issue
registries.

</p><p>

You can manually point it to your custom lint checks jar files by using
the environment variable <code>ANDROID_LINT_JARS</code>:

</p><pre class="listing backtick"><code><span class="line"></span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> ANDROID_LINT_JARS=/path/to/first.jar:/path/to/second.jar</span></code></pre><p>
(On Windows, use <code>;</code> instead of <code>:</code> as the path separator)

</p><p>

However, that is only intended for development and as a workaround for
build systems that do not have direct support for lint or embedded lint
libraries, such as the internal Google build system.

</p>
<a class="target" name="android">&nbsp;</a><a class="target" name="publishingalintcheck/android">&nbsp;</a><a class="target" name="toc4.1">&nbsp;</a><h2>Android</h2>

<a class="target" name="aarsupport">&nbsp;</a><a class="target" name="publishingalintcheck/android/aarsupport">&nbsp;</a><a class="target" name="toc4.1.1">&nbsp;</a><h3>AAR Support</h3>
<p>


Android libraries are shipped as <code>.aar</code> files instead of <code>.jar</code> files.
This means that they can carry more than just the code payload. Under
the hood, <code>.aar</code> files are just zip files which contain many other
nested files, including api and implementation jars, resources,
proguard/r8 rules, and yes, lint jars.

</p><p>

For example, if we look at the contents of the timber logging library's
AAR file, we can see the lint.jar with several lint checks within as
part of the payload:

</p><pre class="listing backtick"><code><span class="line"></span><span class="hljs-meta">$</span><span class="bash"> jar tvf ~/.gradle/caches/.../jakewharton.timber/timber/4.5.1/?/timber-4.5.1.aar</span>
<span class="line"></span>   216 Fri Jan 20 14:45:28 PST 2017 AndroidManifest.xml
<span class="line"></span>  8533 Fri Jan 20 14:45:28 PST 2017 classes.jar
<span class="line"></span> 10111 Fri Jan 20 14:45:28 PST 2017 lint.jar
<span class="line"></span>    39 Fri Jan 20 14:45:28 PST 2017 proguard.txt
<span class="line"></span>     0 Fri Jan 20 14:45:24 PST 2017 aidl/
<span class="line"></span>     0 Fri Jan 20 14:45:28 PST 2017 assets/
<span class="line"></span>     0 Fri Jan 20 14:45:28 PST 2017 jni/
<span class="line"></span>     0 Fri Jan 20 14:45:28 PST 2017 res/
<span class="line"></span>     0 Fri Jan 20 14:45:28 PST 2017 libs/</code></pre><p>

The advantage of this approach is that when lint notices that you
depend on a library, and that library contains custom lint checks, then
lint will pull in those checks and apply them. This gives library
authors a way to provide their own additional checks enforcing usage.

</p>
<a class="target" name="lintpublishconfiguration">&nbsp;</a><a class="target" name="publishingalintcheck/android/lintpublishconfiguration">&nbsp;</a><a class="target" name="toc4.1.2">&nbsp;</a><h3>lintPublish Configuration</h3>
<p>


The Android Gradle library plugin provides some special configurations,
<code>lintConfig</code> and <code>lintPublish</code>.

</p><p>

The <code>lintPublish</code> configuration lets you reference another project, and
it will take that project's output jar and package it as a <code>lint.jar</code>
inside the AAR file.

</p><p>

The <a href="https://github.com/googlesamples/android-custom-lint-rules"></a><a href="https://github.com/googlesamples/android-custom-lint-rules" class="url">https://github.com/googlesamples/android-custom-lint-rules</a>
sample project demonstrates this setup.

</p><p>

The <code>:checks</code> project is a pure Kotlin library which depends on the
Lint APIs, implements a <code>Detector</code>, and provides an <code>IssueRegistry</code>
which is linked from <code>META-INF/services</code>.

</p><p>

Then in the Android library, the <code>:library</code> project applies the Android
Gradle library plugin. It then specifies a <code>lintPublish</code> configuration
referencing the checks lint project:

</p><pre class="listing tilde"><code><span class="line"></span>apply plugin: <span class="hljs-string">'com.android.library'</span>
<span class="line"></span>dependencies {
<span class="line"></span>    <span class="hljs-function">lintPublish <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">':checks'</span></span>)
<span class="line"></span>    <span class="hljs-comment">// other dependencies</span>
<span class="line"></span>}</span></code></pre><p>

Finally, the sample <code>:app</code> project is an example of an Android app
which depends on the library, and the source code in the app contains a
violation of the lint check defined in the <code>:checks</code> project. If you
run <code>./gradlew :app:lint</code> to analyze the app, the build will fail
emitting the custom lint check.

</p>
<a class="target" name="localchecks">&nbsp;</a><a class="target" name="publishingalintcheck/android/localchecks">&nbsp;</a><a class="target" name="toc4.1.3">&nbsp;</a><h3>Local Checks</h3>
<p>


What if you aren't publishing a library, but you'd like to apply
some checks locally for your own codebase?

</p><p>

You can use a similar approach to <code>lintPublish</code>: In your app
module, specify

</p><pre class="listing tilde"><code><span class="line"></span>apply plugin: <span class="hljs-string">'com.android.application'</span>
<span class="line"></span>dependencies {
<span class="line"></span>    <span class="hljs-function">lintConfig <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">':checks'</span></span>)
<span class="line"></span>    <span class="hljs-comment">// other dependencies</span>
<span class="line"></span>}</span></code></pre><p>

Now, when lint runs on this application, it will apply the checks
provided from the given project.

</p><p>

</p><div class="admonition warning">This mechanism works well on the CI server for enforcing local code
   conventions, and it also works for developers on your team; the
   errors should be flagged in the IDE (providing they are analyzing
   single-file scopes). However, there have been various bugs and
   difficulties around the lint checks getting rebuilt after changes or
   clean builds. There are some bugs in the Android Gradle Plugin issue
   tracker for this.</div>

<p></p>
<a class="target" name="unpublishing">&nbsp;</a><a class="target" name="publishingalintcheck/android/unpublishing">&nbsp;</a><a class="target" name="toc4.1.4">&nbsp;</a><h3>Unpublishing</h3>
<p>


If you end up “deleting” a lint check, perhaps because the original
conditions for the lint check are not true, don't just stop
distributing lint checks with your library. Instead, you'll want to
update your <code>IssueRegistry</code> to override the <code>deletedIssues</code> property to
return your deleted issue id or ids:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-comment">/**
<span class="line"></span> * The issue id's from any issues that have been deleted from this
<span class="line"></span> * registry. This is here such that when an issue no longer applies
<span class="line"></span> * and is no longer registered, any existing mentions of the issue
<span class="line"></span> * id in baselines, lint.xml files etc are gracefully handled.
<span class="line"></span> */</span>
<span class="line"></span>open val deletedIssues: <span class="hljs-keyword">List</span>&lt;<span class="hljs-keyword">string</span>&gt; = emptyList()</code></pre><p>

The reason you'll want to do this is listed right there in the doc: If
you don't do this, and if users have for example listed your issue id
in their <code>build.gradle</code> file or in <code>lint.xml</code> to say change the
severity, then lint will report an error that it's an unknown id. This
is done to catch issue id typos. And if the user has a baseline file
listing incidents from your check, then if your issue id is not
registered as deleted, lint will think this is an issue that has been
“fixed“ since it's no longer reported, and lint will issue an
informational message that the baseline contains issues no longer
reported (which is done such that users can update their baseline
files, to ensure that the fixed issues aren't reintroduced again.)

</p><p>



</p>
<a class="target" name="lintcheckunittesting">&nbsp;</a><a class="target" name="lintcheckunittesting">&nbsp;</a><a class="target" name="toc5">&nbsp;</a><h1>Lint Check Unit Testing</h1>
<p>


Lint has a dedicated testing library for lint checks. To use it,
add this dependency to your lint check Gradle project:

</p><pre class="listing backtick"><code><span class="line"></span>testImplementation <span class="hljs-string">"com.android.tools.lint:lint-tests:<span class="hljs-variable">$lintVersion</span>"</span></code></pre><p>

This lends itself nicely to test-driven development. When we get bug
reports of a false positive, we typically start by adding the text for
the repro case, ensure that the test is failing, and then work on the
bug fix (often setting breakpoints and debugging through the unit test)
until it passes.

</p>
<a class="target" name="creatingaunittest">&nbsp;</a><a class="target" name="lintcheckunittesting/creatingaunittest">&nbsp;</a><a class="target" name="toc5.1">&nbsp;</a><h2>Creating a Unit Test</h2>
<p>


Here's a sample lint unit test for a simple, sample lint check which
just issues warnings whenever it sees the word “lint” mentioned
in a string:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">package</span> com.example.lint.checks
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.checks.infrastructure.TestFiles.java
<span class="line"></span><span class="hljs-keyword">import</span> com.android.tools.lint.checks.infrastructure.TestLintTask.lint
<span class="line"></span><span class="hljs-keyword">import</span> org.junit.Test
<span class="line"></span>
<span class="line"></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleCodeDetectorTest</span> </span>{
<span class="line"></span>    <span class="hljs-meta">@Test</span>
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testBasic</span><span class="hljs-params">()</span></span> {
<span class="line"></span>        lint().files(
<span class="line"></span>            java(
<span class="line"></span>                <span class="hljs-string">"""
<span class="line"></span>                package test.pkg;
<span class="line"></span>                public class TestClass1 {
<span class="line"></span>                    // In a comment, mentioning "lint" has no effect
<span class="line"></span>                    private static String s1 = "Ignore non-word usages: linting";
<span class="line"></span>                    private static String s2 = "Let's say it: lint";
<span class="line"></span>                }
<span class="line"></span>                """</span>
<span class="line"></span>            ).indented()
<span class="line"></span>        )
<span class="line"></span>        .issues(SampleCodeDetector.ISSUE)
<span class="line"></span>        .run()
<span class="line"></span>        .<span class="hljs-keyword">expect</span>(
<span class="line"></span>            <span class="hljs-string">"""
<span class="line"></span>            src/test/pkg/TestClass1.java:5: Warning: This code mentions lint: Congratulations [SampleId]
<span class="line"></span>                private static String s2 = "Let's say it: lint";
<span class="line"></span>                                           ∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼∼
<span class="line"></span>            0 errors, 1 warnings
<span class="line"></span>            """</span>
<span class="line"></span>        )
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

Lint's testing API is a “fluent API”; you chain method calls together,
and the return objects determine what is allowed next.

</p><p>

Notice how we construct a test object here on line 10 with the <code>lint()</code>
call. This is a “lint test task”, which has a number of setup methods
on it (such as the set of source files we want to analyze), the issues
it should consider, etc.

</p><p>

Then, on line 23, the <code>run()</code> method. This runs the lint unit test, and
then it returns a result object. On the result object we have a number
of methods to verify that the test succeeded. For a test making sure we
don't have false positives, you can just call <code>expectClean()</code>. But the
most common operation is to call <code>expect(output)</code>.

</p><p>

</p><div class="admonition tip">Notice how we're including the whole text output here; including not
   just the error message and line number, but lint's output of the
   relevant line and the error range (using ~~~~ characters).

<p></p><p>

   This is the recommended practice for lint checks. It may be tempting
   to avoid “duplication” of repeating error messages in the tests
   (“DRY”), so some developers have written tests where they just
   assert that a given test has say “2 warnings”. But this isn't
   testing that the error range is exactly what you expect (which
   matters a lot when users are seeing the lint check from the IDE,
   since that's the underlined region), and it could also continue to
   pass even if the errors flagged are no longer what you intended.

</p><p>

   Finally, even if the location is correct today, it may not be
   correct tomorrow. Several times in the past, some unit tests in
   lint's built-in checks have started failing after an update to the
   Kotlin compiler because of some changes to the AST which required
   tweaks here and there.</p></div>

<p></p>
<a class="target" name="computingtheexpectedoutput">&nbsp;</a><a class="target" name="lintcheckunittesting/computingtheexpectedoutput">&nbsp;</a><a class="target" name="toc5.2">&nbsp;</a><h2>Computing the Expected Output</h2>
<p>


You may wonder how we knew what to paste into our <code>expect</code> call
to begin with.

</p><p>

We didn't. When you write a test, simply start with
<code>expect("")</code>, and run the test. It will fail. You can now
copy the actual output into the <code>expect</code> call as the expected
output, provided of course that it's correct!

</p>
<a class="target" name="testfiles">&nbsp;</a><a class="target" name="lintcheckunittesting/testfiles">&nbsp;</a><a class="target" name="toc5.3">&nbsp;</a><h2>Test Files</h2>
<p>


On line 11, we construct a Java test file. We call <code>java(...)</code> and pass
in the source file contents. This constructs a <code>TestFile</code>, and there
are a number of different types of test source files, such as for
Kotlin files, manifest files, icons, property files, and so on.

</p><p>

Using test file descriptors like this to <strong class="asterisk">describe</strong> an input file has
a number of advantages over the traditional approach of checking in
test files as sources:

</p><p>

</p><ul>
<li class="asterisk">Everything is kept together, so it's easier to look at a test and see
  what it analyzes and what the expected results are. This is
  particularly important for complex lint checks which test a lot of
  scenarios. As of this writing, <code>ApiDetectorTest</code> has 157 individual
  unit tests.

<p></p><p>

  </p><center><div class="image" style=""><a href="api-guide/nested-test-files.png" target="_blank"><img class="markdeep" src="api-guide/nested-test-files.png"></a><center><span class="imagecaption">Multiple test files shown inline</span></center></div></center>

<p></p><p>

</p></li>
<li class="asterisk">Lint can provide a DSL to construct test files easily. For example,
  <code>projectProperties().compileSdk(17)</code> and
  <code>manifest().minSdk(5).targetSdk(17)</code> construct a <code>project.properties</code>
  and an <code>AndroidManifest.xml</code> file with the correct contents to
  specify for example the right <uses-sdk> element setting up the
  <code>minSdkVersion</code> and <code>targetSdkVersion</code>.

<p></p><p>

   For icons, we can construct bitmaps like this:</p></uses-sdk></li></ul>

<p></p><pre class="listing backtick"><code><span class="line"></span>        <span class="hljs-selector-tag">image</span>("res/mipmap-hdpi/my_launcher2_round.png", <span class="hljs-number">50</span>, <span class="hljs-number">50</span>)
<span class="line"></span>           <span class="hljs-selector-class">.fillOval</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>xFFFFFFFF)
<span class="line"></span>           <span class="hljs-selector-class">.text</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, "x", <span class="hljs-number">0</span>xFFFFFFFF))</code></pre><p>


</p><ul>
<li class="asterisk">Similarly, when we construct <code>java()</code> or <code>kotlin()</code> test sources, we
  don't have to name the files, because lint will analyze the source
  code and figure out what the class file should be named and where to
  place it.

<p></p><p>

</p></li>
<li class="asterisk">We can easily “parameterize” our test files. For example, if you want
  to run your unit test against a 100K json file, you can construct it
  programmatically; you don't have to check one in. As another example
  you can programmatically create a number of repetitive scenarios.

<p></p><p>

</p></li>
<li class="asterisk">Since test sources often (deliberately!) have errors in them (which
  is relevant when lint is unning on the fly inside the IDE editor),
  this sometimes causes problems with the tooling; for example, some
  code review tools will flag “disallowed” constructs or things like
  tabs or trailing spaces, which may be deliberate in a lint unit test.

<p></p><p>

</p></li>
<li class="asterisk">You can test running in single-file mode, which is how lint is run
  on the fly in the editor.

<p></p><p>

</p></li>
<li class="asterisk">Lint originally checked in test sources as individual files.
  Unfortunately over time, source files ended up getting reused by
  multiple tests. And that made it harder to make changes, or figure
  out whether test sources are still in use, and so on.

<p></p><p>

</p></li>
<li class="asterisk">Last but not least, because all the test construction methods
  specify the correct mime type for their string parameters, IntelliJ
  will actually syntax highlight the test source declarations! Here's
  how this looks:

<p></p><p>

  </p><center><div class="image" style=""><a href="api-guide/nested-syntax-highlighting.png" target="_blank"><img class="markdeep" src="api-guide/nested-syntax-highlighting.png"></a><center><span class="imagecaption">Screenshot of nested highlighting</span></center></div></center>

<p></p><p>

</p></li>
<li class="asterisk">Finally, but most importantly, with the descriptors of your test
  scenarios, lint can re-run your tests under a number of different
  scenarios, including modifying your source files and project layout.
  This concept is documented in more detail in the <a href="#testmodes">test
  modes</a> chapter.</li></ul>

<p></p>
<a class="target" name="trimmingindents?">&nbsp;</a><a class="target" name="lintcheckunittesting/trimmingindents?">&nbsp;</a><a class="target" name="toc5.4">&nbsp;</a><h2>Trimming indents?</h2>
<p>


Notice how in the above Kotlin unit tests we used raw strings, <strong class="asterisk">and</strong>
we indented the sources to be flush with the opening “”“ string
delimiter.

</p><p>

You might be tempted to call <code>.trimIndent()</code> on the raw string.
However, doing that would break the above nested syntax highlighting
method (or at least it used to). Therefore, instead, call <code>.indented()</code>
on the test file itself, not the string, as shown on line 20.

</p><p>

Note that we don't need to do anything with the <code>expect</code> call; lint
will automatically call <code>trimIndent()</code> on the string passed in to it.

</p>
<a class="target" name="dollarsinrawstrings">&nbsp;</a><a class="target" name="lintcheckunittesting/dollarsinrawstrings">&nbsp;</a><a class="target" name="toc5.5">&nbsp;</a><h2>Dollars in Raw Strings</h2>
<p>


Kotlin requires that raw strings have to escape the dollar ($)
character. That's normally not a problem, but for some source files, it
makes the source code look <strong class="asterisk">really</strong> messy and unreadable.

</p><p>

For that reason, lint will actually convert $ into ＄ (a unicode wide
dollar sign). Lint lets you use this character in test sources, and it
always converts the test output to use it (though it will convert in
the opposite direction when creating the test sources on disk).

</p>
<a class="target" name="quickfixes">&nbsp;</a><a class="target" name="lintcheckunittesting/quickfixes">&nbsp;</a><a class="target" name="toc5.6">&nbsp;</a><h2>Quickfixes</h2>
<p>


If your lint check registers quickfixes with the reported incidents,
it's trivial to test these as well.

</p><p>

For example, for a lint check result which flags two incidents, with a
single quickfix, the unit test looks like this:

</p><pre class="listing backtick"><code><span class="line"></span>lint().files(<span class="hljs-operator">...</span>)
<span class="line"></span>    .run()
<span class="line"></span>    .expect(expected)
<span class="line"></span>    .expectFixDiffs(
<span class="line"></span>        <span class="hljs-string">""</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"Fix for res/layout/textsize.xml line 10: Replace with sp:<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"@@ -11 +11<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"-         android:textSize=<span class="hljs-subst">\"</span>14dp<span class="hljs-subst">\"</span> /&gt;<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"+         android:textSize=<span class="hljs-subst">\"</span>14sp<span class="hljs-subst">\"</span> /&gt;<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"Fix for res/layout/textsize.xml line 15: Replace with sp:<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"@@ -16 +16<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"-         android:textSize=<span class="hljs-subst">\"</span>14dip<span class="hljs-subst">\"</span> /&gt;<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"+         android:textSize=<span class="hljs-subst">\"</span>14sp<span class="hljs-subst">\"</span> /&gt;<span class="hljs-subst">\n</span>"</span>);</code></pre><p>

The <code>expectFixDiffs</code> method will iterate over all the incidents it
found, and in succession, apply the fix, diff the two sources, and
append this diff along with the fix message into the log.

</p><p>

When there are multiple fixes offered for a single incident, it will
iterate through all of these too:

</p><pre class="listing backtick"><code><span class="line"></span>lint().files(<span class="hljs-operator">...</span>)
<span class="line"></span>    .run()
<span class="line"></span>    .expect(expected)
<span class="line"></span>    .expectFixDiffs(
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"Fix for res/layout/autofill.xml line 7: Set autofillHints:<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"@@ -12 +12<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:layout_width=<span class="hljs-subst">\"</span>match_parent<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:layout_height=<span class="hljs-subst">\"</span>wrap_content<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"+         android:autofillHints=<span class="hljs-subst">\"</span>|<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:hint=<span class="hljs-subst">\"</span>hint<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:inputType=<span class="hljs-subst">\"</span>password<span class="hljs-subst">\"</span> &gt;<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"Fix for res/layout/autofill.xml line 7: Set importantForAutofill=<span class="hljs-subst">\"</span>no<span class="hljs-subst">\"</span>:<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"@@ -13 +13<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:layout_height=<span class="hljs-subst">\"</span>wrap_content<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:hint=<span class="hljs-subst">\"</span>hint<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"+         android:importantForAutofill=<span class="hljs-subst">\"</span>no<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"          android:inputType=<span class="hljs-subst">\"</span>password<span class="hljs-subst">\"</span> &gt;<span class="hljs-subst">\n</span>"</span>
<span class="line"></span>        <span class="hljs-operator">+</span> <span class="hljs-string">"  <span class="hljs-subst">\n</span>"</span>);</code></pre>
<a class="target" name="librarydependenciesandstubs">&nbsp;</a><a class="target" name="lintcheckunittesting/librarydependenciesandstubs">&nbsp;</a><a class="target" name="toc5.7">&nbsp;</a><h2>Library Dependencies and Stubs</h2>
<p>


Let's say you're writing a lint check for something like the Android
Jetpack library's <code>RecyclerView</code> widget.

</p><p>

In this case, it's highly likely that your unit test will reference
<code>RecyclerView</code>. But how does lint know what <code>RecyclerView</code> is? If it
doesn't, type resolve won't work, and as a result the detector won't.

</p><p>

You could make your test ”depend“ on the <code>RecyclerView</code>. This is
possible, using the <code>LibraryReferenceTestFile</code>, but is not recommended.

</p><p>

Instead, the recommended approach is to just use ”stubs“; create
skeleton classes which represent only the <strong class="asterisk">signatures</strong> of the
library, and in particular, only the subset that your lint check cares
about.

</p><p>

For example, for lint's own <code>RecyclerView</code> test, the unit test declares
a field holding the recycler view stub:

</p><pre class="listing backtick"><code><span class="line"></span>private val recyclerViewStub = java(
<span class="line"></span>    <span class="hljs-string">"""
<span class="line"></span>    package android.support.v7.widget;
<span class="line"></span>
<span class="line"></span>    import android.content.Context;
<span class="line"></span>    import android.util.AttributeSet;
<span class="line"></span>    import android.view.View;
<span class="line"></span>    import java.util.List;
<span class="line"></span>
<span class="line"></span>    // Just a stub for lint unit tests
<span class="line"></span>    public class RecyclerView extends View {
<span class="line"></span>        public RecyclerView(Context context, AttributeSet attrs) {
<span class="line"></span>            super(context, attrs);
<span class="line"></span>        }
<span class="line"></span>
<span class="line"></span>        public abstract static class ViewHolder {
<span class="line"></span>            public ViewHolder(View itemView) {
<span class="line"></span>            }
<span class="line"></span>        }
<span class="line"></span>
<span class="line"></span>        public abstract static class Adapter&lt;vh extends="" viewholder=""&gt; {
<span class="line"></span>            public abstract void onBindViewHolder(VH holder, int position);
<span class="line"></span>            public void onBindViewHolder(VH holder, int position, List&lt;object&gt; payloads) {
<span class="line"></span>            }
<span class="line"></span>            public void notifyDataSetChanged() { }
<span class="line"></span>        }
<span class="line"></span>    }
<span class="line"></span>    """</span>
<span class="line"></span>).indented()</code></pre><p>

And now, all the other unit tests simply include <code>recyclerViewStub</code>
as one of the test files. For a larger example, see
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/checks/SliceDetectorTest.kt">this test</a>.

</p><p>

</p><div class="admonition tip">In recent versions of lint, the unit testing library will do some
   basic checking to make sure that important symbols <em class="asterisk">do</em> resolve
   correctly. It doesn't check everything (since it's common for unit
   tests to contain snippets from copy paste that aren't relevant to
   the test), but it does check all classes and methods referenced via
   import statements, and any calls or references in the test files
   that match any of the names returned from
   <code>getApplicableMethodNames()</code> or <code>getApplicableReferenceNames()</code>
   respectively.</div>

<p></p><p>

Here's an example of a test failure for an unresolved import:

</p><pre class="listing backtick"><code><span class="line"></span>java.lang.IllegalStateException:
<span class="line"></span>app/src/com/example/MyDiffUtilCallbackJava.java:4: Error:
<span class="line"></span>Couldn't resolve this import [LintError]
<span class="line"></span>import androidx.recyclerview.widget.DiffUtil;
<span class="line"></span>       -------------------------------------
<span class="line"></span>
<span class="line"></span>This usually means that the unit test needs to declare a stub file or
<span class="line"></span>placeholder with the expected signature such that type resolving works.
<span class="line"></span>
<span class="line"></span>If this import is immaterial to the test, either delete it, or mark
<span class="line"></span>this unit test as allowing resolution errors by setting
<span class="line"></span>`allowCompilationErrors()`.
<span class="line"></span>
<span class="line"></span>(This check only enforces import references, not all references, so if
<span class="line"></span>it doesn't matter to the detector, you can just remove the import but
<span class="line"></span>leave references to the class in the code.)</code></pre>
<a class="target" name="binaryandcompiledsourcefiles">&nbsp;</a><a class="target" name="lintcheckunittesting/binaryandcompiledsourcefiles">&nbsp;</a><a class="target" name="toc5.8">&nbsp;</a><h2>Binary and Compiled Source Files</h2>
<p>


If you need to use binaries in your unit tests, there is
a special test file type for that: base64gzip. Here's an
example from a lint check which tries to recognize usage
of Cordova in the bytecode:

</p><pre class="listing backtick"><code><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testVulnerableCordovaVersionInClasses</span><span class="hljs-params">()</span></span> {
<span class="line"></span>    lint().files(
<span class="line"></span>        base64gzip(
<span class="line"></span>            <span class="hljs-string">"bin/classes/org/apache/cordova/Device.class"</span>,
<span class="line"></span>            <span class="hljs-string">""</span> +
<span class="line"></span>                <span class="hljs-string">"yv66vgAAADIAFAoABQAPCAAQCQAEABEHABIHABMBAA5jb3Jkb3ZhVmVyc2lv"</span> +
<span class="line"></span>                <span class="hljs-string">"bgEAEkxqYXZhL2xhbmcvU3RyaW5nOwEABjxpbml0PgEAAygpVgEABENvZGUB"</span> +
<span class="line"></span>                <span class="hljs-string">"AA9MaW5lTnVtYmVyVGFibGUBAAg8Y2xpbml0PgEAClNvdXJjZUZpbGUBAAtE"</span> +
<span class="line"></span>                <span class="hljs-string">"ZXZpY2UuamF2YQwACAAJAQAFMi43LjAMAAYABwEAGW9yZy9hcGFjaGUvY29y"</span> +
<span class="line"></span>                <span class="hljs-string">"ZG92YS9EZXZpY2UBABBqYXZhL2xhbmcvT2JqZWN0ACEABAAFAAAAAQAJAAYA"</span> +
<span class="line"></span>                <span class="hljs-string">"BwAAAAIAAQAIAAkAAQAKAAAAHQABAAEAAAAFKrcAAbEAAAABAAsAAAAGAAEA"</span> +
<span class="line"></span>                <span class="hljs-string">"AAAEAAgADAAJAAEACgAAAB4AAQAAAAAABhICswADsQAAAAEACwAAAAYAAQAA"</span> +
<span class="line"></span>                <span class="hljs-string">"AAUAAQANAAAAAgAO"</span>
<span class="line"></span>        )`
<span class="line"></span>    ).run().<span class="hljs-keyword">expect</span>(</code></pre><p>

Here, ”base64gzip“ means that the file is gzipped and then base64
encoded.

</p><p>

If you want to compute the base64gzip string for a given file, a simple
way to do it is to add this statement at the beginning of your test:

</p><pre class="listing backtick"><code><span class="line"></span>assertEquals(<span class="hljs-string">""</span>, TestFiles.toBase64gzip(<span class="hljs-name">File</span>(<span class="hljs-string">"/tmp/mybinary.bin"</span>)))</code></pre><p>

The test will fail, and now you have your output to copy/paste into the
test.

</p><p>

However, if you're writing byte-code based tests, don't just hard code
in the .class file or .jar file contents like this. Lint's own unit
tests did that, and it's hard to later reconstruct what the byte code
was later if you need to make changes or extend it to other bytecode
formats.

</p><p>

Instead, use the new <code>compiled</code> or <code>bytecode</code> test files. The key here
is that they automate a bit of the above process: the test file
provides a source test file, as well as a set of corresponding binary
files (since a single source file can create multiple class files, and
for Kotlin, some META-INF data).

</p><p>

Here's an example of a lint test which is using <code>bytecode(...)</code> to
describe binary files:
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/client/api/JarFileIssueRegistryTest.kt?q=testNewerLintBroken"></a><a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/client/api/JarFileIssueRegistryTest.kt?q=testNewerLintBroken" class="url">https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/client/api/JarFileIssueRegistryTest.kt?q=testNewerLintBroken</a>

</p><p>

Initially, you just specify the sources, and when no binary data
has been provided, lint will instead attempt to compile the sources
and emit the full test file registration.

</p><p>

This isn't just a convenience; lint's test infrastructure also uses
this to test some additional scenarios (for example, in a multi- module
project it will only provide the binaries, not the sources, for
upstream modules.)

</p>
<a class="target" name="mydetectorisn'tinvokedfromatest!">&nbsp;</a><a class="target" name="lintcheckunittesting/mydetectorisn'tinvokedfromatest!">&nbsp;</a><a class="target" name="toc5.9">&nbsp;</a><h2>My Detector Isn't Invoked From a Test!</h2>
<p>


One common question we hear is
</p><blockquote>
 My Detector works fine when I run it in the IDE or from Gradle, but
 from my unit test, my detector is never called! Why?</blockquote>

<p></p><p>

This is almost always because the test sources are referring to some
library or dependency which isn't on the class path. See the ”Library
Dependencies and Stubs“ section above, as well as the <a href="#frequentlyaskedquestions">frequently asked
questions</a>.

</p><p>



</p>
<a class="target" name="testmodes">&nbsp;</a><a class="target" name="testmodes">&nbsp;</a><a class="target" name="toc6">&nbsp;</a><h1>Test Modes</h1>
<p>


Lint's unit testing machinery has special support for “test modes”,
where it repeats a unit test under different conditions and makes sure
the test continues to pass with the same test results — the same
warnings in the same test files.

</p><p>

There are a number of built-in test modes:

</p><p>

</p><ul>
<li class="asterisk">Test modes which makes small tweaks to the source files which
  should be compatible, such as
<ul>
  <li class="asterisk">Inserting unnecessary parentheses
</li>
  <li class="asterisk">Replacing imported symbols with fully qualified names
</li>
  <li class="asterisk">Replacing imported symbols with Kotlin import aliases
</li>
  <li class="asterisk">Replacing types with typealiases
</li>
  <li class="asterisk">Reordering Kotlin named arguments
</li>
  <li class="asterisk">Replacing simple functions with Kotlin expression bodies
</li>
  <li class="asterisk">etc
</li></ul>
</li><li class="asterisk">A test mode which changes that detectors are correctly handling
  Kotlin literal expressions by running them both with and without
  the upcoming UiInjectionHost mode which will change the
  representation of strings in an upcoming Kotlin version
</li>
<li class="asterisk">A partial analysis test mode which runs the tests in “partial
  analysis” mode; two phases, analysis and reporting, with
  minSdkVersion set to 1 during analysis and set to the true test
  value during reporting etc.
</li>
<li class="asterisk">Bytecode Only: Any test files that specify both source and bytecode
  will only use the bytecode
</li>
<li class="asterisk">Source Only: Any test files that specify both source and bytecode
  will only use the source code</li></ul>

<p></p><p>

These are built-in test modes which will be applied to all detector
tests, but you can opt out of any test modes by invoking the
<code>skipTestModes</code> DSL method, as described below.

</p><p>

You can also add in your own test modes. For example, lint adds its own
internal test mode for making sure the built-in annotation checks works
with Android platform annotations in the following test mode:

</p><p>

<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/checks/AndroidPlatformAnnotationsTestMode.kt"></a><a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/checks/AndroidPlatformAnnotationsTestMode.kt" class="url">https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/checks/AndroidPlatformAnnotationsTestMode.kt</a>

</p>
<a class="target" name="howtodebug">&nbsp;</a><a class="target" name="testmodes/howtodebug">&nbsp;</a><a class="target" name="toc6.1">&nbsp;</a><h2>How to debug</h2>
<p>


Let's say you have a test failure in a particular test mode, such
as <code>TestMode.PARENTHESIZED</code> which inserts unnecessary parentheses
into the source code to make sure detectors are properly skipping
through <code>UParenthesizedExpression</code> nodes.

</p><p>

If you just run this under the debugger, lint will run through
all the test modes as usual, which means you'll need to skip
through a lot of intermediate breakpoint hits.

</p><p>

For these scenarios, it's helpful to limit the test run to <strong class="asterisk">only</strong> the
target test mode. To do this, go and specify that specific test mode as
part of the run setup by adding the following method declaration into
your detector class:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lint</span><span class="hljs-params">()</span></span>: TestLintTask {
<span class="line"></span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.lint().testModes(TestMode.PARENTHESIZED)
<span class="line"></span>}</code></pre><p>

Now when you run your test, it will run <em class="asterisk">only</em> this test mode, so you
can set breakpoints and start debugging through the scenario without
having to figure out which mode you're currently being invoked in.

</p><p>

</p><div class="admonition warning">Don't forget to remove that override when you're done!</div>

<p></p>
<a class="target" name="handlingintentionalfailures">&nbsp;</a><a class="target" name="testmodes/handlingintentionalfailures">&nbsp;</a><a class="target" name="toc6.2">&nbsp;</a><h2>Handling Intentional Failures</h2>
<p>


There are cases where your lint check is doing something very
particular related to the changes made by the test mode which means
that the test mode doesn't really apply. For example, there is a test
mode which adds unnecessary parentheses, to make sure that the detector
is properly handling the case where there are intermediate parenthesis
nodes in the AST. Normally, every lint check should behave the same
whether or not optional parentheses are present. But, if the lint check
you are writing is actually parenthesis specific, such as suggesting
removal of optional parentheses, then obviously in that case you don't
want to apply this test mode.

</p><p>

To do this, there's a special test DSL method you can add,
<code>skipTestModes</code>. Adding a comment for why that particular mode is
skipped is useful as well.

</p><pre class="listing tilde"><code><span class="line"></span>lint().files(...)
<span class="line"></span>    .allowCompilationErrors()
<span class="line"></span>    <span class="hljs-comment">// When running multiple passes of lint each pass will warn</span>
<span class="line"></span>    <span class="hljs-comment">// about the obsolete lint checks; that's fine</span>
<span class="line"></span>    .skipTestModes(TestMode.PARTIAL)
<span class="line"></span>    .run()
<span class="line"></span>    .expectClean()</code></pre>
<a class="target" name="source-modifyingtestmodes">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes">&nbsp;</a><a class="target" name="toc6.3">&nbsp;</a><h2>Source-Modifying Test Modes</h2>
<p>


The most powerful test modes are those that make some deliberate
transformations to your source code, to test variations of the code
patterns that may appear in the wild. Examples of this include having
optional parentheses, or fully qualified names.

</p><p>

Lint will make these transformations, then run your tests on the
modified sources, and make sure the results are the same — except for
the part of the output which shows the relevant source code, since that
part is expected to differ due to the modifications.

</p><p>

When lint finds a failure, it will abort with a diff that includes not
just the different error output between the default mode and the source
modifying mode, but the source files as well; that makes it easier to
spot what the difference is.

</p><p>

In the following screenshot for example we've run a failing test inside
IntelliJ, and have then clicked on the Show Difference link in the test
output window (Ctrl+D or Cmd-D) which shows the test failure diff
nicely:

</p><p>

</p><center><div class="image" style=""><a href="api-guide/fully-qualified-error.png" target="_blank"><img class="markdeep" src="api-guide/fully-qualified-error.png"></a><center><span class="imagecaption"><a class="target" name="figure_fqn">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;1:</b> Screenshot of test failure</span></center></div></center>

<p></p><p>

This is a test mode which converts all symbols to fully qualified
names; in addition to the labeled output at the top we can see the
diffs in the test case files below the error output diff. The test
files include line numbers to help make it easy to correlate extra or
missing warnings with their line numbers to the changed source code.

</p>
<a class="target" name="fullyqualifiednames">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/fullyqualifiednames">&nbsp;</a><a class="target" name="toc6.3.1">&nbsp;</a><h3>Fully Qualified Names</h3>
<p>


The <code>TestMode.FULLY_QUALIFIED</code> test mode will rewrite the source files
such that all symbols that it can resolve are replaced with fully
qualified names.

</p><p>

For example, this mode will convert the following code:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">import</span> android.widget.RemoteViews
<span class="line"></span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(packageName: <span class="hljs-type">String</span>, other: <span class="hljs-type">Any</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> rv = RemoteViews(packageName, R.layout.test)
<span class="line"></span>    <span class="hljs-keyword">val</span> ov = other <span class="hljs-keyword">as</span> RemoteViews
<span class="line"></span>}</code></pre><p>

to

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">import</span> android.widget.RemoteViews
<span class="line"></span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(packageName: <span class="hljs-type">String</span>, other: <span class="hljs-type">Any</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> rv = android.widget.RemoteViews(packageName, R.layout.test)
<span class="line"></span>    <span class="hljs-keyword">val</span> ov = other <span class="hljs-keyword">as</span> android.widget.RemoteViews
<span class="line"></span>}</code></pre><p>

This makes sure that your detector handles not only the case where a
symbol appears in its normal imported state, but also when it is fully
qualified in the code, perhaps because there is a different competing
class of the same name.

</p><p>

This will typically catch cases where the code is incorrectly just
comparing the identifier at the call node instead of the fully
qualified name.

</p><p>

For example, one detector's tests failed in this mode because
it was looking to identify references to an <code>EnumSet</code>,
and the code looked like this:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkEnumSet</span><span class="hljs-params">(node: <span class="hljs-type">UCallExpression</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> receiver = node.receiver
<span class="line"></span>    <span class="hljs-keyword">if</span> (receiver <span class="hljs-keyword">is</span> USimpleNameReferenceExpression &amp;&amp;
<span class="line"></span>        receiver.identifier == <span class="hljs-string">"EnumSet"</span>
<span class="line"></span>    ) {</code></pre><p>

which will work for code such as <code>EnumSet.of()</code> but not
<code>java.util.EnumSet.of()</code>.

</p><p>

Instead, use something like this:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkEnumSet</span><span class="hljs-params">(node: <span class="hljs-type">UCallExpression</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> targetClass = node.resolve()?.containingClass?.qualifiedName
<span class="line"></span>        ?: <span class="hljs-keyword">return</span>
<span class="line"></span>    <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-string">"java.util.EnumSet"</span>) {</code></pre><p>

As with all the source transforming test modes, there are cases where
it doesn't apply. For example, lint had a built-in check for camera
EXIF metadata, encouraging you to import the androidx version of the
library instead of using the built-in version. If it sees you using the
platform one it will normally encourage you to import the androidx one
instead:

</p><pre class="listing backtick"><code><span class="line"></span>src<span class="hljs-operator">/</span>test<span class="hljs-operator">/</span>pkg<span class="hljs-operator">/</span>ExifUsage.java:<span class="hljs-number">9</span>: Warning: Avoid <span class="hljs-keyword">using</span> android.media.ExifInterface; use androidx.exifinterface.media.ExifInterface instead [ExifInterface]
<span class="line"></span>        android.media.ExifInterface exif <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> android.media.ExifInterface(path);
<span class="line"></span>        <span class="hljs-comment">---------------------------</span></code></pre><p>

However, if you explicitly (via fully qualified imports) reference the
platform one, in that case the lint check does not issue any warnings
since it figures you're deliberately trying to use the older version.
And in this test mode, the results between the two obviously differ,
and that's fine; as usual we'll deliberately turn off the check in this
detector:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> TestLintTask <span class="hljs-title">lint</span><span class="hljs-params">()</span> </span>{
<span class="line"></span>    <span class="hljs-comment">// This lint check deliberately treats fully qualified imports</span>
<span class="line"></span>    <span class="hljs-comment">// differently (they are interpreted as a deliberate usage of</span>
<span class="line"></span>    <span class="hljs-comment">// the discouraged API) so the fully qualified equivalence test</span>
<span class="line"></span>    <span class="hljs-comment">// does not apply:</span>
<span class="line"></span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.lint().skipTestModes(TestMode.FULLY_QUALIFIED);
<span class="line"></span>}</code></pre><p>



</p><div class="admonition tip">In Kotlin code, you may have code that checks to see if a node is a
   <code>UCallExpression</code>. But note that if a call is fully qualified, the
   node will be a <code>UQualifiedReferenceExpression</code> instead, and you'll
   need to look at its selector. So watch out for code which does
   something like <code>node as? UCallExpression</code>.</div>

<p></p>
<a class="target" name="importaliasing">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/importaliasing">&nbsp;</a><a class="target" name="toc6.3.2">&nbsp;</a><h3>Import Aliasing</h3>
<p>


In Kotlin, you can create an import alias, which lets you refer to
the imported class using an entirely different name.

</p><p>

This test mode will create import aliases for all the import statements
in the file and will replace all the references to the import aliases
instead. This makes sure that the detector handles the equivalent Kotlin
code.

</p><p>

For example, this mode will convert the following code:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">import</span> android.widget.RemoteViews
<span class="line"></span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(packageName: <span class="hljs-type">String</span>, other: <span class="hljs-type">Any</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> rv = RemoteViews(packageName, R.layout.test)
<span class="line"></span>    <span class="hljs-keyword">val</span> ov = other <span class="hljs-keyword">as</span> RemoteViews
<span class="line"></span>}</code></pre><p>

to

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">import</span> android.widget.RemoteViews <span class="hljs-keyword">as</span> IMPORT_ALIAS_1_REMOTEVIEWS
<span class="line"></span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(packageName: <span class="hljs-type">String</span>, other: <span class="hljs-type">Any</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> rv = IMPORT_ALIAS_1_REMOTEVIEWS(packageName, R.layout.test)
<span class="line"></span>    <span class="hljs-keyword">val</span> ov = other <span class="hljs-keyword">as</span> IMPORT_ALIAS_1_REMOTEVIEWS
<span class="line"></span>}</code></pre>
<a class="target" name="typealiasing">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/typealiasing">&nbsp;</a><a class="target" name="toc6.3.3">&nbsp;</a><h3>Type Aliasing</h3>
<p>


Kotlin also lets you alias types using the <code>typealias</code> keyword.
This test mode is similar to import aliasing, but applied to all
types. In addition to the different AST representations of import
aliases and type aliases, they apply to different things.

</p><p>

For example, if we import TreeMap, and we have a code reference such as
<code>TreeMap&lt;string&gt;</code>, then the import alias will alias the tree map class
itself, and the reference would look like <code>IMPORT_ALIAS_1&lt;string&gt;</code>,
whereas for type aliases, the alias would be for the whole
<code>TreeMap&lt;string&gt;</code>, and the code reference would be <code>TYPE_ALIAS_1</code>.

</p><p>

Also, import aliases will only apply to the explicitly imported
classes, whereas type aliases will apply to all types, including Int,
Boolean, List<string>, etc.

</string></p><p>

For example, this mode will convert the following code:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">import</span> android.widget.RemoteViews
<span class="line"></span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(packageName: <span class="hljs-type">String</span>, other: <span class="hljs-type">Any</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> rv = RemoteViews(packageName, R.layout.test)
<span class="line"></span>    <span class="hljs-keyword">val</span> ov = other <span class="hljs-keyword">as</span> RemoteViews
<span class="line"></span>}</code></pre><p>

to

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">import</span> android.widget.RemoteViews
<span class="line"></span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(packageName: <span class="hljs-type">TYPE_ALIAS_1</span>, other: <span class="hljs-type">TYPE_ALIAS_2</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> rv = RemoteViews(packageName, R.layout.test)
<span class="line"></span>    <span class="hljs-keyword">val</span> ov = other <span class="hljs-keyword">as</span> TYPE_ALIAS_3
<span class="line"></span>}
<span class="line"></span><span class="hljs-keyword">typealias</span> TYPE_ALIAS_1 = String
<span class="line"></span><span class="hljs-keyword">typealias</span> TYPE_ALIAS_2 = Any
<span class="line"></span><span class="hljs-keyword">typealias</span> TYPE_ALIAS_3 = RemoteViews</code></pre>
<a class="target" name="parenthesismode">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/parenthesismode">&nbsp;</a><a class="target" name="toc6.3.4">&nbsp;</a><h3>Parenthesis Mode</h3>
<p>


Kotlin and Java code is allowed to contain extra clarifying
parentheses. Sometimes these are leftovers from earlier more
complicated expressions where when the expression was simplified the
parentheses were left in place.

</p><p>

In UAST, parentheses are represented in the AST (via a
<code>UParenthesizedExpression</code> node). While this is good since it allows
you to for example write lint checks which identifies unnecessary
parentheses, it introduces a complication: you can't just look at a
node's parent to for example see if it's a <code>UQualifiedExpression</code>; you
have to be prepared to look “through” it such that if it's a
<code>UParenthesizedExpression</code> node, you instead look at its parent in
turn. (And programmers can of course put as (((many unnecessary)))
parentheses as they want, so you may have to skip through repeated
nodes.)

</p><p>

Note also that this isn't just for looking upwards or outwards at
parents. Let's say you're looking at a call and you want to see if the
last argument is a literal expression such as a number or a String. You
<em class="asterisk">can't</em> just use <code>if (call.valueArguments.lastOrNull() is
ULiteralExpression)</code>, because that first argument could be a
<code>UParenthesizedExpression</code>, as in `call(1, true, (“hello”)), so you'd
need to look inside the parentheses.

</p><p>

UAST comes with two functions to help you handle this correctly:

</p><p>

</p><ul>
<li class="asterisk">Whenever you look at the parent, make sure you surround the call with
  <code>skipParenthesizedExprUp(UExpression)</code>.

<p></p><p>

</p></li>
<li class="asterisk">If you are looking at a child node, use the method
  <code>skipParenthesizedExprDown</code>, an extension method on UExpression (and
  from Java import it from UastUtils).</li></ul>

<p></p><p>

To help catch these bugs, lint has a special test mode where it inserts
various redundant parentheses in your test code, and then makes sure
that the same errors are reported. The error output will of course
potentially vary slightly (since the source code snippets shown will
contain extra parentheses), but the test will ignore these differences
and only fail if it sees new errors reported or expected errors not
reported.

</p><p>

In the unlikely event that your lint check is actually doing something
parenthesis specific, you can turn off this test mode using
<code>.skipTestModes(TestMode.PARENTHESIZED)</code>.

</p><p>

For example, this mode will convert the following code:

</p><pre class="listing tilde"><code><span class="line"></span>(t <span class="hljs-keyword">as</span>? String)?.plus(<span class="hljs-string">"other"</span>)?.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>)?.dec()?.inc()
<span class="line"></span><span class="hljs-string">"foo"</span>.chars().allMatch { it.dec() &gt; <span class="hljs-number">0</span> }.toString()</code></pre><p>

to

</p><pre class="listing tilde"><code><span class="line"></span>(((((t <span class="hljs-keyword">as</span>? String))?.plus(<span class="hljs-string">"other"</span>))?.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>))?.dec())?.inc()
<span class="line"></span>((<span class="hljs-string">"foo"</span>.chars()).allMatch { (it.dec() &gt; <span class="hljs-number">0</span>) }).toString()</code></pre><p>

By default the parenthesis mode limits itself to “likely” unnecessary
parentheses; in particular, it won't put extra parenthesis around
simple literals, like (1) or (false). You can explicitly construct
<code>ParenthesizedTestMode(includeUnlikely=true)</code> if you want additional
parentheses.

</p>
<a class="target" name="argumentreordering">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/argumentreordering">&nbsp;</a><a class="target" name="toc6.3.5">&nbsp;</a><h3>Argument Reordering</h3>
<p>


In Kotlin, with named parameters you're allowed to pass in the
arguments in any order. To handle this correctly, detectors should
never just line up parameters and arguments and match them by index;
instead, there's a <code>computeArgumentMapping</code> method on <code>JavaEvaluator</code>
which returns a map from argument to parameter.

</p><p>

The argument-reordering test mode will locate all calls to Kotlin
methods, and it will then first add argument names to any parameter not
already specifying a name, and then it will shift all the arguments
around, then repeat the test. This will catch any detectors which were
incorrectly making assumptions about argument order.

</p><p>

(Note that the test mode will not touch methods that have vararg
parameters for now.)

</p><p>

For example, this mode will convert the following code:

</p><pre class="listing tilde"><code><span class="line"></span>test(<span class="hljs-string">"test"</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">true</span>)</code></pre><p>

to

</p><pre class="listing tilde"><code><span class="line"></span>test(n = <span class="hljs-number">5</span>, z = <span class="hljs-literal">true</span>, s = <span class="hljs-string">"test"</span>)</code></pre>
<a class="target" name="bodyremoval">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/bodyremoval">&nbsp;</a><a class="target" name="toc6.3.6">&nbsp;</a><h3>Body Removal</h3>
<p>


In Kotlin, you can replace

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>: List&lt;string&gt; {
<span class="line"></span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) listOf(<span class="hljs-string">"hello"</span>) <span class="hljs-keyword">else</span> emptyList()
<span class="line"></span>}</code></pre><p>

with

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>: List&lt;string&gt; = <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) listOf(<span class="hljs-string">"hello"</span>) <span class="hljs-keyword">else</span> emptyList()</code></pre><p>

Note that these two ASTs do not look the same; we'll only have an
<code>UReturnExpression</code> node in the first case. Therefore, you have to be
careful if your detector is just visiting <code>UReturnExpression</code>s in order
to find exit points.

</p><p>

The body removal test mode will identify all scenarios where it can
replace a simple function declaration with an expression body, and
will make sure that the test results are the same, to make sure detectors are handling both AST variations.

</p><p>

It also does one more thing: it toggled optional braces from if
expressions — converting

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">if</span> (x &lt; y) { test(x+<span class="hljs-number">1</span>) } <span class="hljs-keyword">else</span> test(x+<span class="hljs-number">2</span>)</code></pre><p>

to

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">if</span> (x &lt; y) test(x+<span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> { test(x+<span class="hljs-number">2</span>) }</code></pre><p>

(Here it has removed the braces around the if-then body since they are
optional, and it has added braces around the if-else body since it did
not have optional braces.)

</p><p>

The purpose of these tweaks are similar to the expression body change:
making sure that detectors are properly handling the presence of
absence of <code>UBlockExpression</code> around the child nodes.

</p>
<a class="target" name="iftowhenreplacement">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/iftowhenreplacement">&nbsp;</a><a class="target" name="toc6.3.7">&nbsp;</a><h3>If to When Replacement</h3>
<p>


In Kotlin, you can replace a series of <code>if</code>/<code>else</code> statements with a
single <code>when</code> block. These two alternative do not look the same in the
AST; <code>if</code> expressions show up as <code>UIfExpression</code>, and <code>when</code>
expressions show up as <code>USwitchExpression</code>.

</p><p>

The if-to-when test mode will change all the <code>if</code> statements in Kotlin
lint tests with the corresponding when statement, and makes sure that
the test results remain the same. This ensures that detectors are
properly looking for both <code>UIfExpression</code> and <code>USwitchExpression</code> and
handling each. When this test mode was introduced, around 12 unit tests
in lint's built-in checks (spread across 5 detectors) needed some
tweaks.

</p>
<a class="target" name="whitespacemode">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/whitespacemode">&nbsp;</a><a class="target" name="toc6.3.8">&nbsp;</a><h3>Whitespace Mode</h3>
<p>


This test mode inserts a number of “unnecessary” whitespace characters
in valid places in the source code.

</p><p>

This helps catch bugs where lint checks are improperly making
assumptions about whitespace in the source file, particularly in
quickfix implementations, or when for example looking up a qualified
expression and just taking the <code>asSourceString()</code> or <code>text</code> property of
a PSI element or PSI type and checking it for equality with something
like <code>java.util.List&lt;string&gt;</code>.

</p><p>

For example, some of the built-in checks which performed quickfix
string replacements based on regular expression matching had to be
updated to be prepared for whitespace characters:

</p><pre class="listing tilde"><code><span class="line"></span>+++ b/lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/WakelockDetector.java
<span class="line"></span>@@ -454,7 +454,7 @@ public class WakelockDetector extends Detector implements ClassScanner, SourceCo
<span class="line"></span>     LintFix fix =
<span class="line"></span>             fix().name("Set timeout to 10 minutes")
<span class="line"></span>                     .replace()
<span class="line"></span>-                    .pattern("acquire\\(()\\)")
<span class="line"></span>+                    .pattern("acquire\\s*\\(()\\s*\\)")
<span class="line"></span>                     .with("10*60*1000L /*10 minutes*/")
<span class="line"></span>                     .build();</code></pre>
<a class="target" name="cdatamode">&nbsp;</a><a class="target" name="testmodes/source-modifyingtestmodes/cdatamode">&nbsp;</a><a class="target" name="toc6.3.9">&nbsp;</a><h3>CDATA Mode</h3>
<p>


When declaring string resources, you may want to use XML CDATA sections
instead of plain text. For example, instead of

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="line"></span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
<span class="line"></span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"app_name"</span>&gt;</span>Application Name<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
<span class="line"></span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><p>

you can equivalently use

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="line"></span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
<span class="line"></span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"app_name"</span>&gt;</span>&lt;![CDATA[Application Name]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
<span class="line"></span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><p>

(where you can place newlines and other unescaped text inside the bracketed span.)

</p><p>

This alternative form shows up differently in the XML DOM that is
provided to lint detectors; in particular, if you are iterating through
the <code>Node</code> children of an <code>Element</code>, you should not just look at nodes
with <code>nodeType == Node.TEXT_NODE</code>; you need to also handle <code>noteType ==
Node.CDATA_SECTION_NODE</code>.

</p><p>

This test mode will automatically retry all your tests that define
string resources, and will convert regular text into <code>CDATA</code> and makes
sure the results continue to be the same.

</p><p>



</p>
<a class="target" name="addingquickfixes">&nbsp;</a><a class="target" name="addingquickfixes">&nbsp;</a><a class="target" name="toc7">&nbsp;</a><h1>Adding Quick Fixes</h1>

<a class="target" name="introduction">&nbsp;</a><a class="target" name="addingquickfixes/introduction">&nbsp;</a><a class="target" name="toc7.1">&nbsp;</a><h2>Introduction</h2>
<p>


When your detector reports an incident, it can also provide one or more
“quick fixes“, which are actions the users can invoke in the IDE (or,
for safe fixes, in batch mode) to address the reported incident.

</p><p>

For example, if the lint check reports an unused resource, a quick fix
could offer to remove the unused resource.

</p><p>

In some cases, quick fixes can take partial steps towards fixing the
problem, but not fully. For example, the accessibility lint check which
makes sure that for images you set a content description, the quickfix
can offer to add it — but obviously it doesn't know what description
to put. In that case, the lint fix will go ahead and add the attribute
declaration with the correct namespace and attribute name, but will
leave the value up to the user (so it uses a special quick fix provided
by lint to place a TODO marker as the value, along with selecting just
that TODO string such that the user can type to replace without having
to manually delete the TODO string first.)

</p>
<a class="target" name="thelintfixbuilderclass">&nbsp;</a><a class="target" name="addingquickfixes/thelintfixbuilderclass">&nbsp;</a><a class="target" name="toc7.2">&nbsp;</a><h2>The LintFix builder class</h2>
<p>


The class in lint which represents a quick fix is <code>LintFix</code>.

</p><p>

Note that <code>LintFix</code> is <strong class="asterisk">not</strong> a class you can subclass and then for
example implement your own arbitrary code in something like a
<code>perform()</code> method.

</p><p>

Instead, <code>LintFix</code> has a number of builders where you <em class="asterisk">describe</em> the
action that you would like the quickfix to take. Then, lint will offer
that quickfix in the IDE, and when the user invokes it, lint runs its
own implementation of the various descriptors.

</p><p>

The historical reason for this is that many of the quickfixes in lint
depended on machinery in the IDE (such as code and import cleanup after
an edit operation) that isn't available in lint itself, along with
other concepts that only make sense in the IDE, such as moving the
caret, opening files, selecting text, and so on.

</p><p>

More recently, this is also used to persist quickfixes properly for
later reuse; this is required for <a href="#partialanalysis">partial
analysis</a>.

</p>
<a class="target" name="creatingalintfix">&nbsp;</a><a class="target" name="addingquickfixes/creatingalintfix">&nbsp;</a><a class="target" name="toc7.3">&nbsp;</a><h2>Creating a LintFix</h2>
<p>


Lint fixes use a ”fluent API“; you first construct a <code>LintFix</code>, and on
that method you call various available type methods, which will then
further direct you to the allowed options.

</p><p>

For example, to create a lint fix to set an XML attribute of a given
name to ”true“, use something like this:

</p><pre class="listing tilde"><code><span class="line"></span>LintFix fix = fix().<span class="hljs-keyword">set</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">"singleLine"</span>, <span class="hljs-string">"true"</span>).build()</code></pre><p>

Here the <code>fix()</code> method is provided by the <code>Detector</code> super class, but
that's just a utility method for <code>LintFix.fix()</code> (or in older versions,
<code>LintFix.create()</code>).

</p><p>

There are a number of additional, common methods you can set on
the <code>fix()</code> object:

</p><p>

</p><ul>
<li class="asterisk"><code>name</code>: Sets the description of the lint fix. This should be brief;
  it's in the quickfix popup shown to the user.

<p></p><p>

</p></li>
<li class="asterisk"><code>sharedName</code>: This sets the ”shared“ or ”family“ name: all fixes in
  the file will with the same name can be applied in a single
  invocation by the user. For example, if you register 500 ”Remove
  unused import“ quickfixes in a file, you don't want to force the user
  to have to invoke each and every one. By setting the shared name, the
  user will be offered to <strong class="asterisk">Fix All <em class="asterisk">$family name</em> problems in the
  current file</strong>, which they can then perform to have all 500
  individual fixes applied in one go.

<p></p><p>

</p></li>
<li class="asterisk"><code>autoFix</code>: If you get a lint report and you notice there are a lot of
  incidents that lint can fix automatically, you don't want to have to
  go and open each and every file and all the fixes in the file.
  Therefore, lint can apply the fixes in batch mode; the Gradle
  integration has a <code>lintFix</code> target to perform this, and the <code>lint</code>
  command has an <code>--apply-suggestions</code> option.

<p></p><p>

  However, many quick fixes require user intervention. Not just the
  ones where the user has to choose among alternatives, and not just
  the ones where the quick fix inserts a placeholder value like TODO.
  Take for example lint's built-in check which requires overrides of a
  method annotated with <code>@CallSuper</code> to invoke <code>super.</code> on the
  overridden method. Where should we insert the call — at the
  beginning? At the end?

</p><p>

  Therefore, lint has the <code>autoFix</code> property you can set on a quickfix.
  This indicates that this fix is ”safe“ and can be performed in batch
  mode. When the <code>lintFix</code> target runs, it will only apply fixes marked
  safe in this way.</p></li></ul>

<p></p>
<a class="target" name="availablefixes">&nbsp;</a><a class="target" name="addingquickfixes/availablefixes">&nbsp;</a><a class="target" name="toc7.4">&nbsp;</a><h2>Available Fixes</h2>
<p>


The current set of available quick fix types are:

</p><p>

</p><ul>
<li class="asterisk"><code>fix().replace</code>: String replacements. This is the most general
  mechanism, and allows you to perform arbitrary edits to the source
  code. In addition to the obvious ”replace old string with new“, the
  old string can use a different location range than the incident
  range, you can match with regular expressions (and perform
  replacements on a specific group within the regular expression), and
  so on.

<p></p><p>

  This fix is also the most straightforward way to <strong class="asterisk">delete</strong> text.

</p><p>

  It offers some useful cleanup operations:

</p><p>

</p><ul>
  <li class="minus">Source code cleanup, which will run the IDE's code formatter on the
      modified source code range. This will apply the user's code
      preferences, such as whether there should be a space between a cast
      and the expression, and so on.

<p></p><p>

</p></li>
  <li class="minus">Import cleanup. That means that if you are referencing a new type,
      you don't have to worry about checking whether it is imported and
      if not adding an import statement; you can simply write your string
      replacements using the fully qualified names, and then tag the
      quickfix with the import cleanup option, and when the quickfix is
      performed the import will be added if necessary and all the fully
      qualified references replaced with simple names. And this will also
      correctly handle the scenario where the symbols cannot be replaced
      with simple names because there is a conflicting import of the same
      name from a different package.

<p></p><p>

      Normally, you should write your replacement source code using fully
      qualified names, and then apply <code>shortenNames</code> to the quickfix to
      tell lint to replace fully qualified names with imports; don't try
      to write your quickfix to also add the import statements on its
      own. There's a possibility that a given name cannot be imported
      because it's already importing the same name for a different
      namespace. When using fully qualified names, lint will specifically
      handle this.

</p><p>

      In some cases you cannot use fully qualified names in the code
      snippet; this is the case with Kotlin extension functions for
      example. For that scenario, the replacement quickfix has an
      <code>imports</code> property you can use to specify methods (and classes and
      fields) to import at the same time.

</p><p>

</p></li></ul>
</li><li class="asterisk"><code>fix().annotate</code>: Annotating an element. This will add (or optionally
  replace) an annotation on a source element such as a method. It will
  also handle import management.

<p></p><p>

</p></li>
<li class="asterisk"><code>fix().set</code>: Add XML attributes. This will insert an attribute into
  the given element, applying the user's code style preferences for
  where to insert the attribute. (In Android XML for example there's a
  specific sorting convention which is generally alphabetical, except
  layout params go before other attributes, and width goes before
  height.)

<p></p><p>

  You can either set the value to something specific, or place the
  caret inside the newly created empty attribute value, or set it
  to TODO and select that text for easy type-to-replace.</p></li></ul>

<p></p><p>

</p><div class="admonition tip">If you use the <code>todo()</code> quickfix, it's a good idea to special case
   your lint check to deliberately not accept ”TODO“ as a valid value.
   For example, for lint's accessibility check which makes sure you set
   a content description, it will complain both when you haven't set
   the content description attribute, <strong class="asterisk">and</strong> if the text is set to
   ”TODO“. That way, if the user applies the quickfix, which creates
   the attribute in the right place and moves the focus to the right
   place, the editor is still showing a warning that the content
   description should be set.</div>

<p></p><p>

</p><ul>
<li class="asterisk"><code>fix().unset</code>: Remove XML attribute. This is a special case of add
  attribute.

<p></p><p>

</p></li>
<li class="asterisk"><code>fix().url</code>: Show URL. In some cases, you can't ”fix“ or do anything
  local to address the problem, but you really want to direct the
  user's attention to additional documentation. In that case, you can
  attach a ”show this URL“ quick fix to the incident which will open
  the browser with the given URL when invoked. For example, in a
  complicated deprecation where you want users to migrate from one
  approach to a completely different one that you cannot automate, you
  could use something like this:</li></ul>

<p></p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> message = <span class="hljs-string">"Job scheduling with `GcmNetworkManager` is deprecated: Use AndroidX `WorkManager` instead"</span>
<span class="line"></span><span class="hljs-keyword">val</span> fix = fix()
<span class="line"></span>.url(<span class="hljs-string">"https://developer.android.com/topic/libraries/architecture/workmanager/migrating-gcm"</span>)
<span class="line"></span>.build()</code></pre>
<a class="target" name="combiningfixes">&nbsp;</a><a class="target" name="addingquickfixes/combiningfixes">&nbsp;</a><a class="target" name="toc7.5">&nbsp;</a><h2>Combining Fixes</h2>
<p>


You might notice that lint's APIs to report incidents only takes a
<strong class="asterisk">single</strong> quick fix instead of a list of fixes.

</p><p>

But let's say that it <em class="asterisk">did</em> take a list of quick fixes.

</p><p>

</p><ul>
<li class="minus">Should they <em class="asterisk">all</em> be performed as a single unit? That makes sense if
  you're trying to write a quickfix which performs multiple string
  replacements.

<p></p><p>

</p></li>
<li class="minus">Or should they be offered as separate alternatives for the user to
  choose between? That makes sense if the incident says for example
  that you must set at least one attribute among three possibilities;
  in this case we may want to add quickfixes for setting each attribute.</li></ul>

<p></p><p>

Both scenarios have their uses, so lint makes this explicit:

</p><p>

</p><ul>
<li class="minus"><code>fix().composite</code>: create a ”composite“ fix, which composes the fix
  out of multiple individual fixes, or

<p></p><p>

</p></li>
<li class="minus"><code>fix().alternatives</code>: create an ”alternatives“ fix, which holds a
  number of individual fixes, which lint will present as separate
  options to the user.</li></ul>

<p></p><p>

Here's an example of how to create a composite fix, which will be
performed as a unit; here we're both setting a new attribute and
deleting a previous attribute:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> fix = fix().name(<span class="hljs-string">"Replace with singleLine=\"true\""</span>)
<span class="line"></span>    .composite(
<span class="line"></span>        fix().<span class="hljs-keyword">set</span>(ANDROID_URI, <span class="hljs-string">"singleLine"</span>, <span class="hljs-string">"true"</span>).build(),
<span class="line"></span>        fix().unset(namespace, oldAttributeName).build()
<span class="line"></span>    )</code></pre><p>

And here's an example of how to create an alternatives fix, which are
offered to the user as separate options; this is from our earlier
example of the accessibility check which requires you to set a content
description, which can be set either on the ”text“ attribute or the
“contentDescription” attribute:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> fix = fix().alternatives(
<span class="line"></span>    fix().<span class="hljs-keyword">set</span>().todo(ANDROID_URI, <span class="hljs-string">"text"</span>).build(),
<span class="line"></span>    fix().<span class="hljs-keyword">set</span>().todo(ANDROID_URI, <span class="hljs-string">"contentDescription"</span>)
<span class="line"></span>    .build())</code></pre>
<a class="target" name="refactoringjavaandkotlincode">&nbsp;</a><a class="target" name="addingquickfixes/refactoringjavaandkotlincode">&nbsp;</a><a class="target" name="toc7.6">&nbsp;</a><h2>Refactoring Java and Kotlin code</h2>
<p>


It would be nice if there was an AST manipulation API, similar to UAST
for visiting ASTs, that quickfixes could use to implement refactorings,
but we don't have a library like that. And it's unlikely it would work
well; when you rewrite the user's code you typically have to take
language specific conventions into account.

</p><p>

Therefore, today, when you create quickfixes for Kotlin and Java code,
if the quickfix isn't something simple which would work for both
languages, then you need to conditionally create either the Kotlin
version or the Java version of the quickfix based on whether the source
file it applies to is in Kotlin or Java. (For an easy way to check you
can use the <code>isKotlin</code> or <code>isJava</code> package level methods in
<code>com.android.tools.lint.detector.api</code>.)

</p><p>

However, it's often the case that the quickfix is something simple
which would work for both; that's true for most of the built-in lint
checks with quickfixes for Kotlin and Java.

</p>
<a class="target" name="regularexpressionsandbackreferences">&nbsp;</a><a class="target" name="addingquickfixes/regularexpressionsandbackreferences">&nbsp;</a><a class="target" name="toc7.7">&nbsp;</a><h2>Regular Expressions and Back References</h2>
<p>


The <code>replace</code> string quick fix allows you to match the text to
with regular expressions.

</p><p>

You can also use back references in the regular expression such
that the quick fix replacement text includes portions from the
original string.

</p><p>

Here's an example from lint's <code>AssertDetector</code>:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">val</span> fix = fix().name(<span class="hljs-string">"Surround with desiredAssertionStatus() check"</span>)
<span class="line"></span>    .replace()
<span class="line"></span>    .range(context.getLocation(assertCall))
<span class="line"></span>    .pattern(<span class="hljs-string">"(.*)"</span>)
<span class="line"></span>    .with(<span class="hljs-string">"if (javaClass.desiredAssertionStatus()) { \\k&lt;1&gt; }"</span>)
<span class="line"></span>    .reformat(<span class="hljs-literal">true</span>)
<span class="line"></span>    .build()</div></code></pre><p>

The replacement string's back reference above, on line 5, is \k&lt;1&gt;. If
there were multiple regular expression groups in the replacement
string, this could have been \k&lt;2&gt;, \k&lt;3&gt;, and so on.

</p><p>

Here's how this looks when applied, from its unit test:

</p><pre class="listing tilde"><code><span class="line"></span>lint().files().run().expectFixDiffs(
<span class="line"></span>    <span class="hljs-string">"""
<span class="line"></span>    Fix for src/test/pkg/AssertTest.kt line 18: Surround with desiredAssertionStatus() check:
<span class="line"></span>    @@ -18 +18
<span class="line"></span>    -         assert(expensive()) // WARN
<span class="line"></span>    +         if (javaClass.desiredAssertionStatus()) { assert(expensive()) } // WARN
<span class="line"></span>    """</span>
<span class="line"></span>)</code></pre>
<a class="target" name="emittingquickfixxmltoapplyonci">&nbsp;</a><a class="target" name="addingquickfixes/emittingquickfixxmltoapplyonci">&nbsp;</a><a class="target" name="toc7.8">&nbsp;</a><h2>Emitting quick fix XML to apply on CI</h2>
<p>


Note that the <code>lint</code> has an option (<code>--describe-suggestions</code>) to emit
an XML file which describes all the edits to perform on documents to
apply a fix. This maps all quick fixes into chapter edits (including
XML logic operations). This can be (and is, within Google) used to
integrate with code review tools such that the user can choose whether
to auto-fix a suggestion right from within the code review tool.

</p>
<a class="target" name="partialanalysis">&nbsp;</a><a class="target" name="partialanalysis">&nbsp;</a><a class="target" name="toc8">&nbsp;</a><h1>Partial Analysis</h1>

<a class="target" name="about">&nbsp;</a><a class="target" name="partialanalysis/about">&nbsp;</a><a class="target" name="toc8.1">&nbsp;</a><h2>About</h2>
<p>


This chapter describes Lint's “partial analysis”; its architecture and
APIs for allowing lint results to be cached.

</p><p>

This focuses on how to write or update existing lint checks such that
they work correctly under partial analysis. For other details about
partial analysis, such as the client side implemented by the build
system, see the lint internal docs folder.

</p><p>

</p><div class="admonition note">Note that while lint has this architecture, and all lint detectors
   must support it, the checks may not run in partial analysis mode;
   they may instead run in “global analysis mode”, which is how lint
   has worked up until this point.

<p></p><p>

   This is because coordinating partial results and merging is
   performed by the <code>LintClient</code>; e.g. in the IDE, there's no good
   reason to do all this extra work (because all sources are generally
   available, including “downstream” module info like the
   <code>minSdkVersion</code>).

</p><p>

   Right now, only the Android Gradle Plugin turns on partial analysis
   mode. But that's a very important client, since it's usually how
   lint checks are performed on continuous integration servers to
   validate code reviews.</p></div>

<p></p>
<a class="target" name="theproblem">&nbsp;</a><a class="target" name="partialanalysis/theproblem">&nbsp;</a><a class="target" name="toc8.2">&nbsp;</a><h2>The Problem</h2>
<p>


Many lint checks require “global” analysis. For example you can't
determine whether a particular string defined in a library module is
unused unless you look at all modules transitively consuming this
library as well.

</p><p>

However, many developers run lint as part of their continuous
integration. Particularly in large projects, analyzing all modules for
every check-in is too costly.

</p><p>

This chapter describes lint's architecture for handling this, such
that module results can be cached.

</p>
<a class="target" name="overview">&nbsp;</a><a class="target" name="partialanalysis/overview">&nbsp;</a><a class="target" name="toc8.3">&nbsp;</a><h2>Overview</h2>
<p>


Briefly stated, lint's architecture for this is “map reduce”: lint now
has two separate phases, analyze and report (map and reduce
respectively):

</p><p>

</p><ul>
<li class="asterisk"><strong class="asterisk">analyze</strong> - where lint analyzes source code of a single module in
  isolation, and stores some intermediate partial results (map)

<p></p><p>

</p></li>
<li class="asterisk"><strong class="asterisk">report</strong> - where lint reads in the previously stored module results,
  and performs some post-processing on this data to generate an actual
  lint report.</li></ul>

<p></p><p>

Crucially, the individual module results can be cached, such that if
nothing has changed in a module, the module results continue to be
valid (unless signatures have changed in libraries it depends on.)

</p><p>

Making this work requires some modifications to any <code>Detector</code> which
considers data from outside the current module. However, there are some
very common scenarios that lint has special support for to make this
easier.

</p><p>

Detectors fit into one of the following categories (and these
categories will be explained in subsequent sessions) :

</p><p>

</p><ol start="1">
<li class="number">Local analysis which doesn't depend on anything else. For example,
   a lint check which flags typos can report incidents immediately.
   Lint calls these “definite incidents”.

<p></p><p>

</p></li>
<li class="number">Local analysis which depends on a few, common conditions. For
   example, in Android, a check may only apply if the <code>minSdkVersion &lt;
   21</code>. Lint has special support for this; you basically report an
   incident and attach a “constraint” to it. Lint calls these, and
   incidents reported as part of #3 below, as “provisional incidents”.

<p></p><p>

</p></li>
<li class="number">Analysis which depends on some conditions of downstream modules that
   are not part of the built-in constraints. For example, a lint check
   may only apply if the consuming module depends on a certain version
   of a networking library. In this case, the detector will report the
   incident and attach a map to it, with whatever data it needs to
   consult later to decide if the incident actually should be reported.
   When the detector reports incidents this way, it has to also
   override a callback method. Lint will record these incidents, and
   during reporting, call the detector and pass it back its data map
   and provisional incidents such that it can decide whether the
   incidents should indeed be reported.

<p></p><p>

</p></li>
<li class="number">Last, and least, there are some scenarios where you cannot compute
   provisional incidents up front and filter them later (or doing so
   would be very costly). For example, unused resources fit into this
   category. We don't want to report every single resource declaration
   as unused and then filter later. Instead, we compute the resource
   usage graph within the module analysis. And in the reporting task,
   we then load all the partial usage graphs, and merge them together
   and walk the graph to report all the unused resources. To support
   this, lint provides a map per module for detectors to put their data
   into, and you can put maps into the map to model structured data.
   Lint will persist these, and in the reporting task the lint
   detectors will be passed their data to do their post-processing and
   reporting based on their data.</li></ol>

<p></p><p>

These are listed in increasing order of effort, and thankfully, they're
also listed in order of frequency. For lint's built-in checks (~385),

</p><p>

</p><ul>
<li class="asterisk">89% needed no work at all.
</li>
<li class="asterisk">6% were updated to report incidents with constraints
</li>
<li class="asterisk">4% were updated to report incidents with data for later filtering
</li>
<li class="asterisk">1% were updated to perform map recording and later reduce filtering</li></ul>

<p></p>
<a class="target" name="doesmydetectorneedwork?">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?">&nbsp;</a><a class="target" name="toc8.4">&nbsp;</a><h2>Does My Detector Need Work?</h2>
<p>


At this point you're probably wondering whether your checks are in the
89% category where you don't need to do anything, or in the remaining
11%. How do you know?

</p><p>

Lint has several built-in mechanisms to try to catch problems. There
are a few scenarios it cannot detect, and these are described below,
but for the vast majority, simply running your unit tests (which are
comprehensive, right?) should create unit test failures if your
detector is doing something it shouldn't.

</p>
<a class="target" name="catchingmistakes:blockingaccesstomainproject">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?/catchingmistakes:blockingaccesstomainproject">&nbsp;</a><a class="target" name="toc8.4.1">&nbsp;</a><h3>Catching Mistakes: Blocking Access to Main Project</h3>
<p>


In Android checks, it's very common to try to access the main (“app”)
project, to see what the real <code>minSdkVersion</code> is, since the app
<code>minSdkVersion</code> can be higher than the one in the library. For the
<code>targetSdkVersion</code> it's even more important, since the library
<code>targetSdkVersion</code> has no meaningful relationship to the app one.

</p><p>

When you run lint unit tests, as of 7.0, it will now run your tests
twice — once with global analysis (the previous behavior), and once
with partial analysis. When lint is running in partial analysis, a
number of calls, such as looking up the main project, or consulting the
merged manifest, is not allowed during the analysis phase. Attempting
to do so will generate an error:

</p><pre class="listing backtick"><code><span class="line"></span>    SdCardTest.java: Error: The lint detector
<span class="line"></span>        com.android.tools.lint.checks.SdCardDetector
<span class="line"></span>    called context.getMainProject() during module analysis.
<span class="line"></span>
<span class="line"></span>    This does not work correctly when running in Lint Unit Tests.
<span class="line"></span>
<span class="line"></span>    In particular, there may be false positives or false negatives because
<span class="line"></span>    the lint check may be using the minSdkVersion or manifest information
<span class="line"></span>    from the library instead of any consuming app module.
<span class="line"></span>
<span class="line"></span>    Contact the vendor of the lint issue to get it fixed/updated (if
<span class="line"></span>    known, listed below), and in the meantime you can try to work around
<span class="line"></span>    this by disabling the following issues:
<span class="line"></span>
<span class="line"></span>    "SdCardPath"
<span class="line"></span>
<span class="line"></span>    Issue Vendor:
<span class="line"></span>    Vendor: Android Open Source Project
<span class="line"></span>    Contact: https://groups.google.com/g/lint-dev
<span class="line"></span>    Feedback: https://issuetracker.google.com/issues/new?component=192708
<span class="line"></span>
<span class="line"></span>    Call stack: Context.getMainProject(Context.kt:117)←SdCardDetector$createUastHandler$1.visitLiteralExpression(SdCardDetector.kt:66)
<span class="line"></span>        ←UElementVisitor$DispatchPsiVisitor.visitLiteralExpression(UElementVisitor.kt:791)
<span class="line"></span>        ←ULiteralExpression$DefaultImpls.accept(ULiteralExpression.kt:38)
<span class="line"></span>        ←JavaULiteralExpression.accept(JavaULiteralExpression.kt:24)←UVariableKt.visitContents(UVariable.kt:64)
<span class="line"></span>        ←UVariableKt.access$visitContents(UVariable.kt:1)←UField$DefaultImpls.accept(UVariable.kt:92)
<span class="line"></span>        ...</code></pre><p>

Specific examples of information many lint checks look at in this
category:

</p><p>

</p><ul>
<li class="asterisk"><code>minSdkVersion</code> and <code>targetSdkVersion</code>
</li>
<li class="asterisk">The merged manifest
</li>
<li class="asterisk">The resource repository
</li>
<li class="asterisk">Whether the main module is an Android project</li></ul>

<p></p>
<a class="target" name="catchingmistakes:simulatedappmodule">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?/catchingmistakes:simulatedappmodule">&nbsp;</a><a class="target" name="toc8.4.2">&nbsp;</a><h3>Catching Mistakes: Simulated App Module</h3>
<p>


Lint will also modify the unit test when running the test in partial
analysis mode. In particular, let's say your test has a manifest which
sets <code>minSdkVersion</code> to 21.

</p><p>

Lint will instead run the analysis task on a modified test project
where the <code>minSdkVersion</code> is set to 1, and then run the reporting task
where <code>minSdkVersion</code> is set back to 21. This ensures that lint checks
will correctly use the <code>minSdkVersion</code> from the main project, not the
library.

</p>
<a class="target" name="catchingmistakes:diffingresults">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?/catchingmistakes:diffingresults">&nbsp;</a><a class="target" name="toc8.4.3">&nbsp;</a><h3>Catching Mistakes: Diffing Results</h3>
<p>


Lint will also diff the report output from running the same unit tests
both in global analysis mode and in partial analysis mode. We expect
the results to always be identical, and in some cases if the module
analysis is not written correctly, they're not.

</p>
<a class="target" name="catchingmistakes:remainingissues">&nbsp;</a><a class="target" name="partialanalysis/doesmydetectorneedwork?/catchingmistakes:remainingissues">&nbsp;</a><a class="target" name="toc8.4.4">&nbsp;</a><h3>Catching Mistakes: Remaining Issues</h3>
<p>


The above three mechanisms will catch most problems related to partial
analysis. However, there are a few remaining scenarios to be aware of:

</p><p>

</p><ul>
<li class="asterisk">Resolving into library source code. If you have a Kotlin or Java
  function call AST node (<code>UCallExpression</code>) you can call <code>resolve()</code>
  on it to find the called <code>PsiMethod</code>, and from there you can look at
  its source code, to make some decisions.

<p></p><p>

  For example, lint's API Check uses this to see if a given method is a
  version-check utility (“<code>SDK_INT &gt; 21</code>?”); it resolves the method
  call in <code>if (isOnLollipop()) { ... }</code> and looks at its method body to
  see if the return value corresponds to a proper <code>SDK_INT</code> check.

</p><p>

  In partial analysis mode, you cannot look at source files from
  libraries you depend on; they will only be provided in binary
  (bytecode inside a jar file) form.

</p><p>

  This means that instead, you need to aggregate data along the way.
  For example, the way lint handles the version check method lookup is
  to look for SDK_INT comparisons, and if found, stores a reference to
  the method in the partial results map which it can later consult
  from downstream modules.

</p><p>

</p></li>
<li class="asterisk">Multiple passes across the modules (lint has a way to request
  multiple passes; this was used by a few lint checks like the unused
  resource detector; the multiple passes now only apply to the local
  module)</li></ul>

<p></p><p>

In order to test for correct operation of your check, you should add
your own individual unit test for a multi-module project.

</p><p>

Lint's unit test infrastructure makes this easy; just use relative
paths in the test file descriptions.

</p><p>

For example, if you have the following unit test declaration:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span>   lint().files(
<span class="line"></span>       manifest().minSdk(<span class="hljs-number">15</span>),
<span class="line"></span>       manifest().to(<span class="hljs-string">"../app/AndroidManifest.xml"</span>).minSdk(<span class="hljs-number">21</span>),
<span class="line"></span>       xml(
<span class="line"></span>           <span class="hljs-string">"res/layout/linear.xml"</span>,
<span class="line"></span>           <span class="hljs-string">"&lt;linearlayout ...="</span><span class="hljs-string">"&gt;"</span> + ...</div></code></pre><p>

The second <code>manifest()</code> call here on line 3 does all the heavy lifting:
the fact that you're referencing <code>../app</code> means it will create another
module named “app”, and it will add a dependency from that module on
this one. It will also mark the current module as a library. This is
based on the name patterns; if you for example reference say <code>../lib1</code>,
it will assume the current module is an app module and the dependency
will go from here to the library.

</p><p>

Finally, to test a multi-module setup where the code in the other
module is only available as binary, lint has a new special test file
type. The <code>CompiledSourceFile</code> can be constructed via either
<code>compiled()</code>, if you want to make both the source code and the class
file available in the project, or <code>bytecode()</code> if you want to only
provide the bytecode. In both cases you include the source code in the
test file declaration, and the first time you run your test it will try
to run compilation and emit the extra base64 string to include the test
file. By having the sources included for the binary it's easy to
regenerate bytecode tests later (this was an issue with some of lint's
older unit tests; we recently decompiled them and created new test
files using this mechanism to make the code more maintainable.

</p><p>

Lint's partial analysis testing support will automatically only use
binaries for the dependencies (even if using <code>CompiledSourceFile</code> with
sources).

</p><p>

</p><div class="admonition note">Lint's testing infrastructure may try to automate this testing at
   some point; e.g. by looking at the error locations from a global
   analysis, it can then create a new project where only the source
   file with the warnings is provided as source, and all the other test
   files are placed in a separate module, and then represented only as
   binaries (through a lint AST to PsiCompiled pretty printer.)</div>

<p></p>
<a class="target" name="incidents">&nbsp;</a><a class="target" name="partialanalysis/incidents">&nbsp;</a><a class="target" name="toc8.5">&nbsp;</a><h2>Incidents</h2>
<p>


In the past, you would typically report problems like this:
</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span>    context.report(
<span class="line"></span>        ISSUE,
<span class="line"></span>        element,
<span class="line"></span>        context.getNameLocation(element),
<span class="line"></span>        <span class="hljs-string">"Missing `contentDescription` attribute on image"</span>
<span class="line"></span>    )</div></code></pre><p>

At some point, we added support for quickfixes, so the
report method took an additional parameter, line 6:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span>    context.report(
<span class="line"></span>        ISSUE,
<span class="line"></span>        element,
<span class="line"></span>        context.getNameLocation(element),
<span class="line"></span>        <span class="hljs-string">"Missing `contentDescription` attribute on image"</span>,
<span class="line"></span>        fix().<span class="hljs-keyword">set</span>().todo(ANDROID_URI, ATTR_CONTENT_DESCRIPTION).build()
<span class="line"></span>)</div></code></pre><p>

Now that we need to attach various additional data (like constraints
and maps), we don't really want to just add more parameters.

</p><p>

Instead, this tuple of data about a particular occurrence of a problem
is called an “incident”, and there is a new <code>Incident</code> class which
represents it. To report an incident you simply call
<code>context.report(incident)</code>. There are several ways to create these
incidents. The easiest is to simply edit your existing call above by
adding <code>Incident(</code> (or from Java, <code>new Incident(</code>) inside the
<code>context.report</code> block like this:

</p><pre class="listing tilde"><code><span class="line"></span>    context.report(Incident(
<span class="line"></span>        ISSUE,
<span class="line"></span>        element,
<span class="line"></span>        context.getNameLocation(element),
<span class="line"></span>        <span class="hljs-string">"Missing `contentDescription` attribute on image"</span>
<span class="line"></span>    ))</code></pre><p>

and then reformatting the source code:

</p><pre class="listing tilde"><code><span class="line"></span>    context.report(
<span class="line"></span>        Incident(
<span class="line"></span>            ISSUE,
<span class="line"></span>            element,
<span class="line"></span>            context.getNameLocation(element),
<span class="line"></span>            <span class="hljs-string">"Missing `contentDescription` attribute on image"</span>
<span class="line"></span>        )
<span class="line"></span>)</code></pre><p>

<code>Incident</code> has a number of overloaded constructors to make it easy to
construct it from existing report calls.

</p><p>

There are other ways to construct it too, for example like the
following:

</p><pre class="listing tilde"><code><span class="line"></span>    Incident(context)
<span class="line"></span>        .issue(ISSUE)
<span class="line"></span>        .scope(node)
<span class="line"></span>        .location(context.getLocation(node))
<span class="line"></span>        .message(<span class="hljs-string">"Do not hardcode \"/sdcard/\""</span>).report()</code></pre><p>

That are additional methods you can fall too, like <code>fix()</code>, and
conveniently, <code>at()</code> which specifies not only the scope node but
automatically computes and records the location of that scope node too,
such that the following is equivalent:

</p><pre class="listing tilde"><code><span class="line"></span>    Incident(context)
<span class="line"></span>        .issue(ISSUE)
<span class="line"></span>        .at(node)
<span class="line"></span>        .message(<span class="hljs-string">"Do not hardcode \"/sdcard/\""</span>).report()</code></pre><p>

So step one to partial analysis is to convert your code to report
incidents instead of the passing in all the individual properties of an
incident. Note that for backwards compatibility, if your check doesn't
need any work for partial analysis, you can keep calling the older
report methods; they will be redirected to an <code>Incident</code> call
internally, but since you don't need to attach data you don't have to
make any changes

</p>
<a class="target" name="constraints">&nbsp;</a><a class="target" name="partialanalysis/constraints">&nbsp;</a><a class="target" name="toc8.6">&nbsp;</a><h2>Constraints</h2>
<p>


If your check needs to be conditional, perhaps on the <code>minSdkVersion</code>,
you need to attach a “constraint” to your report call.

</p><p>

All the constraints are built in; there isn't a way to implement your
own. For custom logic, see the next section: LintMaps.

</p><p>

Here are the current constraints, though this list may grow over time:

</p><p>

</p><ul>
<li class="asterisk">minSdkAtLeast(Int)
</li>
<li class="asterisk">minSdkLessThan(Int)
</li>
<li class="asterisk">targetSdkAtLeast(Int)
</li>
<li class="asterisk">targetSdkLessThan(Int)
</li>
<li class="asterisk">isLibraryProject()
</li>
<li class="asterisk">isAndroidProject()
</li>
<li class="asterisk">notLibraryProject()
</li>
<li class="asterisk">notAndroidProject()</li></ul>

<p></p><p>

These are package-level functions, though from Java you can access them
from the <code>Constraints</code> class.

</p><p>

Recording an incident with a constraint is easy; first construct the
<code>Incident</code> as before, and then report them via
<code>context.report(incident, constraint)</code>:

</p><pre class="listing tilde"><code><span class="line"></span>    String message =
<span class="line"></span>        <span class="hljs-string">"One or more images in this project can be converted to "</span>
<span class="line"></span>        + <span class="hljs-string">"the WebP format which typically results in smaller file sizes, "</span>
<span class="line"></span>        + <span class="hljs-string">"even for lossless conversion"</span>;
<span class="line"></span>    Incident incident = <span class="hljs-keyword">new</span> Incident(WEBP_ELIGIBLE, location, message);
<span class="line"></span>    context.report(incident, minSdkAtLeast(<span class="hljs-number">18</span>));</code></pre><p>

Finally, note that you can combine constraints; there are both “and”
and “or” operators defined for the <code>Constraint</code> class. so the following
is valid:

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-keyword">val</span> constraint = targetSdkAtLeast(<span class="hljs-number">23</span>) and notLibraryProject()
<span class="line"></span>    context.report(incident, constraint)</code></pre><p>

That's all you have to do. Lint will record this provisional incident,
and when it is performing reporting, it will evaluate these constraints
on its own and only report incidents that meet the constraint.

</p>
<a class="target" name="incidentlintmaps">&nbsp;</a><a class="target" name="partialanalysis/incidentlintmaps">&nbsp;</a><a class="target" name="toc8.7">&nbsp;</a><h2>Incident LintMaps</h2>
<p>


In some cases, you cannot use one of the built-in constraints; you have
to do your own “filtering” from the reporting task, where you have
access to the main module.

</p><p>

In that case, you call <code>context.report(incident, map)</code> instead.

</p><p>

Like <code>Incident</code>, <code>LintMap</code> is a new data holder class in lint which
makes it convenient to pass around (and more importantly, persist)
data. All the set methods return the map itself, so you can easily
chain property calls.

</p><p>

Here's an example:

</p><pre class="listing tilde"><code><span class="line"></span>    context.report(
<span class="line"></span>        incident,
<span class="line"></span>        map()
<span class="line"></span>            .put(KEY_OVERRIDES, overrides)
<span class="line"></span>            .put(KEY_IMPLICIT, implicitlyExportedPreS)
<span class="line"></span>    )</code></pre><p>

Here, <code>map()</code> is a method defined by <code>Detector</code> to create a new
<code>LintMap</code>, similar to how <code>fix()</code> constructs a new <code>LintFix</code>.

</p><p>

Note however that when reporting data, you need to do the post
processing yourself. To do this, you need to override this method:

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-comment">/**
<span class="line"></span>     * Filter which looks at incidents previously reported via
<span class="line"></span>     * [Context.report] with a [LintMap], and returns false if the issue
<span class="line"></span>     * does not apply in the current reporting project context, or true
<span class="line"></span>     * if the issue should be reported. For issues that are accepted,
<span class="line"></span>     * the detector is also allowed to mutate the issue, such as
<span class="line"></span>     * customizing the error message further.
<span class="line"></span>     */</span>
<span class="line"></span>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filterIncident</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, incident: <span class="hljs-type">Incident</span>, map: <span class="hljs-type">LintMap</span>)</span></span>: <span class="hljs-built_in">Boolean</span> { }</code></pre><p>

For example, for the above report call, the corresponding
implementation of <code>filterIncident</code> looks like this:

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filterIncident</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, incident: <span class="hljs-type">Incident</span>, map: <span class="hljs-type">LintMap</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
<span class="line"></span>        <span class="hljs-keyword">if</span> (context.mainProject.targetSdk &lt; <span class="hljs-number">19</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
<span class="line"></span>        <span class="hljs-keyword">if</span> (map.getBoolean(KEY_IMPLICIT, <span class="hljs-literal">false</span>) == <span class="hljs-literal">true</span> &amp;&amp; context.mainProject.targetSdk &gt;= <span class="hljs-number">31</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
<span class="line"></span>        <span class="hljs-keyword">return</span> map.getBoolean(KEY_OVERRIDES, <span class="hljs-literal">false</span>) == <span class="hljs-literal">false</span>
<span class="line"></span>    }</code></pre><p>

Note also that you are allowed to modify incidents here before
reporting them. The most common reason scenario for this is changing
the incident message, perhaps to reflect data not known at module
analysis time. For example, lint's API check creates messages like this:

</p><p>

<em class="asterisk">Error: Cast from AudioFormat to Parcelable requires API level 24 (current min is 21)</em>

</p><p>

At module analysis time when the incident was created, the minSdk being
21 was not known (and in fact can vary if this library is consumed by
many different app modules!)

</p><p>

</p><div class="admonition warning">You must store state in the lint map; don't try to store it in the
   detector itself as instance state. That won't work because the
   detector instance that <code>filterInstance</code> is called on is not the same
   instance as the one which originally reported it. If you think about
   it, that makes sense; when module results are cached, the same
   reported data can be used over and over again for repeated builds,
   each time for new detector instances in the reporting task.</div>

<p></p>
<a class="target" name="modulelintmaps">&nbsp;</a><a class="target" name="partialanalysis/modulelintmaps">&nbsp;</a><a class="target" name="toc8.8">&nbsp;</a><h2>Module LintMaps</h2>
<p>


The last (and most involved) scenario for partial analysis is one where
you cannot just create incidents and filter or customize them later.

</p><p>

The most complicated example of this is lint's built-in
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/UnusedResourceDetector.java">UnusedResourceDetector</a>, which locates unused resources. This “requires”
global analysis, since we want to include all resources in the entire
project. We also cannot just store lists of “resources declared” and
“resources referenced“ since we really want to treat this as a graph.
For example if <code>@layout/main</code> is including <code>@drawable/icon</code>, then a
naive approach would see the icon as referenced (by main) and therefore
mark it as not unused. But what we want is that if the icon is <strong class="asterisk">only</strong>
referenced from main, and if main is unused, then so is the icon.

</p><p>

To handle this, we model the resources as a graph, with edges
representing references.

</p><p>

When analyzing individual modules, we create the resource graph for
just that model, and we store that in the results. That means we store
it in the module's <code>LintMap</code>. This is a map for the whole module
maintained by lint, so you can access it repeatedly and add to it.
(This is also where lint's API check stores the <code>SDK_INT</code> comparison
functions as described earlier in this chapter).

</p><p>

The unused resource detector creates a persistence string for the
graph, and records that in the map.

</p><p>

Then, during reporting, it is given access to <em class="asterisk">all</em> the lint maps for
all the modules that the reporting module depends on, including itself.
It then merges all the graphs into a single reference graph.

</p><p>

For example, let's say in module 1 we have layout A which includes
drawables B and D, and B in turn depends on color C. We get a resource
graph like the following:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="176" width="360" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 40,48 L 40,112 " style="fill:none;"></path>
<path d="M 56,32 L 104,32 " style="fill:none;"></path>
<path d="M 144,32 L 192,32 " style="fill:none;"></path>
<path d="M 40,112 L 72,112 " style="fill:none;"></path>
<path d="M 40,16 C 23.2,16 24,32 24,32 " style="fill:none;"></path>
<path d="M 40,16 C 56.8,16 56,32 56,32 " style="fill:none;"></path>
<path d="M 128,16 C 111.2,16 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,16 C 144.8,16 144,32 144,32 " style="fill:none;"></path>
<path d="M 216,16 C 199.2,16 200,32 200,32 " style="fill:none;"></path>
<path d="M 216,16 C 232.8,16 232,32 232,32 " style="fill:none;"></path>
<path d="M 40,48 C 23.2,48 24,32 24,32 " style="fill:none;"></path>
<path d="M 40,48 C 56.8,48 56,32 56,32 " style="fill:none;"></path>
<path d="M 128,48 C 111.2,48 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,48 C 144.8,48 144,32 144,32 " style="fill:none;"></path>
<path d="M 216,48 C 199.2,48 200,32 200,32 " style="fill:none;"></path>
<path d="M 216,48 C 232.8,48 232,32 232,32 " style="fill:none;"></path>
<path d="M 96,96 C 79.2,96 80,112 80,112 " style="fill:none;"></path>
<path d="M 96,96 C 112.8,96 112,112 112,112 " style="fill:none;"></path>
<path d="M 96,128 C 79.2,128 80,112 80,112 " style="fill:none;"></path>
<path d="M 96,128 C 112.8,128 112,112 112,112 " style="fill:none;"></path>
<polygon points="200,32 188,26.4 188,37.6 " style="stroke:none" transform="rotate(0,192,32 )"></polygon>
<polygon points="112,32 100,26.4 100,37.6 " style="stroke:none" transform="rotate(0,104,32 )"></polygon>
<polygon points="80,112 68,106.4 68,117.6 " style="stroke:none" transform="rotate(0,72,112 )"></polygon>
<g transform="translate(0,0)"><text text-anchor="middle" x="40" y="36">A</text><text text-anchor="middle" x="128" y="36">B</text><text text-anchor="middle" x="216" y="36">C</text><text text-anchor="middle" x="96" y="116">D</text></g></g></svg>

</p><p>

Then in another module, we have the following resource reference graph:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="96" width="360" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 56,32 L 104,32 " style="fill:none;"></path>
<path d="M 144,32 L 192,32 " style="fill:none;"></path>
<path d="M 40,16 C 23.2,16 24,32 24,32 " style="fill:none;"></path>
<path d="M 40,16 C 56.8,16 56,32 56,32 " style="fill:none;"></path>
<path d="M 128,16 C 111.2,16 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,16 C 144.8,16 144,32 144,32 " style="fill:none;"></path>
<path d="M 216,16 C 199.2,16 200,32 200,32 " style="fill:none;"></path>
<path d="M 216,16 C 232.8,16 232,32 232,32 " style="fill:none;"></path>
<path d="M 40,48 C 23.2,48 24,32 24,32 " style="fill:none;"></path>
<path d="M 40,48 C 56.8,48 56,32 56,32 " style="fill:none;"></path>
<path d="M 128,48 C 111.2,48 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,48 C 144.8,48 144,32 144,32 " style="fill:none;"></path>
<path d="M 216,48 C 199.2,48 200,32 200,32 " style="fill:none;"></path>
<path d="M 216,48 C 232.8,48 232,32 232,32 " style="fill:none;"></path>
<polygon points="200,32 188,26.4 188,37.6 " style="stroke:none" transform="rotate(0,192,32 )"></polygon>
<polygon points="112,32 100,26.4 100,37.6 " style="stroke:none" transform="rotate(0,104,32 )"></polygon>
<g transform="translate(0,0)"><text text-anchor="middle" x="40" y="36">E</text><text text-anchor="middle" x="128" y="36">B</text><text text-anchor="middle" x="216" y="36">D</text></g></g></svg>

</p><p>

In the reporting task, we merge the two graphs like the following:

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="256" width="360" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 40,128 L 40,192 " style="fill:none;"></path>
<path d="M 128,48 L 128,88 " style="fill:none;"></path>
<path d="M 128,128 L 128,168 " style="fill:none;"></path>
<path d="M 56,112 L 104,112 " style="fill:none;"></path>
<path d="M 144,112 L 192,112 " style="fill:none;"></path>
<path d="M 40,192 L 104,192 " style="fill:none;"></path>
<path d="M 128,16 C 111.2,16 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,16 C 144.8,16 144,32 144,32 " style="fill:none;"></path>
<path d="M 128,48 C 111.2,48 112,32 112,32 " style="fill:none;"></path>
<path d="M 128,48 C 144.8,48 144,32 144,32 " style="fill:none;"></path>
<path d="M 40,96 C 23.2,96 24,112 24,112 " style="fill:none;"></path>
<path d="M 40,96 C 56.8,96 56,112 56,112 " style="fill:none;"></path>
<path d="M 128,96 C 111.2,96 112,112 112,112 " style="fill:none;"></path>
<path d="M 128,96 C 144.8,96 144,112 144,112 " style="fill:none;"></path>
<path d="M 216,96 C 199.2,96 200,112 200,112 " style="fill:none;"></path>
<path d="M 216,96 C 232.8,96 232,112 232,112 " style="fill:none;"></path>
<path d="M 40,128 C 23.2,128 24,112 24,112 " style="fill:none;"></path>
<path d="M 40,128 C 56.8,128 56,112 56,112 " style="fill:none;"></path>
<path d="M 128,128 C 111.2,128 112,112 112,112 " style="fill:none;"></path>
<path d="M 128,128 C 144.8,128 144,112 144,112 " style="fill:none;"></path>
<path d="M 216,128 C 199.2,128 200,112 200,112 " style="fill:none;"></path>
<path d="M 216,128 C 232.8,128 232,112 232,112 " style="fill:none;"></path>
<path d="M 128,176 C 111.2,176 112,192 112,192 " style="fill:none;"></path>
<path d="M 128,176 C 144.8,176 144,192 144,192 " style="fill:none;"></path>
<path d="M 128,208 C 111.2,208 112,192 112,192 " style="fill:none;"></path>
<path d="M 128,208 C 144.8,208 144,192 144,192 " style="fill:none;"></path>
<polygon points="200,112 188,106.4 188,117.6 " style="stroke:none" transform="rotate(0,192,112 )"></polygon>
<polygon points="136,168 124,162.4 124,173.6 " style="stroke:none" transform="rotate(90,128,168 )"></polygon>
<polygon points="136,88 124,82.4 124,93.6 " style="stroke:none" transform="rotate(90,128,88 )"></polygon>
<polygon points="112,192 100,186.4 100,197.6 " style="stroke:none" transform="rotate(0,104,192 )"></polygon>
<polygon points="112,112 100,106.4 100,117.6 " style="stroke:none" transform="rotate(0,104,112 )"></polygon>
<g transform="translate(0,0)"><text text-anchor="middle" x="128" y="36">E</text><text text-anchor="middle" x="40" y="116">A</text><text text-anchor="middle" x="128" y="116">B</text><text text-anchor="middle" x="216" y="116">C</text><text text-anchor="middle" x="128" y="196">D</text></g></g></svg>

</p><p>

Once that's done, it can proceed precisely as before: analyze the graph
and report all the resources that are not reachable from the reference
roots (e.g. manifest and used code).

</p><p>

The way this works in code is that you report data into the module by
first looking up the module data map, by calling this method on the
<code>Context</code>:

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-comment">/**
<span class="line"></span>     * Returns a [PartialResult] where state can be stored for later
<span class="line"></span>     * analysis. This is a more general mechanism for reporting
<span class="line"></span>     * provisional issues when you need to collect a lot of data and do
<span class="line"></span>     * some post processing before figuring out what to report and you
<span class="line"></span>     * can't enumerate out specific [Incident] occurrences up front.
<span class="line"></span>     *
<span class="line"></span>     * Note that in this case, the lint infrastructure will not
<span class="line"></span>     * automatically look up the error location (since there isn't one
<span class="line"></span>     * yet) to see if the issue has been suppressed (via annotations,
<span class="line"></span>     * lint.xml and other mechanisms), so you should do this
<span class="line"></span>     * yourself, via the various [LintDriver.isSuppressed] methods.
<span class="line"></span>     */</span>
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getPartialResults</span><span class="hljs-params">(issue: <span class="hljs-type">Issue</span>)</span></span>: PartialResult { ... }</code></pre><p>

Then you put whatever data you want, such as the resource usage model
encoded as a string.

</p><p>

</p><div class="admonition ">Note that you don't have to worry about clashes in key names; each
   issue (and therefore detector) is given its own map.</div>

<p></p><p>

And then your detector should also override the following method, where
you can walk through the map contents, compute incidents and report
them:

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-comment">/**
<span class="line"></span>     * Callback to detectors that add partial results (by adding entries
<span class="line"></span>     * to the map returned by [LintClient.getPartialResults]). This is
<span class="line"></span>     * where the data should be analyzed and merged and results reported
<span class="line"></span>     * (via [Context.report]) to lint.
<span class="line"></span>     */</span>
<span class="line"></span>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkPartialResults</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, partialResults: <span class="hljs-type">PartialResult</span>)</span></span> { ... }</code></pre>
<a class="target" name="optimizations">&nbsp;</a><a class="target" name="partialanalysis/optimizations">&nbsp;</a><a class="target" name="toc8.9">&nbsp;</a><h2>Optimizations</h2>
<p>


Most lint checks run on the fly in the IDE editor as well. In some
cases, if all the map computations are expensive, you can check whether
partial analysis is in effect, and if not, just directly access (for
example) the main project.

</p><p>

Do this by calling <code>isGlobalAnalysis()</code>:

</p><pre class="listing tilde"><code><span class="line"></span>   <span class="hljs-keyword">if</span> (context.isGlobalAnalysis()) {
<span class="line"></span>       <span class="hljs-comment">// shortcut</span>
<span class="line"></span>   } <span class="hljs-keyword">else</span> {
<span class="line"></span>       <span class="hljs-comment">// partial analysis code path</span>
<span class="line"></span>   }</code></pre><p>



</p>
<a class="target" name="dataflowanalyzer">&nbsp;</a><a class="target" name="dataflowanalyzer">&nbsp;</a><a class="target" name="toc9">&nbsp;</a><h1>Data Flow Analyzer</h1>
<p>


The dataflow analyzer is a helper in lint which makes writing certain
kinds of lint checks a lot easier.

</p><p>

Let's say you have an API which creates an object, and then you want to
make sure that at some point a particular method is called on the same
instance.

</p><p>

There are a lot of scenarios like this;

</p><p>

</p><ul>
<li class="asterisk">Calling <code>show</code> on a message in a Toast or Snackbar
</li>
<li class="asterisk">Calling <code>commit</code> or <code>apply</code> on a transaction
</li>
<li class="asterisk">Calling <code>recycle</code> on a TypedArray
</li>
<li class="asterisk">Calling <code>enqueue</code> on a newly created work request</li></ul>

<p></p><p>

and so on. I didn't include calling close on a file object since you
typically use try-with-resources for those.

</p><p>

Here are some examples:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span>getFragmentManager().beginTransaction().commit() <span class="hljs-comment">// OK</span>
<span class="line"></span><span class="hljs-keyword">val</span> t1 = getFragmentManager().beginTransaction() <span class="hljs-comment">// NEVER COMMITTED</span>
<span class="line"></span><span class="hljs-keyword">val</span> t2 = getFragmentManager().beginTransaction() <span class="hljs-comment">// OK</span>
<span class="line"></span>t2.commit()</div></code></pre><p>

Here we are creating 3 transactions. The first one is committed
immediately. The second one is never committed. And the third one
is.

</p><p>

This example shows us creating multiple transactions, and that
demonstrates that solving this problem isn't as simple as just visiting
the method and seeing if the code invokes <code>Transaction#commit</code>
anywhere; we have to make sure that it's invoked on all the instances
we care about.

</p>
<a class="target" name="usage">&nbsp;</a><a class="target" name="dataflowanalyzer/usage">&nbsp;</a><a class="target" name="toc9.1">&nbsp;</a><h2>Usage</h2>
<p>


To use the dataflow analyzer, you basically extend the
<code>DataFlowAnalyzer</code> class, and override one or more of its callbacks,
and then tell it to analyze a method scope.

</p><p>

For the above transaction scenario, it might look like this:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getApplicableMethodNames</span><span class="hljs-params">()</span></span>: List&lt;string&gt; =
<span class="line"></span>    listOf(<span class="hljs-string">"beginTransaction"</span>)
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitMethodCall</span><span class="hljs-params">(context: <span class="hljs-type">JavaContext</span>, node: <span class="hljs-type">UCallExpression</span>, method: <span class="hljs-type">PsiMethod</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> containingClass = method.containingClass
<span class="line"></span>    <span class="hljs-keyword">val</span> evaluator = context.evaluator
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">if</span> (evaluator.extendsClass(containingClass, <span class="hljs-string">"android.app.FragmentManager"</span>, <span class="hljs-literal">false</span>)) {
<span class="line"></span>        <span class="hljs-comment">// node is a call to FragmentManager.beginTransaction(),</span>
<span class="line"></span>        <span class="hljs-comment">// so this expression will evaluate to an instance of</span>
<span class="line"></span>        <span class="hljs-comment">// a Transaction. We want to track this instance to see</span>
<span class="line"></span>        <span class="hljs-comment">// if we eventually call commit on it.</span>
<span class="line"></span>        <span class="hljs-keyword">var</span> foundCommit = <span class="hljs-literal">false</span>
<span class="line"></span>        <span class="hljs-keyword">val</span> visitor = <span class="hljs-keyword">object</span> : DataFlowAnalyzer(setOf(node)) {
<span class="line"></span>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">receiver</span><span class="hljs-params">(call: <span class="hljs-type">UCallExpression</span>)</span></span> {
<span class="line"></span>                <span class="hljs-keyword">if</span> (call.methodName == <span class="hljs-string">"commit"</span>) {
<span class="line"></span>                    foundCommit = <span class="hljs-literal">true</span>
<span class="line"></span>                }
<span class="line"></span>            }
<span class="line"></span>        }
<span class="line"></span>        <span class="hljs-keyword">val</span> method = node.getParentOfType(UMethod::<span class="hljs-keyword">class</span>.java)
<span class="line"></span>        method?.accept(visitor)
<span class="line"></span>        <span class="hljs-keyword">if</span> (!foundCommit) {
<span class="line"></span>            context.report(Incident(...))
<span class="line"></span>        }
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

Aas you can see, the <code>DataFlowAnalyzer</code> is a visitor, so when we find a
call we're interested in, we construct a <code>DataFlowAnalyzer</code> and
initialize it with the instance we want to track, and then we visit the
surrounding method with this visitor.

</p><p>

The visitor will invoke the <code>receiver</code> method whenever the instance is
invoked as the receiver of a method call; this is the case with
<code>t2.commit()</code> in the above example; here “t2” is the receiver, and
<code>commit</code> is the method call name.

</p><p>

With the above setup, basic value tracking is working; e.g. it will
correctly handle the following case:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">val</span> t = getFragmentManager().beginTransaction().commit()
<span class="line"></span><span class="hljs-keyword">val</span> t2 = t
<span class="line"></span><span class="hljs-keyword">val</span> t3 = t2
<span class="line"></span>t3.commit()</div></code></pre><p>

However, there's a lot that can go wrong, which we'll need to deal with. This is explained in the following sections

</p>
<a class="target" name="self-referencingcalls">&nbsp;</a><a class="target" name="dataflowanalyzer/self-referencingcalls">&nbsp;</a><a class="target" name="toc9.2">&nbsp;</a><h2>Self-referencing Calls</h2>
<p>


The Transaction API has a number of utility methods; here's a partial
list:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FragmentTransaction</span> </span>{
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span></span>;
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">commitAllowingStateLoss</span><span class="hljs-params">()</span></span>;
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FragmentTransaction <span class="hljs-title">show</span><span class="hljs-params">(Fragment fragment)</span></span>;
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FragmentTransaction <span class="hljs-title">hide</span><span class="hljs-params">(Fragment fragment)</span></span>;
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FragmentTransaction <span class="hljs-title">attach</span><span class="hljs-params">(Fragment fragment)</span></span>;
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FragmentTransaction <span class="hljs-title">detach</span><span class="hljs-params">(Fragment fragment)</span></span>;
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FragmentTransaction <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> containerViewId, Fragment fragment)</span></span>;
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FragmentTransaction <span class="hljs-title">add</span><span class="hljs-params">(Fragment fragment, String tag)</span></span>;
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FragmentTransaction <span class="hljs-title">addToBackStack</span><span class="hljs-params">(String name)</span></span>;
<span class="line"></span>    ...
<span class="line"></span>}</div></code></pre><p>

The reason all these methods return a <code>FragmentTransaction</code> is to make it easy to chain calls; e.g.

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id = getFragmentManager().beginTransaction()
<span class="line"></span>        .add(<span class="hljs-keyword">new</span> Fragment(), <span class="hljs-keyword">null</span>)
<span class="line"></span>        .addToBackStack(<span class="hljs-keyword">null</span>)
<span class="line"></span>        .commit();</div></code></pre><p>

In order to correctly analyze this, we'd need to know what the implementation of <code>add</code> and <code>addToBackStack</code> return. If we know that they simply return “this”, then it's easy; we can transfer the instance through the call.

</p><p>

And this is what the <code>DataFlowAnalyzer</code> will try to do by default. When
it encounters a call on our tracked receivers, it will try to guess
whether that method is returning itself. It has several heuristics for
this:

</p><p>

</p><ul>
<li class="asterisk">The return type is the same as its surrounding class, or a subtype of
  it
</li>
<li class="asterisk">It's an extension method returning the same type
</li>
<li class="asterisk">It's not named something which indicates a new instance (such as
  clone, copy, or to*X*), unless <code>ignoreCopies()</code> is overridden to
  return false</li></ul>

<p></p><p>

In our example, the above heuristics work, so out of the box, the lint check would correctly handle this scenario.

</p><p>

But there may be cases where you either don't want these heuristics, or you want to add your own. In these cases, you would override the <code>returnsSelf</code> method on the flow analyzer and apply your own logic:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">val</span> visitor = <span class="hljs-keyword">object</span> : DataFlowAnalyzer(setOf(node)) {
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returnsSelf</span><span class="hljs-params">(call: <span class="hljs-type">UCallExpression</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
<span class="line"></span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.returnsSelf(call) || call.methodName == <span class="hljs-string">"copy"</span>
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre>
<a class="target" name="kotlinscopingfunctions">&nbsp;</a><a class="target" name="dataflowanalyzer/kotlinscopingfunctions">&nbsp;</a><a class="target" name="toc9.3">&nbsp;</a><h2>Kotlin Scoping Functions</h2>
<p>


With this in place, lint will track the flow through the method.
This includes handling Kotlin's scoping functions as well. For
example, it will automatically handle scenarios like the
following:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span>transaction1.let { it.commit() }
<span class="line"></span>transaction2.apply { commit() }
<span class="line"></span>with (transaction3) { commit() }
<span class="line"></span>transaction4.also { it.commit() }
<span class="line"></span>
<span class="line"></span>getFragmentManager.let {
<span class="line"></span>    it.beginTransaction()
<span class="line"></span>}.commit()
<span class="line"></span>
<span class="line"></span><span class="hljs-comment">// complex (contrived and unrealistic) example:</span>
<span class="line"></span>transaction5.let {
<span class="line"></span>    it.also {
<span class="line"></span>        it.apply {
<span class="line"></span>            with(<span class="hljs-keyword">this</span>) {
<span class="line"></span>                commit()
<span class="line"></span>            }
<span class="line"></span>        }
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre>
<a class="target" name="limitations">&nbsp;</a><a class="target" name="dataflowanalyzer/limitations">&nbsp;</a><a class="target" name="toc9.4">&nbsp;</a><h2>Limitations</h2>
<p>


It doesn't try to “execute”, constant evaluation (maybe)
if/else

</p>
<a class="target" name="escapingvalues">&nbsp;</a><a class="target" name="dataflowanalyzer/escapingvalues">&nbsp;</a><a class="target" name="toc9.5">&nbsp;</a><h2>Escaping Values</h2>
<p>


What if your check gets invoked on a code snippet like this:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createTransaction</span><span class="hljs-params">()</span></span>: FragmentTransaction =
<span class="line"></span>    getFragmentManager().beginTransaction().add(new Fragment(), <span class="hljs-literal">null</span>)</div></code></pre><p>

Here, we're not calling <code>commit</code>, so our lint check would issue a
warning. However, it's quite possible and likely that elsewhere,
there's code using it, like this:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">val</span> transaction = createTransaction()
<span class="line"></span>...
<span class="line"></span>transaction.commit()</div></code></pre><p>

Ideally, we'd perform global analysis to handle this, but that's not
currently possible. However, we <em class="asterisk">can</em> analyze some additional non-local
scenarios, and more importantly, we need to ensure that we don't offer false positive warnings in the above scenario.

</p>
<a class="target" name="returns">&nbsp;</a><a class="target" name="dataflowanalyzer/escapingvalues/returns">&nbsp;</a><a class="target" name="toc9.5.1">&nbsp;</a><h3>Returns</h3>
<p>


In the above case, our tracked transaction “escapes” the method that
we're analyzing through either an implicit return as in the above
Kotlin code or via an explicit return.

</p><p>

The analyzer has a callback method to let us know when this is happening. We can override that callback to remember that the value escapes, and if so, ignore the missing commit:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">var</span> foundCommit = <span class="hljs-literal">false</span>
<span class="line"></span><span class="hljs-keyword">var</span> escapes = <span class="hljs-literal">false</span>
<span class="line"></span><span class="hljs-keyword">val</span> visitor = <span class="hljs-keyword">object</span> : DataFlowAnalyzer(setOf(node)) {
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">returns</span><span class="hljs-params">(expression: <span class="hljs-type">UReturnExpression</span>)</span></span> {
<span class="line"></span>        escapes = <span class="hljs-literal">true</span>
<span class="line"></span>    }
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">argument</span><span class="hljs-params">(call: <span class="hljs-type">UCallExpression</span>, reference: <span class="hljs-type">UElement</span>)</span></span> {
<span class="line"></span>        <span class="hljs-keyword">super</span>.argument(call, reference)
<span class="line"></span>    }
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">field</span><span class="hljs-params">(field: <span class="hljs-type">UElement</span>)</span></span> {
<span class="line"></span>        <span class="hljs-keyword">super</span>.field(field)
<span class="line"></span>    }
<span class="line"></span>}
<span class="line"></span>node.getParentOfType(UMethod::<span class="hljs-keyword">class</span>.java)?.accept(visitor)
<span class="line"></span><span class="hljs-keyword">if</span> (!escapes &amp;&amp; !foundCommit) {
<span class="line"></span>    context.report(Incident(...))
<span class="line"></span>}</div></code></pre>
<a class="target" name="parameters">&nbsp;</a><a class="target" name="dataflowanalyzer/escapingvalues/parameters">&nbsp;</a><a class="target" name="toc9.5.2">&nbsp;</a><h3>Parameters</h3>
<p>


Another way our transaction can “escape” out of the method such that we
no longer know for certain whether it gets committed is via a method
call.

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> test) {</span>
<span class="line"></span>     <span class="hljs-keyword">val</span> transaction = getFragmentManager().beginTransaction()
<span class="line"></span>    process(transaction)
<span class="line"></span>}</div></code></pre><p>

Here, it's possible that the <code>process</code> method will proceed to actually
commit the transaction.

</p><p>

If we have source, we could resolve the call and take a look at the
method implementation (see the “Non Local Analysis” section below), but
in the general case, if a value escapes, we'll want to do something similar to a returned value. The analyzer has a callback for this, <code>argument</code>, which is invoked whenever our tracked value is passed into a method as an argument. The callback gives us both the argument and the call in case we want to handle conditional logic based on the specific method call.

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">var</span> escapes = <span class="hljs-literal">false</span>
<span class="line"></span><span class="hljs-keyword">val</span> visitor = <span class="hljs-keyword">object</span> : DataFlowAnalyzer(setOf(node)) {
<span class="line"></span>    ...
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">argument</span><span class="hljs-params">(call: <span class="hljs-type">UCallExpression</span>, reference: <span class="hljs-type">UElement</span>)</span></span> {
<span class="line"></span>        escapes = <span class="hljs-literal">true</span>
<span class="line"></span>    }
<span class="line"></span>    ...
<span class="line"></span>}</div></code></pre><p>

(By default, the analyzer will ignore calls that look like logging calls since those are probably safe and not true escapes; you can
customize this by overriding <code>ignoreArgument()</code>.)

</p>
<a class="target" name="fields">&nbsp;</a><a class="target" name="dataflowanalyzer/escapingvalues/fields">&nbsp;</a><a class="target" name="toc9.5.3">&nbsp;</a><h3>Fields</h3>
<p>


Finally, a value may escape a local method context if it gets stored
into a field:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span> {
<span class="line"></span>    <span class="hljs-keyword">this</span>.transaction = createTransaction()
<span class="line"></span>}</div></code></pre><p>

As with returns and method calls, the analyzer has a callback to make
it easy to handle when this is the case:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">var</span> escapes = <span class="hljs-literal">false</span>
<span class="line"></span><span class="hljs-keyword">val</span> visitor = <span class="hljs-keyword">object</span> : DataFlowAnalyzer(setOf(node)) {
<span class="line"></span>    ...
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">field</span><span class="hljs-params">(field: <span class="hljs-type">UElement</span>)</span></span> {
<span class="line"></span>        escapes = <span class="hljs-literal">true</span>
<span class="line"></span>    }
<span class="line"></span>    ...
<span class="line"></span>}</div></code></pre><p>

As you can see, it's passing in the field that is being stored to, in
case you want to perform additional analysis to track field values; see
the next section.

</p>
<a class="target" name="nonlocalanalysis">&nbsp;</a><a class="target" name="dataflowanalyzer/nonlocalanalysis">&nbsp;</a><a class="target" name="toc9.6">&nbsp;</a><h2>Non Local Analysis</h2>
<p>


In the above examples, if we found that the value escaped via a return
or method call or storage in a field, we simply gave up. In some cases
we can do better than that.

</p><p>

</p><ul>
<li class="asterisk">If the field we stored it into is a private field, we can visit
  the surrounding class, and check each reference to the field. If we
  can see that the field never escapes the class, we can perform the
  same analysis (using the data flow analyzer!) on each method where
  it's referenced.

<p></p><p>

</p></li>
<li class="asterisk">Similarly, if the method which returns the value is private, we can
  visit the surrounding class and see how the method is invoked, and
  track the value returned from it in each usage.

<p></p><p>

</p></li>
<li class="asterisk">Finally, if the value escapes as an argument to a call, we can
  resolve that call, and if it's to a method we have source for (which
  doesn't have to be in the same class, as long as it's in the same
  module), we can perform the analysis in that method as well, even
  reusing the same flow analyzer!</li></ul>

<p></p><p>

Complications: - storing in a field, returning, intermediate variables, self-referencing methods, scoping functions,

</p>
<a class="target" name="examples">&nbsp;</a><a class="target" name="dataflowanalyzer/examples">&nbsp;</a><a class="target" name="toc9.7">&nbsp;</a><h2>Examples</h2>
<p>


Here are some existing usages of the data flow analyzer in lint's
built-in rules.

</p>
<a class="target" name="simpleexample">&nbsp;</a><a class="target" name="dataflowanalyzer/examples/simpleexample">&nbsp;</a><a class="target" name="toc9.7.1">&nbsp;</a><h3>Simple Example</h3>
<p>


For WorkManager, ensure that newly created work tasks eventually
get enqueued:

</p><p>

<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/WorkManagerDetector.kt">Source</a>
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/checks/WorkManagerDetectorTest.kt">Test</a>

</p>
<a class="target" name="complexexample">&nbsp;</a><a class="target" name="dataflowanalyzer/examples/complexexample">&nbsp;</a><a class="target" name="toc9.7.2">&nbsp;</a><h3>Complex Example</h3>
<p>


For the Slices API, apply a number of checks on chained calls constructing slices, checking that you only specify a single timestamp, that you don't mix icons and actions, etc etc.

</p><p>

<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/SliceDetector.kt">Source</a>
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-tests/src/test/java/com/android/tools/lint/checks/SliceDetectorTest.kt">Test</a>

</p><p>



</p>
<a class="target" name="annotations">&nbsp;</a><a class="target" name="annotations">&nbsp;</a><a class="target" name="toc10">&nbsp;</a><h1>Annotations</h1>
<p>


Annotations allow API authors to express constraints that tools can
enforce. There are many examples of these, along with existing lint
checks:

</p><p>

</p><ul>
<li class="asterisk"><code>@VisibleForTesting</code>: this API is considered private, and has been
   exposed only for unit testing purposes
</li>
<li class="asterisk"><code>@CheckResult</code>: anyone calling this method is expected to do
  something with the return value
</li>
<li class="asterisk"><code>@CallSuper</code>: anyone overriding this method must also invoke <code>super</code>
</li>
<li class="asterisk"><code>@UiThread</code>: anyone calling this method must be calling from the UI thread
</li>
<li class="asterisk"><code>@Size</code>: the size of the annotated array or collection must be
    of a particular size
</li>
<li class="asterisk"><code>@IntRange</code>: the annotated integer must have a value in the given range</li></ul>

<p></p><p>

...and so on. Lint has built-in checks to enforce these, along with
infrastructure to make them easy to write, and to share analysis such
that improvements to one helps them all. This means that you can easily
write your own annotations-based checks as well.

</p><p>

</p><div class="admonition tip">Note that the annotation support helps you write checks where you
   check <em class="asterisk">usages</em> of annotated elements, not usages of the annotations
   themselves. If you simply want to look at actual annotations,
   override <code>getApplicableUastTypes</code> to return
   <code>listOf(UAnnotation::class.java)</code>, and override <code>createUastHandler</code>
   to return an <code>object : UElementHandler</code> which simply overrides
   <code>visitAnnotation</code>.</div>

<p></p>
<a class="target" name="basics">&nbsp;</a><a class="target" name="annotations/basics">&nbsp;</a><a class="target" name="toc10.1">&nbsp;</a><h2>Basics</h2>
<p>


To create a basic annotation checker, there are two required steps:

</p><p>

</p><ol start="1">
<li class="number">Register the fully qualified name (or names) of the annotation
   classes you want to analyze, and
</li>
<li class="number">Implement the <code>visitAnnotationUsage</code> callback for handling each
   occurrence.</li></ol>

<p></p><p>

Here's a basic example:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">applicableAnnotations</span><span class="hljs-params">()</span></span>: List&lt;string&gt; {
<span class="line"></span>    <span class="hljs-keyword">return</span> listOf(<span class="hljs-string">"my.pkg.MyAnnotation"</span>)
<span class="line"></span>}
<span class="line"></span>
<span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitAnnotationUsage</span><span class="hljs-params">(
<span class="line"></span>    context: <span class="hljs-type">JavaContext</span>,
<span class="line"></span>    element: <span class="hljs-type">UElement</span>,
<span class="line"></span>    annotationInfo: <span class="hljs-type">AnnotationInfo</span>,
<span class="line"></span>    usageInfo: <span class="hljs-type">AnnotationUsageInfo</span>
<span class="line"></span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> name = annotationInfo.qualifiedName.substringAfterLast(<span class="hljs-string">'.'</span>)
<span class="line"></span>    <span class="hljs-keyword">val</span> message = <span class="hljs-string">"`<span class="hljs-subst">${usageInfo.type.name}</span>` usage associated with "</span> +
<span class="line"></span>                  <span class="hljs-string">"`@<span class="hljs-variable">$name</span>` on <span class="hljs-subst">${annotationInfo.origin}</span>"</span>
<span class="line"></span>    <span class="hljs-keyword">val</span> location = context.getLocation(element)
<span class="line"></span>    context.report(TEST_ISSUE, element, location, message)
<span class="line"></span>}</code></pre><p>

All this simple detector does is flag any usage associated with the
given annotation, including some information about the usage.

</p><p>

If we for example have the following annotated API:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnnotation</span></span>
<span class="line"></span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>{
<span class="line"></span>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-meta">@MyAnnotation</span> word: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = TODO()
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = TODO()
<span class="line"></span>    <span class="hljs-meta">@MyAnnotation</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> = TODO()
<span class="line"></span>}
<span class="line"></span><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Book.<span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@MyAnnotation</span> index: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = TODO()</code></pre><p>

...and we then run the above detector on the following test case:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(book: <span class="hljs-type">Book</span>)</span></span> {
<span class="line"></span>    <span class="hljs-keyword">val</span> found = <span class="hljs-string">"lint"</span> <span class="hljs-keyword">in</span> book
<span class="line"></span>    <span class="hljs-keyword">val</span> firstWord = book[<span class="hljs-number">0</span>]
<span class="line"></span>    book.close()
<span class="line"></span>}</code></pre><p>

we get the following output:

</p><pre class="listing tilde"><code><span class="line"></span>src/book.kt:14: Error: METHOD_CALL_PARAMETER usage associated with @MyAnnotation on PARAMETER
<span class="line"></span>    val found = "lint" in book
<span class="line"></span>                 ----
<span class="line"></span>src/book.kt:15: Error: METHOD_CALL_PARAMETER usage associated with @MyAnnotation on PARAMETER
<span class="line"></span>    val firstWord = book[0]
<span class="line"></span>                         -
<span class="line"></span>src/book.kt:16: Error: METHOD_CALL usage associated with @MyAnnotation on METHOD
<span class="line"></span>    book.close()
<span class="line"></span>         -------</code></pre><p>

In the first case, the infix operator “in” will call <code>contains</code> under
the hood, and here we've annotated the parameter, so lint visits the
argument corresponding to that parameter (the literal string “lint”).

</p><p>

The second case shows a similar situation where the array syntax will
end up calling our extension method, <code>get()</code>.

</p><p>

And the third case shows the most common scenario: a straight forward
method call to an annotated method.

</p><p>

In many cases, the above detector implementation is nearly all you have
to do to enforce an annotation constraint. For example, in the
<code>@CheckResult</code> detector, we want to make sure that anyone calling a
method annotated with <code>@CheckResult</code> will not ignore the method return
value. All the lint check has to do is register an interest in
<em class="asterisk"><code>androidx.annotation.CheckResult</code></em>, and lint will invoke
<code>visitAnnotationUsage</code> for each method call to the annotated method.
Then we just check the method call to make sure that its return value
isn't ignored, e.g. that it's stored into a variable or passed into
another method call.

</p><p>

</p><div class="admonition tip">In <code>applicableAnnotations</code>, you typically return the fully
   qualified names of the annotation classes your detector is
   targeting. However, in some cases, it's useful to match all
   annotations of a given name; for example, there are many, many
   variations of the <code>@Nullable</code> annotations, and you don't really
   want to be in the business of keeping track of and listing all of
   them here. Lint will also let you specify just the basename of an
   annotation here, such as <code>"Nullable"</code>, and if so, annotations like
   <code>androidx.annotation.Nullable</code> and
   <code>org.jetbrains.annotations.Nullable</code> will both match.</div>

<p></p>
<a class="target" name="annotationusagetypesandisapplicableannotationusage">&nbsp;</a><a class="target" name="annotations/annotationusagetypesandisapplicableannotationusage">&nbsp;</a><a class="target" name="toc10.2">&nbsp;</a><h2>Annotation Usage Types and isApplicableAnnotationUsage</h2>

<a class="target" name="methodoverride">&nbsp;</a><a class="target" name="annotations/annotationusagetypesandisapplicableannotationusage/methodoverride">&nbsp;</a><a class="target" name="toc10.2.1">&nbsp;</a><h3>Method Override</h3>
<p>


In the detector above, we're including the “usage type” in the error
message. The usage type tells you something about how the annotation is
associated with the usage element — and in the above, the first two
cases have a usage type of “parameter” because the visited element
corresponds to a parameter annotation, and the third one a method
annotation.

</p><p>

There are many other usage types. For example, if we add the following
to the API:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Paperback</span> : <span class="hljs-type">Book</span></span>() {
<span class="line"></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> { }
<span class="line"></span>}</code></pre><p>

then the detector will emit the following incident since the new method
overrides another method that was annotated:

</p><pre class="listing tilde"><code><span class="line"></span>src/book.kt:14: Error: METHOD_OVERRIDE usage associated with @MyAnnotation on METHOD
<span class="line"></span>    override fun close() { }
<span class="line"></span>                 -----
<span class="line"></span>1 errors, 0 warnings</code></pre><p>

Overriding an annotated element is how the <code>@CallSuper</code> detector is
implemented, which makes sure that any method which overrides a method
annotated with <code>@CallSuper</code> is invoking <code>super</code> on the overridden
method somewhere in the method body.

</p>
<a class="target" name="methodreturn">&nbsp;</a><a class="target" name="annotations/annotationusagetypesandisapplicableannotationusage/methodreturn">&nbsp;</a><a class="target" name="toc10.2.2">&nbsp;</a><h3>Method Return</h3>
<p>


Here's another example, where we have annotated the return value
with @MyAnnotation:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Paperback</span> : <span class="hljs-type">Book</span></span>() {
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDefaultCaption</span><span class="hljs-params">()</span></span>: String = TODO()
<span class="line"></span>    <span class="hljs-meta">@MyAnnotation</span>
<span class="line"></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCaption</span><span class="hljs-params">(imageId: <span class="hljs-type">Int</span>)</span></span>: String {
<span class="line"></span>        <span class="hljs-keyword">if</span> (imageId == <span class="hljs-number">5</span>) {
<span class="line"></span>            <span class="hljs-keyword">return</span> <span class="hljs-string">"Blah blah blah"</span>
<span class="line"></span>        } <span class="hljs-keyword">else</span> {
<span class="line"></span>            <span class="hljs-keyword">return</span> getDefaultCaption()
<span class="line"></span>        }
<span class="line"></span>    }
<span class="line"></span>}</code></pre><p>

Here, lint will flag the various exit points from the method
associated with the annotation:

</p><pre class="listing tilde"><code><span class="line"></span>src/book.kt:18: Error: METHOD_RETURN usage associated with @MyAnnotation on METHOD
<span class="line"></span>            return "Blah blah blah"
<span class="line"></span>                    --------------
<span class="line"></span>src/book.kt:20: Error: METHOD_RETURN usage associated with @MyAnnotation on METHOD
<span class="line"></span>            return getDefaultCaption()
<span class="line"></span>                   -------------------
<span class="line"></span>2 errors, 0 warnings</code></pre><p>

Note also that this would have worked if the annotation had been
inherited from a super method instead of being explicitly set here.

</p><p>

One usage of this mechanism in Lint is the enforcement of return values
in methods. For example, if a method has been marked with
<code>@DrawableRes</code>, Lint will make sure that the returned value of that
method will not be of an incompatible resource type (such as
<code>@StringRes</code>).

</p>
<a class="target" name="handlingusagetypes">&nbsp;</a><a class="target" name="annotations/annotationusagetypesandisapplicableannotationusage/handlingusagetypes">&nbsp;</a><a class="target" name="toc10.2.3">&nbsp;</a><h3>Handling Usage Types</h3>
<p>


As you can see, your callback will be invoked for a wide variety of
usage types, and sometimes, they don't apply to the scenario that your
detector is interested in. Consider the <code>@CheckResult</code> detector again,
which makes sure that any calls to a given method will look at the
return value. From the “method override” section above, you can see
that lint would <em class="asterisk">also</em> notify your detector for any method that is
<em class="asterisk">overriding</em> (rather than calling) a method annotated with
<code>@CheckResult</code>. We don't want to report those.

</p><p>

There are two ways to handle this. The first one is to check whether
the usage element is a <code>UMethod</code>, which it will be in the overriding
case, and return early in that case.

</p><p>

The recommended approach, which <code>CheckResultDetector</code> uses, is to
override the <code>isApplicableAnnotationUsage</code> method:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isApplicableAnnotationUsage</span><span class="hljs-params">(type: <span class="hljs-type">AnnotationUsageType</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
<span class="line"></span>    <span class="hljs-keyword">return</span> type != AnnotationUsageType.METHOD_OVERRIDE &amp;&amp;
<span class="line"></span>            <span class="hljs-keyword">super</span>.isApplicableAnnotationUsage(type)
<span class="line"></span>}</code></pre><p>



</p><div class="admonition tip">Notice how we are also calling <code>super</code> here and combining the result
   instead of just using a hardcoded list of expected usage types. This
   is because, as discussed below, lint already filters out some usage
   types by default in the super implementation.</div>

<p></p>
<a class="target" name="usagetypesfilteredbydefault">&nbsp;</a><a class="target" name="annotations/annotationusagetypesandisapplicableannotationusage/usagetypesfilteredbydefault">&nbsp;</a><a class="target" name="toc10.2.4">&nbsp;</a><h3>Usage Types Filtered By Default</h3>
<p>


The default implementation of <code>Detector.isApplicableAnnotationUsage</code>
looks like this:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isApplicableAnnotationUsage</span><span class="hljs-params">(type: <span class="hljs-type">AnnotationUsageType</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
<span class="line"></span>    <span class="hljs-keyword">return</span> type != AnnotationUsageType.BINARY &amp;&amp;
<span class="line"></span>           type != AnnotationUsageType.EQUALITY
<span class="line"></span>}</code></pre><p>

These usage types apply to cases where annotated elements are
compared for equality or using other binary operators. Initially
introducing this support led to a lot of noise and false positives;
most of the existing lint checks do not want this, so they're opt-in.

</p><p>

An example of a lint check which <em class="asterisk">does</em> enforce this is the
<code>@HalfFloat</code> lint check. In Android, a
<a href="https://developer.android.com/reference/androidx/annotation/" halffloat="">HalfFloat</a> is a representation of a floating point value (with less
precision than a <code>float</code>) which is stored in a <code>short</code>, normally an
integer primitive value. If you annotate a <code>short</code> with <code>@HalfFloat</code>,
including in APIs, lint can help catch cases where you are making
mistakes — such as accidentally widening the value to an int, and so
on. Here are some example error messages from lint's unit tests for the
half float check:

</p><pre class="listing tilde"><code><span class="line"></span>src/test/pkg/HalfFloatTest.java:23: Error: Expected a half float here, not a resource id [HalfFloat]
<span class="line"></span>        method1(getDimension1()); // ERROR
<span class="line"></span>                ---------------
<span class="line"></span>src/test/pkg/HalfFloatTest.java:43: Error: Half-float type in expression widened to int [HalfFloat]
<span class="line"></span>        int result3 = float1 + 1; // error: widening
<span class="line"></span>                      ------
<span class="line"></span>src/test/pkg/HalfFloatTest.java:50: Error: Half-float type in expression widened to int [HalfFloat]
<span class="line"></span>        Math.round(float1); // Error: should use Half.round
<span class="line"></span>                   ------</code></pre>
<a class="target" name="scopes">&nbsp;</a><a class="target" name="annotations/annotationusagetypesandisapplicableannotationusage/scopes">&nbsp;</a><a class="target" name="toc10.2.5">&nbsp;</a><h3>Scopes</h3>
<p>


Many annotations apply not just to methods or fields but to classes and
even packages, with the idea that the annotation applies to everything
within the package.

</p><p>

For example, if we have this annotated API:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span></span>
<span class="line"></span><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotThreadSafe</span></span>
<span class="line"></span>
<span class="line"></span><span class="hljs-meta">@ThreadSafe</span>
<span class="line"></span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-type">t</span>&gt; </span>{
<span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span>
<span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">push</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>
<span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>: String
<span class="line"></span>    <span class="hljs-meta">@NotThreadSafe</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span> { }
<span class="line"></span>
<span class="line"></span>    <span class="hljs-meta">@NotThreadSafe</span>
<span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStack</span>&lt;<span class="hljs-type">t</span>&gt; : <span class="hljs-type">Stack</span>&lt;<span class="hljs-type">t</span>&gt;</span>() {
<span class="line"></span>        <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>: String
<span class="line"></span>    }
<span class="line"></span>}</div></code></pre><p>

And the following test case:

</p><pre class="listing tilde"><code><div class=" linenumbers"><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(stack: <span class="hljs-type">Stack</span>&lt;<span class="hljs-type">string</span>&gt;, fileStack: <span class="hljs-type">Stack</span>&lt;<span class="hljs-type">string</span>&gt;)</span></span> {
<span class="line"></span>    stack.push(<span class="hljs-string">"Hello"</span>)
<span class="line"></span>    stack.pop()
<span class="line"></span>    fileStack.push(<span class="hljs-string">"Hello"</span>)
<span class="line"></span>    fileStack.pop()
<span class="line"></span>}</div></code></pre><p>

Here, <code>stack.push</code> call on line 2 resolves to the API method on line 7.
That method is not annotated, but it's inside a class that is annotated
with <code>@ThreadSafe</code>. Similarly for the <code>pop()</code> call on line 3.

</p><p>

The <code>fileStack.push</code> call on line 4 also resolves to the same method
as the call on line 2 (even though the concrete type is a <code>FileStack</code>
instead of a `Stack), so like on line 2, this call is taken to be
thread safe.

</p><p>

However, the <code>fileStack.pop</code> call on line 6 resolves to the API method
on line 14. That method is not annotated, but it's inside a class
annotated with <code>@NotThreadSafe</code>, which in turn is inside an outer class
annotated with <code>@ThreadSafe</code>. The intent here is clearly that that
method should be considered not thread safe.

</p><p>

To help with scenarios like this, lint will provide <em class="asterisk">all</em> the
annotations (well, all annotations that any lint checks have registered
interest in via <code>getApplicableAnnotations</code>; it will not include
annotations like <code>java.lang.SuppressWarnings</code> and so on unless a lint
check asks for it).

</p><p>

This is provided in the <code>AnnotationUsageInfo</code> passed to the
<code>visitAnnotationUsage</code> parameters. The <code>annotations</code> list will include
all relevant annotations, <strong class="asterisk">in scope order</strong>. That means that for the
above <code>pop</code> call on line 5, it will point to first the annotations on
the <code>pop</code> method (and here there are none), then the <code>@NotThreadSafe</code>
annotation on the surrounding class, and then the <code>@ThreadSafe</code>
annotation on the outer class, and then annotations on the file itself
and the package.

</p><p>

The <code>index</code> points to the annotation we're analyzing. If for example
our detector had registered an interest in <code>@ThreadSafe</code>, it would be
called for the second <code>pop</code> call as well, since it calls a method
inside a <code>@ThreadSafe</code> annotation (on the outer class), but the <code>index</code>
would be 1. The lint check can check all the annotations earlier than
the one at the index to see if they “counteract” the annotation, which
of course the <code>@NotThreadSafe</code> annotation does.

</p><p>

Lint uses this mechanism for example for the <code>@CheckResult</code> annotation,
since some APIs are annotated with <code>@CheckResult</code> for whole packages
(as an API convention), and then there are explicit exceptions carved
out using <code>@CanIgnoreReturnValue</code>. There is a method on the
<code>AnnotationUsageInfo</code>, <code>anyCloser</code>, which makes this check easy:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">if</span> (usageInfo.anyCloser { it.qualifiedName ==
<span class="line"></span>     <span class="hljs-string">"com.google.errorprone.annotations.CanIgnoreReturnValue"</span> }) {
<span class="line"></span>    <span class="hljs-comment">// There's a closer @CanIgnoreReturnValue which cancels the</span>
<span class="line"></span>    <span class="hljs-comment">// outer @CheckReturnValue annotation we're analyzing here</span>
<span class="line"></span>    <span class="hljs-keyword">return</span>
<span class="line"></span>}</code></pre><p>



</p><div class="admonition tip">You only have to worry about this when there are different
   annotations that interact with each other. If the same annotation is
   found in multiple nested contexts, lint <em class="asterisk">will</em> include all the
   annotations in the <code>AnnotationUsageInfo</code>, but it will not invoke
   your callback for any outer occurrences; only the closest one. This
   is usually what detectors expect: the innermost one “overrides” the
   outer ones, so lint omits these to help avoid false positives where
   a lint check author forgot to handle and test this scenario. A good
   example of this situation is with the <code>@RequiresApi</code> annotation; a
   class may be annotated as requiring a particular API level, but a
   specific inner class or method within the class can have a more
   specific <code>@RequiresApi</code> annotation, and we only want the detector to
   be invoked for the innermost one. If for some reason your detector
   <em class="asterisk">does need</em> to handle all of the repeated outer occurrences, note
   that they're all there in the <code>annotations</code> list for the
   <code>AnnotationUsageInfo</code> so you can look for them and handle them when
   you are invoked for the innermost one.</div>

<p></p>
<a class="target" name="inheritedannotations">&nbsp;</a><a class="target" name="annotations/annotationusagetypesandisapplicableannotationusage/inheritedannotations">&nbsp;</a><a class="target" name="toc10.2.6">&nbsp;</a><h3>Inherited Annotations</h3>
<p>


As we saw in the method overrides section, lint will include
annotations in the hierarchy: annotations specified not just on a
specific method but super implementations and so on.

</p><p>

This is normally what you want — for example, if a method is annotated
with <code>@CheckResult</code> (such as <code>String.trim()</code>, where it's important to
understand that you're not changing the string in place, there's a new
string returned so it's probably a mistake to not use it), you probably
want any overriding implementations to have the same semantics.

</p><p>

However, there are exceptions to this. For example,
<code>@VisibleForTesting</code>. Perhaps a super class made a method public only
for testing purposes, but you have a concrete subclass where you are
deliberately supporting the operation, not just from tests. If
annotations were always inherited, you would have to create some sort
of annotation to “revert” the semantics, e.g.
<code>@VisibleNotJustForTesting</code>, which would require a lot of noisy
annotations.

</p><p>

Lint lets you specify the inheritance behavior of individual
annotations. For example, the lint check which enforces the
<code>@VisibleForTesting</code> and <code>@RestrictTo</code> annotations handles it like this:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inheritAnnotation</span><span class="hljs-params">(<span class="hljs-keyword">annotation</span>: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
<span class="line"></span>    <span class="hljs-comment">// Require restriction annotations to be annotated everywhere</span>
<span class="line"></span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
<span class="line"></span>}</code></pre><p>

(Note that the API passes in the fully qualified name of the annotation
in question so you can control this behavior individually for each
annotation when your detector applies to multiple annotations.)

</p><p>



</p>
<a class="target" name="options">&nbsp;</a><a class="target" name="options">&nbsp;</a><a class="target" name="toc11">&nbsp;</a><h1>Options</h1>

<a class="target" name="usage">&nbsp;</a><a class="target" name="options/usage">&nbsp;</a><a class="target" name="toc11.1">&nbsp;</a><h2>Usage</h2>
<p>


Users can configure lint using <code>lint.xml</code> files, turning on and off
checks, changing the default severity, ignoring violations based on
paths or regular expressions matching paths or messages, and so on.

</p><p>

They can also configure “options” on a per issue type basis. Options
are simply strings, booleans, integers or paths that configure how a
detector works.

</p><p>

For example, in the following <code>lint.xml</code> file, we're configuring the
<code>UnknownNullness</code> detector to turn on its <code>ignoreDeprecated</code> option,
and we're telling the <code>TooManyViews</code> detector that the maximum number
of views in a layout it should allow before generating a warning should
be set to 20:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="line"></span><span class="hljs-tag">&lt;<span class="hljs-name">lint</span>&gt;</span>
<span class="line"></span>    <span class="hljs-tag">&lt;<span class="hljs-name">issue</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"UnknownNullness"</span>&gt;</span>
<span class="line"></span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ignoreDeprecated"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span>
<span class="line"></span>    <span class="hljs-tag">&lt;/<span class="hljs-name">issue</span>&gt;</span>
<span class="line"></span>    <span class="hljs-tag">&lt;<span class="hljs-name">issue</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"TooManyViews"</span>&gt;</span>
<span class="line"></span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxCount"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span> /&gt;</span>
<span class="line"></span>    <span class="hljs-tag">&lt;/<span class="hljs-name">issue</span>&gt;</span>
<span class="line"></span><span class="hljs-tag">&lt;/<span class="hljs-name">lint</span>&gt;</span></code></pre><p>

Note that <code>lint.xml</code> files can be located not just in the project
directory but nested as well, for example for a particular source
folder.

</p><p>

(See the <a href="#configuringusinglint.xmlfiles">lint.xml</a> documentation for more.)

</p>
<a class="target" name="creatingoptions">&nbsp;</a><a class="target" name="options/creatingoptions">&nbsp;</a><a class="target" name="toc11.2">&nbsp;</a><h2>Creating Options</h2>
<p>


First, create an <code>Option</code> and register it with the corresponding
<code>Issue</code>.

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> MAX_COUNT = IntOption(<span class="hljs-string">"maxCount"</span>, <span class="hljs-string">"Max number of views allowed"</span>, <span class="hljs-number">80</span>)
<span class="line"></span><span class="hljs-keyword">val</span> MY_ISSUE = Issue.create(<span class="hljs-string">"MyId"</span>, ...)
<span class="line"></span>        .setOptions(listOf(MAX_COUNT))</code></pre><p>

An option has a few pieces of metadata:

</p><p>

</p><ul>
<li class="asterisk">The name, which is a short identifier. Users will configure the
  option by listing this key along with the configured value in their
  <code>lint.xml</code> files. By convention this should be using camel case and
  only valid Java identifier characters.

<p></p><p>

</p></li>
<li class="asterisk">A description. This should be a short sentence which lists the
  purpose of the option (and should be capitalized, and not end with
  punctuation).

<p></p><p>

</p></li>
<li class="asterisk">A default value. This is the value that will be returned from
  <code>Option.getValue()</code> if the user has not configured the setting.

<p></p><p>

</p></li>
<li class="asterisk">For integer and float options, minimum and maximum allowed values.

<p></p><p>

</p></li>
<li class="asterisk">An optional explanation. This is a longer explanation of the option,
  if necessary.</li></ul>

<p></p><p>

The name and default value are used by lint when options are looked up
by detectors; the description, explanation and allowed ranges are used
to include information about available options when lint generates for
example HTML reports, or text reports including explanations, or
displaying lint checks in the IDE settings panel, and so on.

</p><p>

There are currently 5 types of options: Strings, booleans, ints, floats
and paths. There's a separate option class for each one, which makes it
easier to look up these options since for example for a <code>StringOption</code>,
<code>getValue</code> returns a <code>String</code>, for an <code>IntOption</code> it returns an <code>Int</code>,
and so on.
</p><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Option Type </th><th style="text-align:left"> Option Class </th></tr>
<tr><td style="text-align:left"> <code>String</code> </td><td style="text-align:left"> <code>StringOption</code> </td></tr>
<tr><td style="text-align:left"> <code>Boolean</code> </td><td style="text-align:left"> <code>BooleanOption</code> </td></tr>
<tr><td style="text-align:left"> <code>Int</code> </td><td style="text-align:left"> <code>IntOption</code> </td></tr>
<tr><td style="text-align:left"> <code>Float</code> </td><td style="text-align:left"> <code>FloatOption</code> </td></tr>
<tr><td style="text-align:left"> <code>File</code> </td><td style="text-align:left"> <code>FileOption</code> </td></tr>
</tbody></table></div>

<p></p>
<a class="target" name="readingoptions">&nbsp;</a><a class="target" name="options/readingoptions">&nbsp;</a><a class="target" name="toc11.3">&nbsp;</a><h2>Reading Options</h2>
<p>


To look up the configured value for an option, just call <code>getValue</code>
and pass in the <code>context</code>:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> maxCount = MAX_COUNT.getValue(context)</code></pre><p>

This will return the <code>Int</code> value configured for this option by the
user, or if not set, our original default value, in this case 80.

</p>
<a class="target" name="specificconfigurations">&nbsp;</a><a class="target" name="options/specificconfigurations">&nbsp;</a><a class="target" name="toc11.4">&nbsp;</a><h2>Specific Configurations</h2>
<p>


The above call will look up the option configured for the specific
source file in the current <code>context</code>, which might be an individual
Kotlin source file. That's generally what you want; users can configure
<code>lint.xml</code> files not just at the root of the project; they can be
placed throughout the source folders and are interpreted by lint to
apply to the folders below. Therefore, if we're analyzing a particular
Kotlin file and we want to check an option, you generally want to check
what's configured locally for this file.

</p><p>

However, there are cases where you want to look up options up front,
for example at the project level.

</p><p>

In that case, first look up the particular configuration you want, and
then pass in that configuration instead of the context to the
<code>Option.getValue</code> call.

</p><p>

For example, the context for the current module is already available in
the <code>context</code>, so you might for example look up the option value like
this:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> maxCount = MAX_COUNT.getValue(context.configuration)</code></pre><p>

If you want to find the most applicable configuration for a given
source file, use

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> configuration = context.findConfiguration(context.file)
<span class="line"></span><span class="hljs-keyword">val</span> maxCount = MAX_COUNT.getValue(configuration)</code></pre>
<a class="target" name="files">&nbsp;</a><a class="target" name="options/files">&nbsp;</a><a class="target" name="toc11.5">&nbsp;</a><h2>Files</h2>
<p>


Note that there is a special <code>Option</code> type for files and paths:
<code>FileOption</code>. Make sure that you use this instead of just a
<code>StringOption</code> if you are planning on configuring files, because in the
case of paths, users will want to specify paths relative to the
location of the <code>lint.xml</code> file where the path is defined. For
<code>FileOption</code> lint is aware of this and will convert the relative path
string as necessary.

</p>
<a class="target" name="constraints">&nbsp;</a><a class="target" name="options/constraints">&nbsp;</a><a class="target" name="toc11.6">&nbsp;</a><h2>Constraints</h2>
<p>


Note that the integer and float options allow you to specify a valid
range for the configured value — a minimum (inclusive) and a maximum
(exclusive):

</p><p>

This range will be included with the option documentation, such as in
“<strong class="asterisk">duration</strong> (default is 1.5): Expected duration in seconds. Must be
at least 0.0 and less than 15.0.”

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> DURATION_OPTION = FloatOption(
<span class="line"></span>    name = <span class="hljs-string">"duration"</span>,
<span class="line"></span>    description = <span class="hljs-string">"Expected duration"</span>,
<span class="line"></span>    defaultValue = <span class="hljs-number">1.5f</span>,
<span class="line"></span>    min = <span class="hljs-number">0f</span>,
<span class="line"></span>    max = <span class="hljs-number">15f</span>
<span class="line"></span>)</code></pre><p>

It will also be checked at runtime, and if the configured value is
outside of the range, lint will report an error and pinpoint the
location in the invalid <code>lint.xml</code> file:

</p><pre class="listing backtick"><code><span class="line"></span>lint.xml:4: Error: duration: Must be less than 15.0 [LintError]
<span class="line"></span>        &lt;option name="duration" value="100.0"&gt;
<span class="line"></span>        ----------------------------------------
<span class="line"></span>1 errors, 0 warnings</code></pre>
<a class="target" name="testingoptions">&nbsp;</a><a class="target" name="options/testingoptions">&nbsp;</a><a class="target" name="toc11.7">&nbsp;</a><h2>Testing Options</h2>
<p>


When writing a lint unit test, you can easily configure specific values
for your detector options. On the <code>lint()</code> test task, you can call
<code>configureOption(option, value)</code>. There are a number of overloads for
this method, so you can reference the option by its string name, or
passing in the option instance, and if you do, you can pass in strings,
integers, booleans, floats and files as values. Here's an example:

</p><pre class="listing tilde"><code><span class="line"></span>lint().files(
<span class="line"></span>    kotlin(<span class="hljs-string">"fun test() { println("</span>Hello World.<span class="hljs-string">") }"</span>)
<span class="line"></span>)
<span class="line"></span>.configureOption(MAX_COUNT, <span class="hljs-number">150</span>)
<span class="line"></span>.run()
<span class="line"></span>.expectClean()</code></pre>
<a class="target" name="supportinglint4.2,7.0and7.1">&nbsp;</a><a class="target" name="options/supportinglint4.2,7.0and7.1">&nbsp;</a><a class="target" name="toc11.8">&nbsp;</a><h2>Supporting Lint 4.2, 7.0 and 7.1</h2>
<p>


The <code>Option</code> support is new in 7.2. If your lint check still needs to
work with older versions of lint, you can bypass the option
registration, and just read option values directly from the
configuration.

</p><p>

First, find the configuration as shown above, and then instead of
calling <code>Option.getValue</code>, call <code>getOption</code> on the configuration:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> option: String? = configuration.getOption(ISSUE, <span class="hljs-string">"maxCount"</span>)</code></pre><p>

The <code>getOption</code> method returns a <code>String</code>. For numbers and booleans,
the coniguration also provides lookups which will convert the value to
a number or boolean respectively: <code>getOptionAsInt</code>,
<code>getOptionAsBoolean</code>, and most importantly, <code>getOptionAsFile</code>. If you
are looking up paths, be sure to use <code>getOptionAsFile</code> since it has the
important attribute that it allows paths to be relative to the
configuration file where the (possibly inherited) value was defined,
which is what users expect when editing <code>lint.xml</code> files.

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">val</span> option = configuration.getOptionAsInt(ISSUE, <span class="hljs-string">"maxCount"</span>, <span class="hljs-number">100</span>)</code></pre><p>



</p>
<a class="target" name="errormessageconventions">&nbsp;</a><a class="target" name="errormessageconventions">&nbsp;</a><a class="target" name="toc12">&nbsp;</a><h1>Error Message Conventions</h1>

<a class="target" name="length">&nbsp;</a><a class="target" name="errormessageconventions/length">&nbsp;</a><a class="target" name="toc12.1">&nbsp;</a><h2>Length</h2>
<p>


The error message reported by a detector should typically be short; think of
typical compiler error messages you see from <code>kotlinc</code> or <code>javac</code>.

</p><p>

This is particularly important when your lint check is running inside the IDE,
because the error message will typically be shown as a tooltip as the user
hovers over the underlined symbol.

</p><p>

It's tempting to try to fully explain what's going on, but lint has separate
facilities for that — the issue explanation metadata. When lint generates text
and html reports, it will include the explanation metadata. Similarly, in the
IDE, users can pull up the full explanation with a tooltip.

</p><p>

This is not a hard rule; there are cases where lint uses multiple sentences to
explain an issue, but strive to make the error message as short as possible
while still legible.

</p>
<a class="target" name="formatting">&nbsp;</a><a class="target" name="errormessageconventions/formatting">&nbsp;</a><a class="target" name="toc12.2">&nbsp;</a><h2>Formatting</h2>
<p>


Use the available formatting support for text in lint:
</p><div class="table">
<table class="table"><tbody><tr><th style="text-align:left"> Raw text format </th><th style="text-align:left"> Renders To </th></tr>
<tr><td style="text-align:left"> This is a `code symbol` </td><td style="text-align:left"> This is a <code>code symbol</code> </td></tr>
<tr><td style="text-align:left"> This is <code>*italics*</code> </td><td style="text-align:left"> This is <em class="asterisk">italics</em> </td></tr>
<tr><td style="text-align:left"> This is <code>**bold**</code> </td><td style="text-align:left"> This is <strong class="asterisk">bold</strong> </td></tr>
<tr><td style="text-align:left"> <a href="http://," class="url">http://,</a> <a href="https:// " class="url">https:// </a></td><td style="text-align:left"> <a href="http://"></a><a href="http://</a" class="url">http://, </a><a href="https://"></a><a href="https://</a" class="url">https:// </a></td></tr>
<tr><td style="text-align:left"> <code>\*not italics*</code> </td><td style="text-align:left"> <code>\*not italics*</code> </td></tr>
<tr><td style="text-align:left"> ```language\n text\n``` </td><td style="text-align:left"> (preformatted text block) </td></tr>
</tbody></table><center><div class="tablecaption">Supported markup in lint's markdown-like raw text format</div></center></div>

<p></p><p>

In particular, when referencing code elements such as variable names, APIs, and
so on, use the code symbol formatting (`like this`), not simple or double
quotes.

</p>
<a class="target" name="punctuation">&nbsp;</a><a class="target" name="errormessageconventions/punctuation">&nbsp;</a><a class="target" name="toc12.3">&nbsp;</a><h2>Punctuation</h2>
<p>


One line error messages should not be punctuated - e.g. the error message
should be “Unused import foo”, not “Unused import foo.”

</p><p>

However, if there are multiple sentences in the error message, all sentences
should be punctuate.

</p><p>

Note that there should be no space before an exclamation (!) or question mark
(?) sign.

</p>
<a class="target" name="includedetails">&nbsp;</a><a class="target" name="errormessageconventions/includedetails">&nbsp;</a><a class="target" name="toc12.4">&nbsp;</a><h2>Include Details</h2>
<p>


Avoid generic error messages such as “Unused import”; try to incorporate
specific details from the current error. In the unused import example, instead
of just saying “Unused import”, say “Unused import java.io.List”.

</p><p>

In addition to being clearer (you can see from the error message what the
problem is without having to look up the corresponding source code), this is
important to support lint's <a href="#baselines">baseline</a> feature.
Lint matches known errors not by matching on specific line numbers (which would
cause problems as soon as the line numbers drift after edits to the file), lint
matches by error message in the file, so the more unique error messages are,
the better. If all unused import warnings were just “Unused import”, lint would
match them in order, which often would be the wrong thing.

</p>
<a class="target" name="referenceandroidbynumber">&nbsp;</a><a class="target" name="errormessageconventions/referenceandroidbynumber">&nbsp;</a><a class="target" name="toc12.5">&nbsp;</a><h2>Reference Android By Number</h2>
<p>


When referring to Android behaviors introduced in new API levels, use the
phrase “In Android 12 and higher”, instead of variations like “Android S” or
“API 31“.

</p>
<a class="target" name="keepmessagesstable">&nbsp;</a><a class="target" name="errormessageconventions/keepmessagesstable">&nbsp;</a><a class="target" name="toc12.6">&nbsp;</a><h2>Keep Messages Stable</h2>
<p>


Once you have written an error message, think twice before changing it. This is
again because of the baseline mechanism mentioned above. If users have already
run lint with your previous error message, and that message has been written
into baselines, changing the error message will cause the baseline to no longer
match, which means this will show up as a new error for users.

</p><p>

If you <strong class="asterisk">have</strong> to change an error message because it's misleading, then of
course, do that — but avoid it if there isn't a strong reason to do so.

</p><p>

There <em class="asterisk">are</em> some edits you can make to the error message which the baseline
matcher will handle:

</p><p>

</p><ul>
<li class="asterisk">Adding a suffix
</li>
<li class="asterisk">Adding a suffix which also changes the final punctuation; e.g. changing
  ”Hello.“ to ”Hello, world!“ is compatible.
</li>
<li class="asterisk">Adding a prefix</li></ul>

<p></p>
<a class="target" name="examples">&nbsp;</a><a class="target" name="errormessageconventions/examples">&nbsp;</a><a class="target" name="toc12.7">&nbsp;</a><h2>Examples</h2>
<p>


Here are some examples from lint's built-in checks. Note that these are not
chosen as great examples of clear error messages; most of these were written
by engineers without review from a tech writer. But for better or worse they
reflect the ”tone“ of the built-in lint checks today. (These were derived from
lint's unit test suite, which explains silly symbols like <code>test.pkg</code> in the
error messages.)

</p><p>

Note that the [Id] block is not part of the error message; it's included here
to help cross reference the messages with the corresponding lint check.

</p><p>

</p><ul>
<li class="asterisk">[AccidentalOctal] The leading 0 turns this number into octal which is probably not what was intended (interpreted as 8)
</li>
<li class="asterisk">[AdapterViewChildren] A list/grid should have no children declared in XML
</li>
<li class="asterisk">[AddJavascriptInterface] `WebView.addJavascriptInterface` should not be called with minSdkVersion &lt; 17 for security reasons: JavaScript can use reflection to manipulate application
</li>
<li class="asterisk">[AllCaps] Using `textAllCaps` with a string (`has_markup`) that contains markup; the markup will be dropped by the caps conversion
</li>
<li class="asterisk">[AllowAllHostnameVerifier] Using the `AllowAllHostnameVerifier` HostnameVerifier is unsafe because it always returns true, which could cause insecure network traffic due to trusting TLS/SSL server certificates for wrong hostnames
</li>
<li class="asterisk">[AlwaysShowAction] Prefer `ifRoom` instead of `always`
</li>
<li class="asterisk">[AndroidGradlePluginVersion] A newer version of com.android.tools.build:gradle than 3.3.0-alpha04 is available: 3.3.2
</li>
<li class="asterisk">[AnimatorKeep] This method is accessed from an ObjectAnimator so it should be annotated with `@Keep` to ensure that it is not discarded or renamed in release builds
</li>
<li class="asterisk">[AnnotateVersionCheck] This field should be annotated with `ChecksSdkIntAtLeast(api=Build.VERSION_CODES.LOLLIPOP)`
</li>
<li class="asterisk">[AnnotationProcessorOnCompilePath] Add annotation processor to processor path using `annotationProcessor` instead of `api`
</li>
<li class="asterisk">[AppBundleLocaleChanges] Found dynamic locale changes, but did not find corresponding Play Core library calls for downloading languages and splitting by language is not disabled in the `bundle` configuration
</li>
<li class="asterisk">[AppCompatCustomView] This custom view should extend `android.support.v7.widget.AppCompatButton` instead
</li>
<li class="asterisk">[AppCompatMethod] Should use `getSupportActionBar` instead of `getActionBar` name
</li>
<li class="asterisk">[AppCompatResource] Should use `android:showAsAction` when not using the appcompat library
</li>
<li class="asterisk">[AppIndexingService] `UPDATE_INDEX` is configured as a service in your app, which is no longer supported for the API level you're targeting. Use a `BroadcastReceiver` instead.
</li>
<li class="asterisk">[AppLinkUrlError] Missing URL for the intent filter
</li>
<li class="asterisk">[AppLinksAutoVerify] This host does not support app links to your app. Checks the Digital Asset Links JSON file: <a href="http://example.com/.well-known/assetlinks.json" class="url">http://example.com/.well-known/assetlinks.json</a>
</li>
<li class="asterisk">[ApplySharedPref] Consider using `apply()` instead; `commit` writes its data to persistent storage immediately, whereas `apply` will handle it in the background
</li>
<li class="asterisk">[AssertionSideEffect] Assertion condition has a side effect: i++
</li>
<li class="asterisk">[Autofill] Missing `autofillHints` attribute
</li>
<li class="asterisk">[BackButton] Back buttons are not standard on Android; see design guide's navigation section
</li>
<li class="asterisk">[BadHostnameVerifier] `verify` always returns `true`, which could cause insecure network traffic due to trusting TLS/SSL server certificates for wrong hostnames
</li>
<li class="asterisk">[BatteryLife] Use of `com.android.camera.NEW_PICTURE` is deprecated for all apps starting with the N release independent of the target SDK. Apps should not rely on these broadcasts and instead use `WorkManager`
</li>
<li class="asterisk">[BidiSpoofing] Comment contains misleading Unicode bidirectional text
</li>
<li class="asterisk">[BlockedPrivateApi] Reflective access to NETWORK_TYPES is forbidden when targeting API 28 and above
</li>
<li class="asterisk">[BottomAppBar] This `BottomAppBar` must be wrapped in a `CoordinatorLayout` (`android.support.design.widget.CoordinatorLayout`)
</li>
<li class="asterisk">[BrokenIterator] `Vector#listIterator` was broken in API 24 and 25; it can return `hasNext()=false` before the last element. Consider switching to `ArrayList` with synchronization if you need it.
</li>
<li class="asterisk">[ButtonCase] @android:string/yes actually returns ”OK“, not ”Yes“; use @android:string/ok instead or create a local string resource for Yes
</li>
<li class="asterisk">[ButtonOrder] OK button should be on the right (was ”OK | Cancel“, should be ”Cancel | OK“)
</li>
<li class="asterisk">[ButtonStyle] Buttons in button bars should be borderless; use `style=”?android:attr/buttonBarButtonStyle”` (and `?android:attr/buttonBarStyle` on the parent)
</li>
<li class="asterisk">[ByteOrderMark] Found byte-order-mark in the middle of a file
</li>
<li class="asterisk">[CanvasSize] Calling `Canvas.getWidth()` is usually wrong; you should be calling `getWidth()` instead
</li>
<li class="asterisk">[CheckResult] The result of `double` is not used
</li>
<li class="asterisk">[ClickableViewAccessibility] Custom view ``NoPerformClick`` has `setOnTouchListener` called on it but does not override `performClick`
</li>
<li class="asterisk">[CoarseFineLocation] If you need access to FINE location, you must request both `ACCESS_FINE_LOCATION` and `ACCESS_COARSE_LOCATION`
</li>
<li class="asterisk">[CommitPrefEdits] `SharedPreferences.edit()` without a corresponding `commit()` or `apply()` call
</li>
<li class="asterisk">[CommitTransaction] This transaction should be completed with a `commit()` call
</li>
<li class="asterisk">[ConstantLocale] Assigning `Locale.getDefault()` to a final static field is suspicious; this code will not work correctly if the user changes locale while the app is running
</li>
<li class="asterisk">[ContentDescription] Missing `contentDescription` attribute on image
</li>
<li class="asterisk">[ConvertToWebp] One or more images in this project can be converted to the WebP format which typically results in smaller file sizes, even for lossless conversion
</li>
<li class="asterisk">[CustomPermissionTypo] Did you mean `my.custom.permission.FOOBAR`?
</li>
<li class="asterisk">[CustomSplashScreen] The application should not provide its own launch screen
</li>
<li class="asterisk">[CustomViewStyleable] By convention, the custom view (`CustomView1`) and the declare-styleable (`MyDeclareStyleable`) should have the same name (various editor features rely on this convention)
</li>
<li class="asterisk">[CustomX509TrustManager] Implementing a custom `X509TrustManager` is error-prone and likely to be insecure. It is likely to disable certificate validation altogether, and is non-trivial to implement correctly without calling Android's default implementation.
</li>
<li class="asterisk">[CutPasteId] The id `R.id.duplicated` has already been looked up in this method; possible cut &amp; paste error?
</li>
<li class="asterisk">[DalvikOverride] This package private method may be unintentionally overriding `method` in `pkg1.Class1`
</li>
<li class="asterisk">[DataBindingWithoutKapt] If you plan to use data binding in a Kotlin project, you should apply the kotlin-kapt plugin.
</li>
<li class="asterisk">[DataExtractionRules] The attribute `android:allowBackup` is deprecated from Android 12 and the default allows backup
</li>
<li class="asterisk">[DefaultEncoding] This `Scanner` will use the default system encoding instead of a specific charset which is usually a mistake; add charset argument, `Scanner(..., UTF_8)`?
</li>
<li class="asterisk">[DefaultLocale] Implicitly using the default locale is a common source of bugs: Use `toUpperCase(Locale)` instead. For strings meant to be internal use `Locale.ROOT`, otherwise `Locale.getDefault()`.
</li>
<li class="asterisk">[DeletedProvider] The Crypto provider has been deleted in Android P (and was deprecated in Android N), so the code will crash
</li>
<li class="asterisk">[DeprecatedProvider] The `BC` provider is deprecated and when `targetSdkVersion` is moved to `P` this method will throw a `NoSuchAlgorithmException`. To fix this you should stop specifying a provider and use the default implementation
</li>
<li class="asterisk">[DeprecatedSinceApi] This method is deprecated as of API level 25
</li>
<li class="asterisk">[Deprecated] `AbsoluteLayout` is deprecated
</li>
<li class="asterisk">[DevModeObsolete] You no longer need a `dev` mode to enable multi-dexing during development, and this can break API version checks
</li>
<li class="asterisk">[DeviceAdmin] You must have an intent filter for action `android.app.action.DEVICE_ADMIN_ENABLED`
</li>
<li class="asterisk">[DiffUtilEquals] Suspicious equality check: Did you mean `.equals()` instead of `==` ?
</li>
<li class="asterisk">[DisableBaselineAlignment] Set `android:baselineAligned=“false”` on this element for better performance
</li>
<li class="asterisk">[DiscouragedPrivateApi] Reflective access to addAssetPath, which is not part of the public SDK and therefore likely to change in future Android releases
</li>
<li class="asterisk">[DrawAllocation] Avoid object allocations during draw/layout operations (preallocate and reuse instead)
</li>
<li class="asterisk">[DuplicateActivity] Duplicate registration for activity `com.example.helloworld.HelloWorld`
</li>
<li class="asterisk">[DuplicateDefinition] `app_name` has already been defined in this folder
</li>
<li class="asterisk">[DuplicateDivider] Replace with `android.support.v7.widget.DividerItemDecoration`?
</li>
<li class="asterisk">[DuplicateIds] Duplicate id `@+id/android_logo`, already defined earlier in this layout
</li>
<li class="asterisk">[DuplicateIncludedIds] Duplicate id @+id/button1, defined or included multiple times in layout/layout2.xml: * [layout/layout2.xml =&gt; layout/layout3.xml defines @+id/button1, layout/layout2.xml =&gt; layout/layout4.xml defines @+id/button1]
</li>
<li class="asterisk">[DuplicatePlatformClasses] `xpp3` defines classes that conflict with classes now provided by Android. Solutions include finding newer versions or alternative libraries that don't have the same problem (for example, for `httpclient` use `HttpUrlConnection` or `okhttp` instead), or repackaging the library using something like `jarjar`.
</li>
<li class="asterisk">[DuplicateStrings] Duplicate string value `HELLO`, used in `hello_caps` and `hello`. Use `android:inputType` or `android:capitalize` to treat these as the same and avoid string duplication.
</li>
<li class="asterisk">[DuplicateUsesFeature] Duplicate declaration of uses-feature `android.hardware.camera`
</li>
<li class="asterisk">[EllipsizeMaxLines] Combining `ellipsize=start` and `lines=1` can lead to crashes. Use `singleLine=true` instead.
</li>
<li class="asterisk">[EmptySuperCall] No need to call `super.someOtherMethod`; the super method is defined to be empty
</li>
<li class="asterisk">[EnforceUTF8] iso-latin-1: Not using UTF-8 as the file encoding. This can lead to subtle bugs with non-ascii characters
</li>
<li class="asterisk">[EnqueueWork] WorkContinuation `cont` not enqueued: did you forget to call `enqueue()`?</li></ul>

<p></p>
<a class="target" name="frequentlyaskedquestions">&nbsp;</a><a class="target" name="frequentlyaskedquestions">&nbsp;</a><a class="target" name="toc13">&nbsp;</a><h1>Frequently Asked Questions</h1>
<p>


This chapter contains a random collection of questions people
have asked in the past.

</p>
<a class="target" name="mydetectorcallbacksaren'tinvoked">&nbsp;</a><a class="target" name="frequentlyaskedquestions//mydetectorcallbacksaren'tinvoked">&nbsp;</a><a class="target" name="toc13.0.1">&nbsp;</a><h3>My detector callbacks aren't invoked</h3>
<p>


If you've for example implemented the Detector callback for visiting
method calls, <code>visitMethodCall</code>, notice how the third parameter is a
<code>PsiMethod</code>, and that it is not nullable:

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">visitMethodCall</span><span class="hljs-params">(
<span class="line"></span>        context: <span class="hljs-type">JavaContext</span>,
<span class="line"></span>        node: <span class="hljs-type">UCallExpression</span>,
<span class="line"></span>        method: <span class="hljs-type">PsiMethod</span>
<span class="line"></span>    )</span></span> {</code></pre><p>

This passes in the method that has been called. When lint is visiting
the AST, it will resolve calls, and if the called method cannot be
resolved, the callback won't be called.

</p><p>

This happens when the classpath that lint has been configured with does
not contain everything needed. When lint is running from Gradle, this
shouldn't happen; the build system should have a complete classpath and
pass it to Lint (or the build wouldn't have succeeded in the first
place).

</p><p>

This usually comes up in unit tests for lint, where you've added a test
case which is referencing some API for some library, but the library
itself isn't part of the test. The solution for this is to create stubs
for the part of the API you care about. This is discussed in more
detail in the <a href="#lintcheckunittesting">unit testing</a> chapter.

</p>
<a class="target" name="mylintcheckworksfromtheunittestbutnotintheide">&nbsp;</a><a class="target" name="frequentlyaskedquestions//mylintcheckworksfromtheunittestbutnotintheide">&nbsp;</a><a class="target" name="toc13.0.2">&nbsp;</a><h3>My lint check works from the unit test but not in the IDE</h3>
<p>


There are several things to check if you have a lint check which
works correctly from your unit test but not in the IDE.

</p><p>

</p><ol start="1">
<li class="number">First check that the lint jar is packaged correctly; use <code>jar tvf
   lint.jar</code> to look at the jar file to make sure it contains the
   service loader registration of your issue registry, and <code>javap
   -classpath lint.jar com.example.YourIssueRegistry</code> to inspect your
   issue registry.

<p></p><p>

</p></li>
<li class="number">If that's correct, the next thing to check is that lint is actually
   loading your issue registry. First look in the IDE log (from the
   Help menu) to make sure there aren't log messages from lint
   explaining why it can't load the registry, for example because it
   does not specify a valid applicable API range.

<p></p><p>

</p></li>
<li class="number">If there's no relevant warning in the log, try setting the
   <code>$ANDROID_LINT_JARS</code> environment variable to point directly to your
   lint jar file and restart Studio to make sure that that works.

<p></p><p>

</p></li>
<li class="number">Next, try running <strong class="asterisk">Analyze | Inspect Code...</strong>. This runs lint on
   the whole project. If that works, then the issue is that your lint
   check isn't eligible to run “on the fly”; the reason for this is
   that your implementation scope registers more than one scope, which
   says that your lint check can only run if lint gets to look at both
   types of files, and in the editor, only the current file is analyzed
   by lint. However, you can still make the check work on the fly by
   specifying additional analysis scopes; see the API guide for more
   information about this.</li></ol>

<p></p>
<a class="target" name="visitannotationusageisn'tcalledforannotations">&nbsp;</a><a class="target" name="frequentlyaskedquestions//visitannotationusageisn'tcalledforannotations">&nbsp;</a><a class="target" name="toc13.0.3">&nbsp;</a><h3><code>visitAnnotationUsage</code> isn't called for annotations</h3>
<p>


If you want to just visit any annotation declarations (e.g. <code>@Foo</code> on
method <code>foo</code>), don't use the <code>applicableAnnotations</code> and
<code>visitAnnotationUsage</code> machinery. The purpose of that facility is to
look at <em class="asterisk">elements</em> that are being combined with annotated elements,
such as a method call to a method whose return value has been
annotated, or an argument to a method a method parameter that has been
annotated, or assigning an assigned value to an annotated variable, etc.

</p><p>

If you just want to look at annotations, use <code>getApplicableUastTypes</code>
with <code>UAnnotation::class.java</code>, and a <code>UElementHandler</code> which overrides
<code>visitAnnotation</code>.

</p>
<a class="target" name="howdoicheckifauastorpsielementisforjavaorkotlin?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoicheckifauastorpsielementisforjavaorkotlin?">&nbsp;</a><a class="target" name="toc13.0.4">&nbsp;</a><h3>How do I check if a UAST or PSI element is for Java or Kotlin?</h3>
<p>


To check whether an element is in Java or Kotlin, call one
of the package level methods in the detector API (and from
Java, you can access them as utility methods on the “Lint”
class) :

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">package</span> com.android.tools.lint.detector.api
<span class="line"></span>
<span class="line"></span><span class="hljs-comment">/** Returns true if the given element is written in Java. */</span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isJava</span><span class="hljs-params">(element: <span class="hljs-type">PsiElement</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span> }
<span class="line"></span>
<span class="line"></span><span class="hljs-comment">/** Returns true if the given language is Kotlin. */</span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isKotlin</span><span class="hljs-params">(language: <span class="hljs-type">Language</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span> }
<span class="line"></span>
<span class="line"></span><span class="hljs-comment">/** Returns true if the given language is Java. */</span>
<span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isJava</span><span class="hljs-params">(language: <span class="hljs-type">Language</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span> }</code></pre><p>

If you have a <code>UElement</code> and need a <code>PsiElement</code> for the above method,
see the next question.

</p>
<a class="target" name="whatifineedapsielementandihaveauelement?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//whatifineedapsielementandihaveauelement?">&nbsp;</a><a class="target" name="toc13.0.5">&nbsp;</a><h3>What if I need a <code>PsiElement</code> and I have a <code>UElement</code> ?</h3>
<p>


If you have a <code>UElement</code>, you can get the underlying source PSI element
by calling <code>element.sourcePsi</code>.

</p>
<a class="target" name="howdoigettheumethodforapsimethod?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoigettheumethodforapsimethod?">&nbsp;</a><a class="target" name="toc13.0.6">&nbsp;</a><h3>How do I get the <code>UMethod</code> for a <code>PsiMethod</code> ?</h3>
<p>


Call <code>psiMethod.toUElementOfType&lt;umethod&gt;()</code>. Note that this may return
null if UAST cannot find valid Java or Kotlin source code for the
method.

</p><p>

For <code>PsiField</code> and <code>PsiClass</code> instances use the equivalent
<code>toUElementOfType</code> type arguments.

</p>
<a class="target" name="howdogetajavaevaluator?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdogetajavaevaluator?">&nbsp;</a><a class="target" name="toc13.0.7">&nbsp;</a><h3>How do get a <code>JavaEvaluator</code> ?</h3>
<p>


The <code>Context</code> passed into most of the <code>Detector</code> callback methods
relevant to Kotlin and Java analysis is of type <code>JavaContext</code>, and it
has a public <code>evaluator</code> property which provides a <code>JavaEvaluator</code> you
can use in your analysis.

</p><p>

If you need one outside of that scenario (this is not common) you can
construct one directly by instantiating a <code>DefaultJavaEvaluator</code>; the
constructor parameters are nullable, and are only needed for a couple
of operations on the evaluator.

</p>
<a class="target" name="howdoicheckwhetheranelementisinternal?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoicheckwhetheranelementisinternal?">&nbsp;</a><a class="target" name="toc13.0.8">&nbsp;</a><h3>How do I check whether an element is internal?</h3>
<p>


First get a <code>JavaEvaluator</code> as explained above, then call
this evaluator method:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInternal</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></code></pre><p>

(Note that a <code>PsiModifierListOwner</code> is an interface which includes
<code>PsiMethod</code>, <code>PsiClass</code>, <code>PsiField</code>, <code>PsiMember</code>, <code>PsiVariable</code>, etc.)

</p>
<a class="target" name="iselementinline,sealed,operator,infix,suspend,data?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//iselementinline,sealed,operator,infix,suspend,data?">&nbsp;</a><a class="target" name="toc13.0.9">&nbsp;</a><h3>Is element inline, sealed, operator, infix, suspend, data?</h3>
<p>


Get the <code>JavaEvaluator</code> as explained above, and then call one of these
evaluator method:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isData</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span>
<span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInline</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span>
<span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isLateInit</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span>
<span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isSealed</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span>
<span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span>
<span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInfix</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span>
<span class="line"></span><span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isSuspend</span><span class="hljs-params">(owner: <span class="hljs-type">PsiModifierListOwner</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span></code></pre>
<a class="target" name="howdoilookupaclassifihaveitsfullyqualifiedname?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoilookupaclassifihaveitsfullyqualifiedname?">&nbsp;</a><a class="target" name="toc13.0.10">&nbsp;</a><h3>How do I look up a class if I have its fully qualified name?</h3>
<p>


Get the <code>JavaEvaluator</code> as explained above, then call
<code>evaluator.findClass(qualifiedName: String)</code>. Note that the result is
nullable.

</p>
<a class="target" name="howdoilookupaclassifihaveapsitype?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoilookupaclassifihaveapsitype?">&nbsp;</a><a class="target" name="toc13.0.11">&nbsp;</a><h3>How do I look up a class if I have a PsiType?</h3>
<p>


Get the <code>JavaEvaluator</code> as explained above, then call
<code>evaluator.getTypeClass</code>. To go from a class to its type,
use <code>getClassType</code>.

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getClassType</span><span class="hljs-params">(psiClass: <span class="hljs-type">PsiClass</span>?)</span></span>: PsiClassType?
<span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getTypeClass</span><span class="hljs-params">(psiType: <span class="hljs-type">PsiType</span>?)</span></span>: PsiClass?</code></pre>
<a class="target" name="howdoilookuphierarhcyannotationsforanelement?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoilookuphierarhcyannotationsforanelement?">&nbsp;</a><a class="target" name="toc13.0.12">&nbsp;</a><h3>How do I look up hierarhcy annotations for an element?</h3>
<p>


You can directly look up annotations via the modified list
of PsiElement or the annotations for a <code>UAnnotated</code> element,
but if you want to search the inheritance hierarchy for
annotations (e.g. if a method is overriding another, get
any annotations specified on super implementations), use
one of these two evaluator methods:

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAllAnnotations</span><span class="hljs-params">(
<span class="line"></span>        owner: <span class="hljs-type">UAnnotated</span>,
<span class="line"></span>        inHierarchy: <span class="hljs-type">Boolean</span>
<span class="line"></span>    )</span></span>: List&lt;uannotation&gt;
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAllAnnotations</span><span class="hljs-params">(
<span class="line"></span>        owner: <span class="hljs-type">PsiModifierListOwner</span>,
<span class="line"></span>        inHierarchy: <span class="hljs-type">Boolean</span>
<span class="line"></span>    )</span></span>: Array&lt;psiannotation&gt;</code></pre>
<a class="target" name="howdoilookupifaclassisasubclassofanother?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoilookupifaclassisasubclassofanother?">&nbsp;</a><a class="target" name="toc13.0.13">&nbsp;</a><h3>How do I look up if a class is a subclass of another?</h3>
<p>


To see if a method is a direct member of a particular
named class, use the following method in <code>JavaEvaluator</code>:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isMemberInClass</span><span class="hljs-params">(member: <span class="hljs-type">PsiMember</span>?, className: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> { }</code></pre><p>

To see if a method is a member in any <em class="asterisk">subclass</em> of a named class, use

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isMemberInSubClassOf</span><span class="hljs-params">(
<span class="line"></span>        member: <span class="hljs-type">PsiMember</span>,
<span class="line"></span>        className: <span class="hljs-type">String</span>,
<span class="line"></span>        strict: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>
<span class="line"></span>    )</span></span>: <span class="hljs-built_in">Boolean</span> { <span class="hljs-comment">/* ... */</span> }
<span class="line"></span></code></pre><p>

Here, use <code>strict = true</code> if you don't want to include members in the
named class itself as a match.

</p><p>

To see if a class extends another or implements an interface, use one
of these methods. Again, <code>strict</code> controls whether we include the super
class or super interface itself as a match.

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">extendsClass</span><span class="hljs-params">(
<span class="line"></span>        cls: <span class="hljs-type">PsiClass</span>?,
<span class="line"></span>        className: <span class="hljs-type">String</span>,
<span class="line"></span>        strict: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>
<span class="line"></span>    )</span></span>: <span class="hljs-built_in">Boolean</span>
<span class="line"></span>
<span class="line"></span>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">implementsInterface</span><span class="hljs-params">(
<span class="line"></span>        cls: <span class="hljs-type">PsiClass</span>,
<span class="line"></span>        interfaceName: <span class="hljs-type">String</span>,
<span class="line"></span>        strict: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>
<span class="line"></span>    )</span></span>: <span class="hljs-built_in">Boolean</span></code></pre>
<a class="target" name="howdoiknowwhichparameteracallargumentcorrespondsto?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoiknowwhichparameteracallargumentcorrespondsto?">&nbsp;</a><a class="target" name="toc13.0.14">&nbsp;</a><h3>How do I know which parameter a call argument corresponds to?</h3>
<p>


In Java, matching up the arguments in a call with the parameters in the
called method is easy: the first argument corresponds to the first
parameter, the second argument corresponds to the second parameter and
so on. If there are more arguments than parameters, the last arguments
are all vararg arguments to the last parameter.

</p><p>

In Kotlin, it's much more complicated. With named parameters, but
arguments can appear in any order, and with default parameters, only
some of them may be specified. And if it's an extension method, the
first argument passed to a <code>PsiMethod</code> is actually the instance itself.

</p><p>

Lint has a utility method to help with this on the <code>JavaEvaluator</code>:

</p><pre class="listing tilde"><code><span class="line"></span>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">computeArgumentMapping</span><span class="hljs-params">(
<span class="line"></span>        call: <span class="hljs-type">UCallExpression</span>,
<span class="line"></span>        method: <span class="hljs-type">PsiMethod</span>
<span class="line"></span>    )</span></span>: Map&lt;uexpression, psiparameter=<span class="hljs-string">""</span>&gt; { <span class="hljs-comment">/* ... */</span></code></pre><p>

This returns a map from UAST expressions (each argument to a UAST call
is a <code>UExpression</code>, and these are the <code>valueArguments</code> property on the
<code>UCallExpression</code>) to each corresponding <code>PsiParameter</code> on the
<code>PsiMethod</code> that the method calls.

</p>
<a class="target" name="howcanmylintcheckstargettwodifferentversionsoflint?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howcanmylintcheckstargettwodifferentversionsoflint?">&nbsp;</a><a class="target" name="toc13.0.15">&nbsp;</a><h3>How can my lint checks target two different versions of lint?</h3>
<p>


If you need to ship different versions of your lint checks to target
different versions of lint (because perhaps you need to work both with
an older version of lint, and a newer version that has a different
API), the way to do this (as of Lint 7.0) is to use the <code>maxApi</code>
property on the <code>IssueRegistry</code>. In the service loader registration
(<code>META-INF/services</code>), register <em class="asterisk">two</em> issue registries; one for each
implementation, and mark the older one with the right <code>minApi</code> to
<code>maxApi</code> range, and the newer one with <code>minApi</code> following the previous
registry's <code>maxApi</code>. (Both <code>minApi</code> and <code>maxApi</code> are inclusive). When
lint loads the issue registries it will ignore registries with a range
outside of the current API level.

</p>
<a class="target" name="canimakemylintcheck%E2%80%9Cnotsuppressible?%E2%80%9D">&nbsp;</a><a class="target" name="frequentlyaskedquestions//canimakemylintcheck%E2%80%9Cnotsuppressible?%E2%80%9D">&nbsp;</a><a class="target" name="toc13.0.16">&nbsp;</a><h3>Can I make my lint check “not suppressible?”</h3>
<p>


In some (hopefully rare) cases, you may want your lint checks to not be
suppressible using the normal mechanisms — suppress annotations,
comments, lint.xml files, baselines, and so on. The usecase for this is
typically strict company guidelines around compliance or security and
you want to remove the easy possibility of just silencing the check.

</p><p>

This is possible as part of the issue registration. After creating your
<code>Issue</code>, set the <code>suppressNames</code> property to an <strong class="asterisk">empty</strong> collection.

</p>
<a class="target" name="whyareoverloadedoperatorsnothandled?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//whyareoverloadedoperatorsnothandled?">&nbsp;</a><a class="target" name="toc13.0.17">&nbsp;</a><h3>Why are overloaded operators not handled?</h3>
<p>


Kotlin supports overloaded operators, but these are not handled as
calls in the AST - instead, an implicit <code>get</code> or <code>set</code> method from an
array access will show up as a <code>UArrayAccessExpression</code>. Lint has
specific support to help handling these scenarios; see the “Implicit
Calls” section in the <a href="#writingalintcheck:basics"></a><a href="#basics">basics</a> chapter.

</p>
<a class="target" name="howdoicheckoutthecurrentlintsourcecode?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//howdoicheckoutthecurrentlintsourcecode?">&nbsp;</a><a class="target" name="toc13.0.18">&nbsp;</a><h3>How do I check out the current lint source code?</h3>
<pre class="listing backtick"><code><span class="line"></span><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> --branch=mirror-goog-studio-main --single-branch \
<span class="line"></span>   https://android.googlesource.com/platform/tools/base</span>
<span class="line"></span>Cloning into 'base'...
<span class="line"></span>remote: Total 648820 (delta 325442), reused 635137 (delta 325442)
<span class="line"></span>Receiving objects: 100% (648820/648820), 1.26 GiB | 15.52 MiB/s, done.
<span class="line"></span>Resolving deltas: 100% (325442/325442), done.
<span class="line"></span>Updating files: 100% (14416/14416), done.
<span class="line"></span><span class="hljs-meta">
<span class="line"></span>$</span><span class="bash"> du -sh base</span>
<span class="line"></span>1.8G    base
<span class="line"></span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> base/lint</span>
<span class="line"></span><span class="hljs-meta">$</span><span class="bash"> ls</span>
<span class="line"></span>.editorconfig           BUILD                   build.gradle            libs/
<span class="line"></span>.gitignore              MODULE_LICENSE_APACHE2  cli/
<span class="line"></span><span class="hljs-meta">$</span><span class="bash"> ls libs/</span>
<span class="line"></span>intellij-core/   kotlin-compiler/ lint-api/        lint-checks/     lint-gradle/     lint-model/      lint-tests/      uast/</code></pre>
<a class="target" name="wheredoifindexamplesoflintchecks?">&nbsp;</a><a class="target" name="frequentlyaskedquestions//wheredoifindexamplesoflintchecks?">&nbsp;</a><a class="target" name="toc13.0.19">&nbsp;</a><h3>Where do I find examples of lint checks?</h3>
<p>


The built-in lint checks are a good source. Check out the source code
as shown above and look in
<code>lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/</code> or
browse sources online:
<a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/"></a><a href="https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/" class="url">https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/</a>

</p><p>



</p>
<a class="target" name="appendix:recentchanges">&nbsp;</a><a class="target" name="appendix:recentchanges">&nbsp;</a><a class="target" name="toc14">&nbsp;</a><h1>Appendix: Recent Changes</h1>
<p>

           
<strong class="asterisk">Recent Changes</strong>

</p><p>

This chapter lists recent changes to lint that affect lint check
authors: new features, API and behavior changes, and so on. For
information about user visible changes to lint, see the User
Guide.

</p><p>

<strong class="asterisk">7.4</strong>

</p><p>

</p><ul>
<li class="asterisk">Annotation detectors can now specify just an annotation name instead
  of its fully qualified name in order to match <em class="asterisk">all</em> annotations of
  that name. For example,
  <code>override fun applicableAnnotations() = listOf("Nullable")</code>
  will match both <code>androidx.annotation.Nullable</code> and
  <code>org.jetbrains.annotations.Nullable</code>. This is used by for example
  the built-in CheckResultDetector to match many new variants of the
  <code>CheckReturnValue</code> annotations, such as the ones in mockito and in
  protobuf.

<p></p><p>

</p></li>
<li class="asterisk">The new AnnotationUsageTypes IMPLICIT_CONSTRUCTOR and
  IMPLICIT_CONSTRUCTOR_CALL let detectors analyzing annotations get callbacks
  when an annotated no-args constructor is invoked explicitly from a subclass
  which has an implicit constructor, or from an implicit super call in an
  explicit sub constructor. These are not included by default, so override
  isApplicableAnnotationUsage to opt in.</li></ul>

<p></p><p>

<strong class="asterisk">7.3</strong>

</p><p>

</p><ul>
<li class="asterisk">The new AnnotationUsageType.DEFINTION now lets detectors easily check
  occurrences of an annotation in the source code. Previously,
  <code>visitAnnotationUsage</code> would only check annotated elements, not the
  annotations themselves, and to check an annotation you'd need to
  create an <code>UElementHandler</code>. See the docs for the new enum constant
  for more details, and for an example of a detector that was converted
  from a handler to using this, see <code>IgnoreWithoutReasonDetector</code>.

<p></p><p>

</p></li>
<li class="asterisk">Lint unit tests can now include <code>package-info.java</code> files with
  annotations in source form (until now, this only worked if the files
  were provided as binary class files)

<p></p><p>

</p></li>
<li class="asterisk">String replacement quickfixes can now be configured with a list of
  imports to be performed when the fix is applied. This can be used to
  for example import Kotlin extension functions needed by the
  replacement string. (You should not use this for normal imports;
  instead, the replacement string should use fully qualified names
  everywhere along with the <code>shortenNames</code> property on the fix, and
  then lint will rewrite and import all symbols that can be done
  without conflicts.)</li></ul>

<p></p><p>

<strong class="asterisk">7.2</strong>

</p><p>

</p><ul>
<li class="asterisk">There is now a way to register “options” for detectors. These are
  simple key/value pairs of type string, integer, boolean or file, and
  users can configure values in <code>lint.xml</code> files. This has all been
  possible since 4.2, but in 7.2 there is now a way to register the
  names, descriptions and default values of these options, and these
  will show up in issue explanations, HTML reports, and so on. (In the
  future we can use this to create an Options UI in the IDE, allow
  configuration via Gradle DSL, and so on.)

<p></p><p>

  For more, see the <a href="#options"></a><a href="#options">options</a> chapter.

</p><p>

</p></li>
<li class="asterisk">A new test mode, <code>TestMode.CDATA</code>, checks that tests correctly handle
  XML CDATA sections in <code>&lt;string&gt;</code> declarations.</li></ul>

<p></p><p>

<strong class="asterisk">7.1</strong>

</p><p>

</p><ul>
<li class="asterisk">Lint now bundles IntelliJ version 2021.1 and Kotlin compiler version 1.5.30.
  You may see minor API changes in these dependencies. For example,
  the Kotlin UAST class <code>KotlinUMethod</code> changed packages from
  <code>org.jetbrains.uast.kotlin.declarations</code> to <code>org.jetbrains.uast.kotlin</code>.

<p></p><p>

</p></li>
<li class="asterisk">The default behaviour of ResourceXmlDetector will change.
  It will skip res/raw folder and you have to override appliesTo method
  if you want your Lint checks to run there.

<p></p><p>

</p></li>
<li class="asterisk">The computation of checksums for binary test files (e.g. <code>compiled</code>
  and <code>bytecode</code>) unfortunately had to change; the old mechamism was
  not stable. This means that after updating some of the test files
  will show as having wrong checksums (e.g. “The checksum does not
  match for test.kt; expected 0×26e3997d but was 0xb76b5946”). In these
  cases, just drop in the new checksum.

<p></p><p>

</p></li>
<li class="asterisk">Source-modifying test modes. Lint's testing library now runs your
  unit tests through a number of additional paces: it will try
  inserting unnecessary parentheses, it will try replacing all
  imported symbols with fully qualified names, it will try adding
  argument names and reordering arguments to Kotlin calls, etc, and
  making sure the same results are reported. More information about
  this is available in <a href="#testmodes"></a><a href="#testmodes" class="url">api-guide/test-modes.md.html</a>.

<p></p><p>

</p></li>
<li class="asterisk">The support for Kotlin's overloaded operators is significantly
  improved. While these are method calls, in the AST they do not show
  up as <code>UCallExpressions</code> (instead, you'll find them as
  <code>UBinaryExpression</code>, <code>UPrefixExpression</code>, <code>UArrayAccessExpression</code>
  and so on), which meant various call-specific checks ignored them.

<p></p><p>

  Now, in addition to the built-in checks all applying to these
  implicit calls as well, lint can present these expressions as call
  expressions. This means that the <code>getApplicableMethodNames</code> machinery
  for call callbacks will now also work for overloaded functions, and
  code which is iterating through calls can use the new
  <code>UastCallVisitor</code> (or directly construct <code>UImplicitCallExpression</code>
  wrappers) to simplify processing of all these types of calls.

</p><p>

  Finally, lint now provides a way to resolve operators for array
  access expressions (which is missing in UAST) via the
  UArrayAccessExpression.resolveOperator extension method, which is
  also used by the above machinery.

</p><p>

</p></li>
<li class="asterisk">The annotation support (where a detector callback is invoked when
  elements are combined with annotated elements) has been significantly
  reworked (and the detector API changed). It now supports visiting
  the following additional scenarios:

<p></p><p>

</p><ul>
  <li class="asterisk">Fields in annotated classes and packages
</li>
  <li class="asterisk">Fields and methods in annotated outerclasses
</li>
  <li class="asterisk">Class and object literals
</li>
  <li class="asterisk">Overridden methods
</li>
  <li class="asterisk">File level annotations (from Kotlin)

<p></p><p>

</p></li></ul>
</li><li class="number">It also offers better control for handling scopes — providing all
  relevant annotations in the hierarchy at the same time such that a
  lint check for example can easily determine whether an outer
  annotation like <code>@Immutable</code> is canceled by a closer @Mutable`
  annotation.

<p></p><p>

  There are some new annotation usage type enum constants which let
  your lint checks treat these differently. For example, the lint check
  which makes sure that calls to methods annotated with <code>@CheckResult</code>
  started flagging overrides of these methods. The fix was to add the
  following override to the <code>CheckResultDetector</code>:

</p><pre class="listing tilde"><code><span class="line"></span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isApplicableAnnotationUsage</span><span class="hljs-params">(type: <span class="hljs-type">AnnotationUsageType</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
<span class="line"></span>  <span class="hljs-keyword">return</span> type != AnnotationUsageType.METHOD_OVERRIDE &amp;&amp;
<span class="line"></span>      <span class="hljs-keyword">super</span>.isApplicableAnnotationUsage(type)
<span class="line"></span>}</code></pre><p>

  (Using this new API constant will make your lint check only work with
  the new version of lint. An alternative fix is to check that the
  <code>usage</code> parameter is not a <code>UMethod</code>.)

</p><p>

  For more, see the <a href="#annotations">new documentation</a> for
  how to handle annotations from detectors.

</p><p>

</p></li>
<li class="asterisk">The lint testing library now contains a new test file type, <code>rClass</code>,
  which lets you easily construct Android <code>R</code> classes with resource
  declarations (which are needed in tests that reference the R fields
  to ensure that symbol resolution works.)

<p></p><p>

</p></li>
<li class="asterisk">When you call <code>context.getLocation(UMethod)</code>, lint will now default
  this method to be equivalent to <code>context.getNameLocation(UMethod)</code>
  instead, which will highlight the method name. This might surface
  itself as unit test failures where the location range moves from a
  single <code>^</code> into a <code>~~~~~</code> range. This is because the location printer
  uses <code>^</code> to just indicate the start offset when a range is multi-line.</li></ul>

<p></p><p>

<strong class="asterisk">7.0</strong>

</p><p>

</p><ul>
<li class="asterisk">The API level has bumped to 10.

<p></p><p>

</p></li>
<li class="asterisk">Partial analysis. Lint's architecture has changed to support better
  scalability across large projects, where module results can be
  cached, etc. See the api-guide's dedicated chapter for more details.
  It is enabled by default starting in AGP 7.0.0-alpha13.

<p></p><p>

</p></li>
<li class="asterisk">Issue registration now takes an optional <code>Vendor</code> property, where you
  can specify information about which company or team provided this
  lint check, which library it's associated with, contact information,
  and so on. This will make it easier for users to figure out where to
  send feedback or requests for 3rd party lint checks.

<p></p><p>

</p></li>
<li class="asterisk">Bytecode verification: Instead of warning about 3rd party lint checks
  being obsolete because they were not compiled against the latest Lint
  API, lint now run its own bytecode verification against the lint jar
  and will silently accept older (and newer!) lint checks if they do
  not reference APIs that are not available.

<p></p><p>

</p></li>
<li class="asterisk">Android Lint checks can now always access the resource repository for
  random access to resources, instead of having to gather them in batch
  mode. (Previously this was only available when lint checks were
  running in the IDE.)

<p></p><p>

</p></li>
<li class="asterisk">The lint unit testing library now provides a <code>TestMode</code> concept. You
  can define setup and teardown methods, and lint will run unit tests
  repeatedly for each test mode. There are a number of built-in test
  modes already enabled; for example, all lint tests will run both in
  global analysis mode and in partial analysis mode, and the results
  compared to ensure they are the same.

<p></p><p>

</p></li>
<li class="asterisk">Lint unit tests now include source contents for secondary locations
  too. If the test fails, lint will retry without secondary source
  locations and not report an error; this preserves backwards
  compatibility.

<p></p><p>

</p></li>
<li class="asterisk">There's a new <code>Incident</code> class which is used to hold information to
  be reported to the user. Previously, there were a number of
  overloaded methods to report issues, taking locations, error
  messages, quick fixes, and so on. Each time we added another one we'd
  have to add another overload. Now, you instead just report incidents.
  This is critical to the new partial analysis architecture but is also
  required if you for example want to override severities per incident
  as described above.

<p></p><p>

</p></li>
<li class="asterisk">Lint checks can now vary the severity on a per incident basis by
  calling overrideSeverity on the incidents. This means that there is
  no longer a need to create separate issues for flavors of the same
  underlying problem with slightly different expectations around
  warnings or errors.

<p></p><p>

</p></li>
<li class="asterisk">There are additional modifier lookup methods for Kotlin modifiers
  on <code>JavaEvaluator</code>, like <code>isReified()</code>, <code>isCompanion()</code>,
  <code>isTailRec()</code>, and so on.

<p></p><p>

</p></li>
<li class="asterisk">API documentation is now available.

<p></p><p>

</p></li>
<li class="asterisk">UAST for Kotlin is now based on Kotlin 1.5.

<p></p><p>

</p></li>
<li class="asterisk">Certain Kotlin PSI elements have new implementations known as <em class="underscore">ultra
  light classes</em>. Ultra light classes improve performance by answering
  PSI queries “directly from source” rather than delegating to the
  Kotlin compiler backend. You may see ultra light classes when
  accessing the <code>UElement.javaPsi</code> property of a Kotlin UAST element.
  They can also appear when resolving references. For example,
  resolving a Kotlin field reference to its declaration may result in
  an instance of <code>KtUltraLightFieldForSourceDeclaration</code>. As a
  reminder, Kotlin light classes represent the “Java view” of an
  underlying Kotlin PSI element. To access the underlying Kotlin PSI
  element you should use <code>UElement.sourcePsi</code> (preferred) or otherwise
  the extension property <code>PsiElement.unwrapped</code> (declared in
  <code>org.jetbrains.kotlin.asJava</code>).

<p></p><p>

</p></li>
<li class="asterisk">There is a new bug where calling <code>getNameIdentifier()</code> on Kotlin
  fields may return <code>null</code>
  (<a href="https://youtrack.jetbrains.com/issue/KT-45629">KT-45629</a>).
  As a workaround you can use <code>JavaContext.findNameElement()</code> instead.

<p></p><p>

</p></li>
<li class="asterisk">Kotlin references to Java methods now trigger both the
  <code>visitMethodCall()</code> callback <em class="underscore">and</em> the <code>visitReference()</code> callback.
  Previously only <code>visitMethodCall()</code> was triggered.

<p></p><p>

</p></li>
<li class="asterisk">Quickfixes can now create and delete new files; see
  <code>LintFix#newFile</code> and <code>LintFix#deleteFile</code>..

<p></p><p>

</p></li>
<li class="asterisk">For quickfixes, the <code>independent</code> property had inverted logic;
  this has now been reversed to follow the meaning of the name.

<p></p><p>

</p></li>
<li class="asterisk">The location range returned when looking up the location for a call
  will now include arguments outside of the call range itself. This is
  important when the code is using Kotlin's assignment syntax for
  calling methods as if they are properties.

<p></p><p>

</p></li>
<li class="asterisk">Lint's unit testing framework now checks all <code>import</code> statements in
  test files to make sure that they resolve. This will help catch
  common bugs and misunderstandings where tests reference frameworks
  that aren't available to lint in the unit test, and where you need to
  either add the library or more commonly just add some simple stubs.
  If the import statements do not matter to the test, you can just mark
  the test as allowing compilation errors, using
  <code>.allowCompilationErrors()</code> on the <code>lint()</code> task.

<p></p><p>

</p></li>
<li class="asterisk">The <a href="#dataflowanalyzer">data flow analyzer</a> has been
  significantly improved, particularly around Kotlin scoping functions.</li></ul>

<p></p><p>



</p>
<a class="target" name="appendix:environmentvariablesandsystemproperties">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties">&nbsp;</a><a class="target" name="toc15">&nbsp;</a><h1>Appendix: Environment Variables and System Properties</h1>
<p>


This chapter lists the various environment variables and system
properties that Lint will look at. None of these are really intended to
be used or guaranteed to be supported in the future, but documenting
what they are seems useful.

</p>
<a class="target" name="environmentvariables">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/environmentvariables">&nbsp;</a><a class="target" name="toc15.1">&nbsp;</a><h2>Environment Variables</h2>

<a class="target" name="detectorconfigurationvariables">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/environmentvariables/detectorconfigurationvariables">&nbsp;</a><a class="target" name="toc15.1.1">&nbsp;</a><h3>Detector Configuration Variables</h3>
<p>


</p><dl><dt><code>ANDROID_LINT_INCLUDE_LDPI</code></dt><dd><p>  Lint's icon checks normally ignore the <code>ldpi</code> density since it's not
  commonly used any more, but you can turn this back on with this
  environment variable set to <code>true</code>.

</p></dd><dt><code>ANDROID_LINT_MAX_VIEW_COUNT</code></dt><dd><p>  Lint's <code>TooManyViews</code> check makes sure that a single layout does not
  have more than 80 views. You can set this environment variable to a
  different number to change the limit.

</p></dd><dt><code>ANDROID_LINT_MAX_DEPTH</code></dt><dd><p>  Lint's <code>TooManyViews</code> check makes sure that a single layout does not
  have a deeper layout hierarchy than 10 levels.You can set this
  environment variable to a different number to change the limit.

</p></dd><dt><code>ANDROID_LINT_NULLNESS_IGNORE_DEPRECATED</code></dt><dd><p>  Lint's <code>UnknownNullness</code> which flags any API element which is not
  explicitly annotated with nullness annotations, normally skips
  deprecated elements. Set this environment variable to true to include
  these as well.

</p><p>

  Corresponding system property: <code>lint.nullness.ignore-deprecated</code>.

</p><p>

  Note that this setting can also be configured using a proper
  <code>lint.xml</code> setting instead; this is now listed in the documentation
  for that check.

</p></dd></dl><p></p>
<a class="target" name="lintconfigurationvariables">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/environmentvariables/lintconfigurationvariables">&nbsp;</a><a class="target" name="toc15.1.2">&nbsp;</a><h3>Lint Configuration Variables</h3>
<p>


</p><dl><dt><code>ANDROID_SDK_ROOT</code></dt><dd><p>  Locates the Android SDK root

</p></dd><dt><code>ANDROID_HOME</code></dt><dd><p>  Locates the Android SDK root, if <code>$ANDROID_SDK_ROOT</code> has not been set

</p></dd><dt><code>JAVA_HOME</code></dt><dd><p>  Locates the JDK when lint is analyzing JDK (not Android) projects

</p></dd><dt><code>LINT_XML_ROOT</code></dt><dd><p>  Normally the search for <code>lint.xml</code> files proceeds upwards in the
  directory hierarchy. In the Gradle integration, the search will stop
  at the root Gradle project, but in other build systems, it can
  continue up to the root directory. This environment variable sets a
  path where the search should stop.

</p></dd><dt><code>ANDROID_LINT_JARS</code></dt><dd><p>  A path of jar files (using the path separator — semicolon on
  Windows, colon elsewhere) for lint to load extra lint checks from

</p></dd><dt><code>ANDROID_SDK_CACHE_DIR</code></dt><dd><p>  Sets the directory where lint should read and write its cache files.
  Lint has a number of databases that it caches between invocations,
  such as its binary representation of the SDK API database, used to
  look up API levels quickly. In the Gradle integration of lint, this
  cache directory is set to the root <code>build/</code> directory, but elsewhere
  the cache directory is located in a <code>lint</code> subfolder of the normal
  Android tooling cache directory, such as <code>~/.android</code>.

</p></dd><dt><code>LINT_OVERRIDE_CONFIGURATION</code></dt><dd><p>  Path to a lint XML file which should override any local <code>lint.xml</code>
  files closer to reported issues. This provides a way to globally
  change configuration.

</p><p>

  Corresponding system property: <code>lint.configuration.override</code>

</p></dd><dt><code>LINT_DO_NOT_REUSE_UAST_ENV</code></dt><dd><p>  Set to <code>true</code> to enable a workaround (if affected) for
  <a href="https://issuetracker.google.com/159733104">bug 159733104</a>
  until 7.0 is released.

</p><p>

  Corresponding system property: <code>lint.do.not.reuse.uast.env</code>

</p></dd><dt><code>LINT_API_DATABASE</code></dt><dd><p>  Point lint to an alternative API database XML file instead of the
  normally used <code>$SDK/platforms/android-?/data/api-versions.xml</code> file.

</p></dd></dl><p></p>
<a class="target" name="lintdevelopmentvariables">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/environmentvariables/lintdevelopmentvariables">&nbsp;</a><a class="target" name="toc15.1.3">&nbsp;</a><h3>Lint Development Variables</h3>
<p>


</p><dl><dt><code>LINT_PRINT_STACKTRACE</code></dt><dd><p>  If set to true, lint will print the full stack traces of any internal
  exceptions encountered during analysis. This is useful for authors of
  lint checks, or for power users who can reproduce a bug and want to
  report it with more details.

</p><p>

  Corresponding system property: <code>lint.print-stacktrace</code>

</p></dd><dt><code>LINT_TEST_KOTLINC</code></dt><dd><p>  When writing a lint check unit test, when creating a <code>compiled</code> or
  <code>bytecode</code> test file, lint can generate the .class file binary
  content automatically if it is pointed to the <code>kotlinc</code> compiler.

</p></dd><dt><code>LINT_TEST_JAVAC</code></dt><dd><p>  When writing a lint check unit test, when creating a <code>compiled</code> or
  <code>bytecode</code> test file, lint can generate the .class file binary
  content automatically if it is pointed to the <code>javac</code> compiler.

</p></dd><dt><code>INCLUDE_EXPENSIVE_LINT_TESTS</code></dt><dd><p>  When working on lint itself, set this environment variable to <code>true</code>
  some really, really expensive tests that we don't want run on the CI
  server or by the rest of the development team.

</p></dd></dl><p></p>
<a class="target" name="systemproperties">&nbsp;</a><a class="target" name="appendix:environmentvariablesandsystemproperties/systemproperties">&nbsp;</a><a class="target" name="toc15.2">&nbsp;</a><h2>System Properties</h2>
<p>




</p><div class="admonition tip">To set system properties when running lint via Gradle, try for
   example <code>./gradlew lintDebug -Dlint.baselines.continue=true</code></div>

<p></p><p>

</p><dl><dt><code>lint.baselines.continue</code></dt><dd><p>  When you configure a new baseline, lint normally fails the build
  after creating the baseline. You can set this system property to true
  to force lint to continue.

</p></dd><dt><code>lint.autofix</code></dt><dd><p>  Turns on auto-fixing (applying safe quickfixes) by default. This is a
  shortcut for invoking the <code>lintFix</code> targets or running the <code>lint</code>
  command with <code>--apply-suggestions</code>.

</p></dd><dt><code>lint.html.prefs</code></dt><dd><p>  This property allows you to customize lint's HTML reports. It
  consists of a comma separated list of property assignments, e.g.
  <code>./gradlew :app:lintDebug -Dlint.html.prefs=theme=darcula,window=5</code>

</p></dd></dl><div class="table"><table class="table"><tbody><tr><th style="text-align:left"> Property </th><th style="text-align:left"> Explanation and Values </th><th style="text-align:left"> Default </th></tr>
<tr><td style="text-align:left"> <code>theme</code> </td><td style="text-align:left"> <code>light</code>, <code>darcula</code>, <code>solarized</code> </td><td style="text-align:left"> <code>light</code> </td></tr>
<tr><td style="text-align:left"> <code>window</code> </td><td style="text-align:left"> Number of lines around problem </td><td style="text-align:left"> 3 </td></tr>
<tr><td style="text-align:left"> <code>maxIncidents</code> </td><td style="text-align:left"> Maximum incidents shown per issue type </td><td style="text-align:left"> 50 </td></tr>
<tr><td style="text-align:left"> <code>splitLimit</code> </td><td style="text-align:left"> Issue count before “More...” button </td><td style="text-align:left"> 8 </td></tr>
<tr><td style="text-align:left"> <code>maxPerIssue</code> </td><td style="text-align:left"> Name of split limit prior to 7.0 </td><td style="text-align:left"> 8 </td></tr>
<tr><td style="text-align:left"> <code>underlineErrors</code> </td><td style="text-align:left"> If true, wavy underlines, else highlight </td><td style="text-align:left"> <code>true</code> </td></tr>
</tbody></table></div>

<p></p><p>

</p><dl><table><tbody><tr valign="top"><td><dt><code>lint.unused-resources.exclude-tests</code></dt></td><td><dd><p>  Whether the unused resource check should exclude test sources as
  referenced resources.

</p></dd></td></tr><tr valign="top"><td><dt><code>lint.configuration.override</code></dt></td><td><dd><p>  Alias for <code>$LINT_OVERRIDE_CONFIGURATION</code>

</p></dd></td></tr><tr valign="top"><td><dt><code>lint.print-stacktrace</code></dt></td><td><dd><p>  Alias for <code>$LINT_PRINT_STACKTRACE</code>

</p></dd></td></tr><tr valign="top"><td><dt><code>lint.do.not.reuse.uast.env</code></dt></td><td><dd><p>  Alias for <code>$LINT_DO_NOT_REUSE_UAST_ENV</code>

</p></dd></td></tr><tr valign="top"><td><dt><code>android.lint.log-jar-problems</code></dt></td><td><dd><p>  Controls whether lint will complain about custom check lint jar
  loading problems. By default, true.

</p></dd></td></tr></tbody></table></dl><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility=&ldquo;visible&rdquo;)</script>
<p></p></span><div id="mdContextMenu" style="visibility:hidden"></div><div class="markdeepFooter"><i>formatted by <a href="https://casual-effects.com/markdeep" style="color:#999">Markdeep&nbsp;1.14&nbsp;&nbsp;</a></i><div style="display:inline-block;font-size:13px;font-family:'Times New Roman',serif;vertical-align:middle;transform:translate(-3px,-1px)rotate(135deg);">✒</div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>